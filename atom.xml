<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://x-vic.gitee.io/code/code/</id>
  <title>code</title>
  <subtitle>code</subtitle>
  <author>
    <name>Vic</name>
  </author>
  <updated>2021-06-03T00:27:16.466Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://x-vic.gitee.io/code/code/atom.xml"/>
  <link rel="alternate" href="https://x-vic.gitee.io/code/code/"/>
  <rights>Copyright by Vic</rights>
  <contributor>
    <name>Vic</name>
  </contributor>
  <entry>
    <title type="html">首页</title>
    <id>https://x-vic.gitee.io/code/code/</id>
    <link href="https://x-vic.gitee.io/code/code/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p><a href="./views/vue-next/reactive.html">Vue 源码学习</a> </p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">Blob</title>
    <id>https://x-vic.gitee.io/code/code/views/JS/</id>
    <link href="https://x-vic.gitee.io/code/code/views/JS/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="blob-是什么"> Blob 是什么</h2>
<blockquote>
<p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。</p>
</blockquote>
<p>Blob 实例包含两个属性：size 和 type。size 表示数据大小，type 是 MIME 类型。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 Blob 的功能，并将其扩展使其支持用户系统上的文件。</p>
<h2 id="blob-api"> Blob Api</h2>
<h3 id="构造函数"> 构造函数</h3>
<div><pre><code><span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span>blobParts<span>,</span> options<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>blobParts：由 ArrayBuffer，ArrayBufferView，Blob，DOMString等对象构成的数组。</li>
<li>options：一个可选对象，包含两个属性：
<ul>
<li>type---默认值为''，代表 MIME 类型</li>
<li>endings---默认值为'transparent'，用于指定包含行结束符 \n 的字符串如何被写入。它是以下两个值中的一个：&quot;native&quot;，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 &quot;transparent&quot;，代表会保持 blob 中保存的结束符不变。</li>
</ul>
</li>
</ul>
<p>例一：从字符串创建 Blob</p>
<div><pre><code><span>// </span>
<span>let</span> myBlobParts <span>=</span> <span>[</span><span>'&lt;html>&lt;h2>Hello Semlinker&lt;/h2>&lt;/html>'</span><span>]</span><span>;</span> <span>// an array consisting of a single DOMString</span>
<span>let</span> myBlob <span>=</span> <span>new</span> <span>Blob</span><span>(</span>myBlobParts<span>,</span> <span>{</span>type <span>:</span> <span>'text/html'</span><span>,</span> endings<span>:</span> <span>"transparent"</span><span>}</span><span>)</span><span>;</span> <span>// the blob</span>

console<span>.</span><span>log</span><span>(</span>myBlob<span>.</span>size <span>+</span> <span>" bytes size"</span><span>)</span><span>;</span>
<span>// Output: 37 bytes size</span>
console<span>.</span><span>log</span><span>(</span>myBlob<span>.</span>type <span>+</span> <span>" is the type"</span><span>)</span><span>;</span>
<span>// Output: text/html is the type</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>例二：从类型化数组和字符串创建 Blob</p>
<div><pre><code><span>let</span> hello <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span><span>[</span><span>72</span><span>,</span> <span>101</span><span>,</span> <span>108</span><span>,</span> <span>108</span><span>,</span> <span>111</span><span>]</span><span>)</span><span>;</span> <span>// 二进制格式的 "hello"</span>
<span>let</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>hello<span>,</span> <span>' '</span><span>,</span> <span>'semlinker'</span><span>]</span><span>,</span> <span>{</span>type<span>:</span> <span>'text/plain'</span><span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="方法"> 方法</h3>
<ul>
<li><code>slice([start[, end[, contentType]]])</code> 返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据</li>
<li><code>stream()</code> 返回一个能读取 blob 内容的 <code>ReadableStream</code></li>
<li><code>text()</code> 返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 <code>USVString</code></li>
<li><code>arrayBuffer()</code> 返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 <code>ArrayBuffer</code></li>
</ul>
<h2 id="blob-的使用场景"> Blob 的使用场景</h2>
<h3 id="分片上传"> 分片上传</h3>
<p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下：</p>
<div><pre><code><span>const</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>[</span><span>"a"</span><span>.</span><span>repeat</span><span>(</span><span>1000000</span><span>)</span><span>]</span><span>,</span> <span>"test.txt"</span><span>)</span><span>;</span>

<span>const</span> chunkSize <span>=</span> <span>40000</span><span>;</span>
<span>const</span> url <span>=</span> <span>"https://httpbin.org/post"</span><span>;</span>

<span>async</span> <span>function</span> <span>chunkedUpload</span><span>(</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> start <span>=</span> <span>0</span><span>;</span> start <span>&lt;</span> file<span>.</span>size<span>;</span> start <span>+=</span> chunkSize<span>)</span> <span>{</span>
    <span>const</span> chunk <span>=</span> file<span>.</span><span>slice</span><span>(</span>start<span>,</span> start <span>+</span> chunkSize <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>const</span> fd <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>
    fd<span>.</span><span>append</span><span>(</span><span>"data"</span><span>,</span> chunk<span>)</span><span>;</span>

    <span>await</span> <span>fetch</span><span>(</span>url<span>,</span> <span>{</span> method<span>:</span> <span>"post"</span><span>,</span> body<span>:</span> fd <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span>
      res<span>.</span><span>text</span><span>(</span><span>)</span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="从互联网下载数据"> 从互联网下载数据</h3>
<p>我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，比如：</p>
<div><pre><code><span>const</span> <span>downloadBlob</span> <span>=</span> <span>(</span><span>url<span>,</span> callback</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>
  xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> url<span>)</span>
  xhr<span>.</span>responseType <span>=</span> <span>'blob'</span>
  xhr<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>callback</span><span>(</span>xhr<span>.</span>response<span>)</span>
  <span>}</span>
  xhr<span>.</span><span>send</span><span>(</span><span>null</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>除了使用 <code>XMLHttpRequest</code> API 之外，我们也可以使用 fetch API 来实现以流的方式获取二进制数据。这里我们来看一下如何使用 <code>fetch</code> API 获取线上图片并本地显示，具体实现如下：</p>
<div><pre><code><span>const</span> myImage <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'img'</span><span>)</span>
<span>const</span> myRequest <span>=</span> <span>new</span> <span>Request</span><span>(</span><span>'flowers.jpg'</span><span>)</span>

<span>fetch</span><span>(</span>myRequest<span>)</span>
  <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>response</span><span>)</span> <span>{</span>
    <span>return</span> response<span>.</span><span>blob</span><span>(</span><span>)</span>
  <span>}</span><span>)</span>
 <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>myBlob</span><span>)</span> <span>{</span>
   <span>let</span> objectURL <span>=</span> <span>URL</span><span>.</span><span>createObjectURL</span><span>(</span>myBlob<span>)</span>
   myImage<span>.</span>src <span>=</span> objectURL
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>当 fetch 请求成功的时候，我们调用 response 对象的 <code>blob()</code> 方法，从 response 对象中读取一个 Blob 对象，然后使用 <code>createObjectURL()</code> 方法创建一个 objectURL，然后把它赋值给 <code>img</code> 元素的 <code>src</code> 属性从而显示这张图片。</p>
<h3 id="blob-用作-url"> Blob 用作 URL</h3>
<p>Blob 文件下载示例：</p>
<div><pre><code><span>const</span> <span>download</span> <span>=</span> <span>(</span><span>fileName<span>,</span> blob</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> link <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>"a"</span><span>)</span><span>;</span>
  <span>// 将 Blob 对象转换成 url</span>
  link<span>.</span>href <span>=</span> <span>URL</span><span>.</span><span>createObjectURL</span><span>(</span>blob<span>)</span><span>;</span>
  link<span>.</span>download <span>=</span> fileName<span>;</span>
  link<span>.</span><span>click</span><span>(</span><span>)</span><span>;</span>
  link<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
  <span>// 释放 Blob 对象</span>
  <span>URL</span><span>.</span><span>revokeObjectURL</span><span>(</span>link<span>.</span>href<span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> downloadBtn <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>"#downloadBtn"</span><span>)</span><span>;</span>
downloadBtn<span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> fileName <span>=</span> <span>"blob.txt"</span><span>;</span>
  <span>const</span> myBlob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span><span>'详解Blob'</span><span>]</span><span>,</span> <span>{</span> type<span>:</span> <span>"text/plain"</span> <span>}</span><span>)</span><span>;</span>
  <span>download</span><span>(</span>fileName<span>,</span> myBlob<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="blob-转换为-base64"> Blob 转换为 Base64</h3>
<p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64 编码的字符串。<code>Base64</code> 是一种基于 64 个可打印字符来表示二进制数据的表示方法。<br>
利用 FileReader API，我们也可以方便的实现图片本地预览功能，具体代码如下：</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>file<span>"</span></span> <span>accept</span><span><span>=</span><span>"</span>image/*<span>"</span></span> <span>onchange</span><span><span>=</span><span>"</span>loadFile(event)<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>img</span> <span>id</span><span><span>=</span><span>"</span>output<span>"</span></span><span>/></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>const</span> <span>loadFile</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
    <span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
    reader<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
      <span>const</span> output <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'output'</span><span>)</span><span>;</span>
      output<span>.</span>src <span>=</span> reader<span>.</span>result<span>;</span>
    <span>}</span><span>;</span>
    <span>// Blob 转 Base64</span>
    reader<span>.</span><span>readAsDataURL</span><span>(</span>event<span>.</span>target<span>.</span>files<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>在完成本地图片预览之后，我们可以直接把图片对应的 Data URLs 数据提交到服务器。针对这种情形，服务端需要做一些相关处理，才能正常保存上传的图片，这里以 Express 为例，具体处理代码如下：</p>
<div><pre><code><span>const</span> app <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>post</span><span>(</span><span>'/upload'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span><span>{</span>
    <span>let</span> imgData <span>=</span> req<span>.</span>body<span>.</span>imgData<span>;</span> <span>// 获取POST请求中的base64图片数据</span>
    <span>let</span> base64Data <span>=</span> imgData<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>^data:image\/\w+;base64,</span><span>/</span></span><span>,</span> <span>""</span><span>)</span><span>;</span>
    <span>let</span> dataBuffer <span>=</span> Buffer<span>.</span><span>from</span><span>(</span>base64Data<span>,</span> <span>'base64'</span><span>)</span><span>;</span>
    fs<span>.</span><span>writeFile</span><span>(</span><span>"image.png"</span><span>,</span> dataBuffer<span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
      <span>if</span><span>(</span>err<span>)</span><span>{</span>
        res<span>.</span><span>send</span><span>(</span>err<span>)</span><span>;</span>
      <span>}</span><span>else</span><span>{</span>
        res<span>.</span><span>send</span><span>(</span><span>"图片上传成功！"</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>对于 FileReader 对象来说，除了支持把 Blob/File 对象转换为 Data URL 之外，它还提供了 <code>readAsArrayBuffer()</code> 和 <code>readAsText()</code> 方法，用于把 Blob/File 对象转换为其它的数据格式。这里我们来看个 <code>readAsArrayBuffer()</code> 的使用示例：</p>
<div><pre><code><span>// 从 blob 获取 arrayBuffer</span>
<span>let</span> fileReader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span>

fileReader<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>event</span><span>)</span> <span>{</span>
  <span>let</span> arrayBuffer <span>=</span> fileReader<span>.</span>result
<span>}</span>
fileReader<span>.</span><span>readAsArrayBuffer</span><span>(</span>blob<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="图片压缩"> 图片压缩</h3>
<p>在一些场合中，我们希望在上传本地图片时，先对图片进行一定的压缩，然后再提交到服务器，从而减少传输的数据量。在前端要实现图片压缩，我们可以利用 Canvas 对象提供的 <code>toDataURL()</code> 方法，该方法接收 <code>type</code> 和 <code>encoderOptions</code> 两个可选参数。</p>
<p>其中 <code>type</code> 表示图片格式，默认为 <code>image/png</code>。而 <code>encoderOptions</code> 用于表示图片的质量，在指定图片格式为 <code>image/jpeg</code> 或 <code>image/webp</code> 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <code>0.92</code>，其他参数会被忽略。</p>
<p>下面我们来看一下具体如何实现图片压缩：</p>
<div><pre><code><span>// compress.js</span>
<span>const</span> <span>MAX_WIDTH</span> <span>=</span> <span>800</span><span>;</span> <span>// 图片最大宽度</span>

<span>function</span> <span>compress</span><span>(</span><span>base64<span>,</span> quality<span>,</span> mimeType</span><span>)</span> <span>{</span>
  <span>let</span> canvas <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>"canvas"</span><span>)</span><span>;</span>
  <span>let</span> img <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>"img"</span><span>)</span><span>;</span>
  img<span>.</span>crossOrigin <span>=</span> <span>"anonymous"</span><span>;</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    img<span>.</span>src <span>=</span> base64<span>;</span>
    img<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>let</span> targetWidth<span>,</span> targetHeight<span>;</span>
      <span>if</span> <span>(</span>img<span>.</span>width <span>></span> <span>MAX_WIDTH</span><span>)</span> <span>{</span>
        targetWidth <span>=</span> <span>MAX_WIDTH</span><span>;</span>
        targetHeight <span>=</span> <span>(</span>img<span>.</span>height <span>*</span> <span>MAX_WIDTH</span><span>)</span> <span>/</span> img<span>.</span>width<span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        targetWidth <span>=</span> img<span>.</span>width<span>;</span>
        targetHeight <span>=</span> img<span>.</span>height<span>;</span>
      <span>}</span>
      canvas<span>.</span>width <span>=</span> targetWidth<span>;</span>
      canvas<span>.</span>height <span>=</span> targetHeight<span>;</span>
      <span>let</span> ctx <span>=</span> canvas<span>.</span><span>getContext</span><span>(</span><span>"2d"</span><span>)</span><span>;</span>
      ctx<span>.</span><span>clearRect</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> targetWidth<span>,</span> targetHeight<span>)</span><span>;</span> <span>// 清除画布</span>
      ctx<span>.</span><span>drawImage</span><span>(</span>img<span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> canvas<span>.</span>width<span>,</span> canvas<span>.</span>height<span>)</span><span>;</span>
      <span>let</span> imageData <span>=</span> canvas<span>.</span><span>toDataURL</span><span>(</span>mimeType<span>,</span> quality <span>/</span> <span>100</span><span>)</span><span>;</span>
      <span>resolve</span><span>(</span>imageData<span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>对于返回的 Data URL 格式的图片数据，为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象：</p>
<div><pre><code><span>function</span> <span>dataUrlToBlob</span><span>(</span><span>base64<span>,</span> mimeType</span><span>)</span> <span>{</span>
  <span>let</span> bytes <span>=</span> window<span>.</span><span>atob</span><span>(</span>base64<span>.</span><span>split</span><span>(</span><span>","</span><span>)</span><span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
  <span>let</span> ab <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span>bytes<span>.</span>length<span>)</span><span>;</span>
  <span>let</span> ia <span>=</span> <span>new</span> <span>Uint8Array</span><span>(</span>ab<span>)</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bytes<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    ia<span>[</span>i<span>]</span> <span>=</span> bytes<span>.</span><span>charCodeAt</span><span>(</span>i<span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>ab<span>]</span><span>,</span> <span>{</span> type<span>:</span> mimeType <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>在转换完成后，我们就可以压缩后的图片对应的 Blob 对象封装在 FormData 对象中，然后再通过 AJAX 提交到服务器上：</p>
<div><pre><code><span>function</span> <span>uploadFile</span><span>(</span><span>url<span>,</span> blob</span><span>)</span> <span>{</span>
  <span>let</span> formData <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>
  <span>let</span> request <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
  formData<span>.</span><span>append</span><span>(</span><span>"image"</span><span>,</span> blob<span>)</span><span>;</span>
  request<span>.</span><span>open</span><span>(</span><span>"POST"</span><span>,</span> url<span>,</span> <span>true</span><span>)</span><span>;</span>
  request<span>.</span><span>send</span><span>(</span>formData<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其实 Canvas 对象除了提供 toDataURL() 方法之外，它还提供了一个 toBlob() 方法，该方法的语法如下：</p>
<div><p>Tips</p>
<p><code>canvas.toBlob(callback, mimeType, qualityArgument)</code></p>
</div>
<p>和 <code>toDataURL()</code> 方法相比，<code>toBlob()</code> 方法是异步的，因此多了个 <code>callback</code> 参数，这个 <code>callback</code> 回调方法默认的第一个参数就是转换好的 <code>blob</code> 文件信息。<br>
介绍完上述的内容，我们来看一下本地图片压缩完整的示例：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>本地图片压缩<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>file<span>"</span></span> <span>accept</span><span><span>=</span><span>"</span>image/*<span>"</span></span> <span>onchange</span><span><span>=</span><span>"</span>loadFile(event)<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./compress.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
      <span>const</span> <span>loadFile</span> <span>=</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
        <span>const</span> reader <span>=</span> <span>new</span> <span>FileReader</span><span>(</span><span>)</span><span>;</span>
        reader<span>.</span><span>onload</span> <span>=</span> <span>async</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
          <span>let</span> compressedDataURL <span>=</span> <span>await</span> <span>compress</span><span>(</span>
            reader<span>.</span>result<span>,</span>
            <span>90</span><span>,</span>
            <span>"image/jpeg"</span>
          <span>)</span><span>;</span>
          <span>let</span> compressedImageBlob <span>=</span> <span>dataUrlToBlob</span><span>(</span>compressedDataURL<span>)</span><span>;</span>
          <span>uploadFile</span><span>(</span><span>"https://httpbin.org/post"</span><span>,</span> compressedImageBlob<span>)</span><span>;</span>
        <span>}</span><span>;</span>
        reader<span>.</span><span>readAsDataURL</span><span>(</span>event<span>.</span>target<span>.</span>files<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
      <span>}</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="生成-pdf-文档"> 生成 PDF 文档</h3>
<p>在浏览器端，利用一些现成的开源库，比如 jsPDF，我们也可以方便地生成 PDF 文档。</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>客户端生成 PDF 示例<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h3</span><span>></span></span>客户端生成 PDF 示例<span><span><span>&lt;/</span>h3</span><span>></span></span>
    <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/jspdf@latest/dist/jspdf.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
      <span>(</span><span>function</span> <span>generatePdf</span><span>(</span><span>)</span> <span>{</span>
        <span>const</span> doc <span>=</span> <span>new</span> <span>jsPDF</span><span>(</span><span>)</span><span>;</span>
        doc<span>.</span><span>text</span><span>(</span><span>"Hello semlinker!"</span><span>,</span> <span>66</span><span>,</span> <span>88</span><span>)</span><span>;</span>
        <span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>doc<span>.</span><span>output</span><span>(</span><span>)</span><span>]</span><span>,</span> <span>{</span> type<span>:</span> <span>"application/pdf"</span> <span>}</span><span>)</span><span>;</span>
        blob<span>.</span><span>text</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>blobAsText</span><span>)</span> <span>=></span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>blobAsText<span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：</p>
<div><pre><code><span>let</span> imgData <span>=</span> <span>'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...'</span>
<span>let</span> doc <span>=</span> <span>new</span> <span>jsPDF</span><span>(</span><span>)</span><span>;</span>

doc<span>.</span><span>setFontSize</span><span>(</span><span>40</span><span>)</span>
doc<span>.</span><span>text</span><span>(</span><span>35</span><span>,</span> <span>25</span><span>,</span> <span>'Paranyan loves jsPDF'</span><span>)</span>
doc<span>.</span><span>addImage</span><span>(</span>imgData<span>,</span> <span>'JPEG'</span><span>,</span> <span>15</span><span>,</span> <span>40</span><span>,</span> <span>180</span><span>,</span> <span>160</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">web security</title>
    <id>https://x-vic.gitee.io/code/code/views/JS/security/</id>
    <link href="https://x-vic.gitee.io/code/code/views/JS/security/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xss"> xss</h2>
<p>跨站脚本攻击,英文全称是Cross Site Script，本来缩写是CSS,但是为了和层叠样式表(Cascading Style Sheet, CSS)有所区别,所以在安全领域叫做&quot;XSS&quot;。</p>
<p><strong>XSS攻击,通常是指黑客通过&quot;HTML注入&quot;篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击</strong>。在一开始，这种攻击的演示案例是跨域的，所以叫做&quot;跨站脚本&quot;。但是发展到今天。是否跨域已经不再重要。</p>
<h3 id="反射型-xss-非持久"> 反射型 XSS （非持久）</h3>
<p>反射型 XSS 只是简单地把用户输入的数据&quot;反射&quot;给浏览器。也就是说，黑客往往需要诱使用户&quot;点击&quot;一个恶意链接，才能攻击成功。反射型 XSS 也叫做&quot;非持久&quot;。</p>
<h3 id="存储型-xss"> 存储型 XSS</h3>
<p>存储型 XSS 会把用户输入的数据&quot;存储&quot;在服务器端。这种XSS具有很强的稳定性。比较常见的一个场景就是，黑客写下一篇包含恶意JavaScript代码的博客文章，文章发表后，所有访问该博客的用户，都会在它们的浏览器中执行这段恶意的JavaScript代码。黑客把恶意的脚本保存到服务端。所以这种XSS攻击就叫做&quot;存储型 XSS&quot;。</p>
<h3 id="dom-based-xss"> DOM based XSS</h3>
<p>实际上，这种类型的XSS并非按照&quot;数据是否保存在服务器端&quot;来划分。DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为 DOM Based XSS 的形成原因比较特别。通过<strong>修改页面的DOM节点形成的 XSS</strong>，称之为 DOM Based XSS。</p>
<h3 id="如何防御"> 如何防御</h3>
<ol>
<li>对输入内容的特定字符进行编码，例如：&quot;&lt;&gt;&quot;等</li>
<li>对重要的 cookie 设置 httpOnly</li>
<li>将不可信的值输出 URL参数之前，进行 URLEncode 操作，而对于从 URL参数中获取值一定要进行格式检测。</li>
</ol>
<p>举个攻击的例子：</p>
<div><pre><code>// $input 会将 url 中的 param 参数读取出来作为 div 的内容。
// http://www.a.com/test.php?param=<span><span><span>&lt;</span>script</span><span>></span></span><span><span><span>alert</span><span>(</span><span><span>/</span><span>xss</span><span>/</span></span><span>)</span></span></span><span><span><span>&lt;/</span>script</span><span>></span></span> 用户这般输入就造成 XSS 攻击了
<span><span>&lt;?php</span> 
  <span>$input</span> <span>=</span> <span>$_GET</span><span>[</span><span>"param"</span><span>]</span><span>;</span>
  <span>echo</span> <span>"&lt;div>"</span><span>.</span><span>$input</span><span>.</span><span>"&lt;/div>"</span><span>;</span>
<span>?></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="csrf"> csrf</h2>
<p>CSRF 英文全称是 Cross-site request forgery，又称为“跨站请求伪造”。<br>
顾名思义，CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。</p>
<h3 id="攻击过程"> 攻击过程</h3>
<ol>
<li>用户登陆 A 网站（此时浏览器已经存有 A 网站用户信息的 cookie）</li>
<li>再不关闭 A 网站的情况下，新开标签页访问黑客网站</li>
<li>黑客网站发送向 A 网站的请求（该请求会自动带上用户信息，而服务器无法知道这是个恶意请求）</li>
</ol>
<h3 id="如何防御-2"> 如何防御</h3>
<ol>
<li>对每个请求都设置一个 token,尤其是 post, delete 等危险 method</li>
<li>检查 reffer，检测链接访问来源</li>
<li>使用 X-iframe-options 头部控制别的网站用 iframe 嵌入你的内容</li>
</ol>
<h2 id="https"> https</h2>
<p>https 对内容加/解密使用对称加密算法。<br>
对称加密的密码使用非对称加密进行加密传输（公钥加密，私钥解密）。<br>
这样既保证了安全性，又兼顾了编/解码内容的效率。</p>
<p>对称加密密钥的传输：</p>
<ol>
<li>Client 发送 random1+对称加密套件列表+非对称加密套件列表</li>
<li>Server 收到信息， 选择 对称加密套件+非对称加密套件 并和 random2+证书(公钥在证书中) 一起返回</li>
<li>Client 验证证书有效性，并用 random1+random2 生成 pre-master 通过服务器公钥加密+浏览器确认 发送给 Server</li>
<li>Server 收到 pre-master，根据约定的加密算法对 random1+random2+pre-master（解密）生成 master-secret，然后发送服务器确认</li>
<li>Client 收到生成同样的 master-secert，对称<strong>加密秘钥</strong>传输完毕</li>
</ol>
<p>HTTPS 在 TCP 和 HTTP 中间加入了 SSL/TLS 安全层。</p>
<p>对发起 HTTP 请求的数据进行加密操作
对接收到 HTTP 的内容进行解密操作。</p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">TS 奇怪的符号</title>
    <id>https://x-vic.gitee.io/code/code/views/JS/ts/</id>
    <link href="https://x-vic.gitee.io/code/code/views/JS/ts/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="非空断言"> !非空断言</h2>
<p>从含有 <code>undefined</code> <code>null</code> 的类型合集中去除 <code>undefined</code> <code>null</code>。</p>
<div><pre><code><span>function</span> <span>myFunc</span><span>(</span>maybeString<span>:</span> <span>string</span> <span>|</span> <span>undefined</span> <span>|</span> <span>null</span><span>)</span> <span>{</span>
  <span>const</span> onlyString<span>:</span> <span>string</span> <span>=</span> maybeString<span>;</span> <span>// Error</span>
  <span>const</span> ignoreUndefinedAndNull<span>:</span> <span>string</span> <span>=</span> maybeString<span>!</span><span>;</span> <span>// Ok</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=""> ?.</h2>
<p>尝试着取属性。<br>
<code>?.</code> 只会验证对象是否为 <code>null</code> 或 <code>undefined，对于</code> <code>0</code> 或空字符串来说，并不会出现 “短路”。</p>
<div><pre><code>a<span>?.</span>b
a<span>?.</span><span>[</span><span>'b'</span><span>]</span>
obj<span>.</span>customMethod<span>?.</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="空值合并运算符"> ?? 空值合并运算符</h2>
<p>与逻辑或 <code>||</code> 运算符不同，当左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，其返回右侧的操作数，否则返回左侧的操作数。</p>
<div><pre><code><span>// 与可选链结合使用</span>
<span>let</span> customerCity <span>=</span> customer<span>?.</span>city <span>??</span> <span>"Unknown city"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="可选属性"> ?: 可选属性</h2>
<h3 id="工具类型"> 工具类型</h3>
<h4 id="partial-t-将-t-中的所有属性都变成可选的"> <code>Partial&lt;T&gt;</code> 将 T 中的所有属性都变成可选的</h4>
<div><pre><code><span>// Partial 的实现</span>
<span>type</span> <span>Partial<span>&lt;</span><span>T</span><span>></span></span> <span>=</span> <span>{</span>
  <span>[</span><span>P</span> <span>in</span> <span>keyof</span> <span>T</span><span>]</span><span>?</span><span>:</span> <span>T</span><span>[</span><span>P</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="required-t-将-t-中的所有属性都变成必须的"> <code>Required&lt;T&gt;</code> 将 T 中的所有属性都变成必须的</h4>
<div><pre><code><span>// Required 的实现</span>
<span>// 通过 -? 移除了可选属性中的 ?，使得属性从可选变为必选的。</span>
<span>type</span> <span>Required<span>&lt;</span><span>T</span><span>></span></span> <span>=</span> <span>{</span>
  <span>[</span><span>P</span> <span>in</span> <span>keyof</span> <span>T</span><span>]</span><span>-</span><span>?</span><span>:</span> <span>T</span><span>[</span><span>P</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="readonly-t-将某个类型所有属性变为只读属性"> <code>Readonly&lt;T&gt;</code> 将某个类型所有属性变为只读属性</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Readonly<span>&lt;</span><span>T</span><span>></span></span> <span>=</span> <span>{</span>
  <span>readonly</span> <span>[</span><span>P</span> <span>in</span> <span>keyof</span> <span>T</span><span>]</span><span>:</span> <span>T</span><span>[</span><span>P</span><span>]</span><span>;</span>
<span>}</span>
<span>// 如果将上面的 readonly 改成 -readonly， 就是移除子属性的 readonly 标识。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="record-k-extends-keyof-any-t-将-k-中所有的属性的值转化为-t-类型"> <code>Record&lt;K extends keyof any, T&gt;</code> 将 K 中所有的属性的值转化为 T 类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Record<span>&lt;</span><span>K</span> <span>extends</span> <span>keyof</span> <span>any</span><span>,</span> <span>T</span><span>></span></span> <span>=</span> <span>{</span>
  <span>[</span><span>P</span> <span>in</span> <span>K</span><span>]</span><span>:</span> <span>T</span><span>;</span>
<span>}</span>

<span>// 示例</span>
<span>interface</span> <span>PageInfo</span> <span>{</span>
  title<span>:</span> <span>string</span>
<span>}</span>

<span>type</span> <span>Page</span> <span>=</span> <span>"home"</span> <span>|</span> <span>"about"</span> <span>|</span> <span>"contact"</span>

<span>const</span> x<span>:</span> Record<span>&lt;</span>Page<span>,</span> PageInfo<span>></span> <span>=</span> <span>{</span>
  about<span>:</span> <span>{</span> title<span>:</span> <span>"about"</span> <span>}</span><span>,</span>
  contact<span>:</span> <span>{</span> title<span>:</span> <span>"contact"</span> <span>}</span><span>,</span>
  home<span>:</span> <span>{</span> title<span>:</span> <span>"home"</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="pick-t-k-extends-keyof-t-将-t-类型中包含-k-的一部分属性摘出来"> <code>Pick&lt;T, K extends keyof T&gt;</code> 将 T 类型中包含 K 的一部分属性摘出来</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Pick<span>&lt;</span><span>T</span><span>,</span> <span>K</span> <span>extends</span> <span>keyof</span> <span>T</span><span>></span></span> <span>=</span> <span>{</span>
  <span>[</span><span>P</span> <span>in</span> <span>K</span><span>]</span><span>:</span> <span>T</span><span>[</span><span>P</span><span>]</span><span>;</span>
<span>}</span>

<span>// 示例</span>
<span>interface</span> <span>Todo</span> <span>{</span>
  title<span>:</span> <span>string</span>
  description<span>:</span> <span>string</span>
  completed<span>:</span> <span>boolean</span>
<span>}</span>

<span>type</span> <span>TodoPreview</span> <span>=</span> Pick<span>&lt;</span>Todo<span>,</span> <span>"title"</span> <span>|</span> <span>"completed"</span><span>></span>

<span>const</span> todo<span>:</span> TodoPreview <span>=</span> <span>{</span>
  title<span>:</span> <span>"Clean room"</span><span>,</span>
  completed<span>:</span> <span>false</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="exclude-t-u-将-t-中包含-u-部分的属性剔除"> <code>Exclude&lt;T, U&gt;</code> 将 T 中包含 U 部分的属性剔除</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Exclude<span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>></span></span> <span>=</span> <span>T</span> <span>extends</span> <span><span>U</span></span> <span>?</span> <span>never</span> <span>:</span> <span>T</span>

<span>// 示例</span>
<span>type</span> <span><span>T1</span></span> <span>=</span> Exclude<span>&lt;</span><span>"a"</span> <span>|</span> <span>"b"</span> <span>|</span> <span>"c"</span><span>,</span> <span>"a"</span> <span>|</span> <span>"b"</span><span>></span><span>;</span> <span>// "c"</span>
<span>type</span> <span><span>T2</span></span> <span>=</span> Exclude<span>&lt;</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>(</span><span>(</span><span>)</span> <span>=></span> <span>void</span><span>)</span><span>,</span> <span>Function</span><span>></span><span>;</span> <span>// string | number</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="extract-t-u-取-t-与-u-的交集"> <code>Extract&lt;T, U&gt;</code> 取 T 与 U 的交集</h4>
<div><pre><code><span>type</span> <span>Extract<span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>></span></span> <span>=</span> <span>T</span> <span>extends</span> <span><span>U</span></span> <span>?</span> <span>T</span> <span>:</span> <span>never</span>

<span>// 示例</span>
<span>type</span> <span><span>T0</span></span> <span>=</span> Extract<span>&lt;</span><span>"a"</span> <span>|</span> <span>"b"</span> <span>|</span> <span>"c"</span><span>,</span> <span>"a"</span> <span>|</span> <span>"f"</span><span>></span><span>;</span> <span>// "a"</span>
<span>type</span> <span><span>T1</span></span> <span>=</span> Extract<span>&lt;</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>(</span><span>(</span><span>)</span> <span>=></span> <span>void</span><span>)</span><span>,</span> <span>Function</span><span>></span><span>;</span> <span>// () =>void</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="omit-t-k-extends-keyof-any-剔除-t-中健为-k-的属性"> <code>Omit&lt;T, K extends keyof any&gt;</code> 剔除 T 中健为 K 的属性</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Omit<span>&lt;</span><span>T</span><span>,</span> <span>K</span> <span>extends</span> <span>keyof</span> <span>any</span><span>></span></span> <span>=</span> Pick<span>&lt;</span><span>T</span><span>,</span> Exclude<span>&lt;</span><span>keyof</span> <span>T</span><span>,</span> <span>K</span><span>>></span>

<span>// 示例</span>
<span>interface</span> <span>Todo</span> <span>{</span>
  title<span>:</span> <span>string</span>
  description<span>:</span> <span>string</span>
  completed<span>:</span> <span>boolean</span>
<span>}</span>

<span>type</span> <span>TodoPreview</span> <span>=</span> Omit<span>&lt;</span>Todo<span>,</span> <span>"description"</span><span>></span>

<span>const</span> todo<span>:</span> TodoPreview <span>=</span> <span>{</span>
  title<span>:</span> <span>"Clean room"</span><span>,</span>
  completed<span>:</span> <span>false</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="nonnullable-过滤类型中的-null-及-undefined-类型"> <code>NonNullable</code> 过滤类型中的 <code>null</code> 及 <code>undefined</code> 类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>NonNullable<span>&lt;</span><span>T</span><span>></span></span> <span>=</span> <span>T</span> extendsnull <span>|</span> <span>undefined</span> <span>?</span> <span>never</span> <span>:</span> <span>T</span>

<span>// 示例</span>
<span>type</span> <span><span>T0</span></span> <span>=</span> NonNullable<span>&lt;</span><span>string</span> <span>|</span> <span>number</span> <span>|</span> <span>undefined</span><span>></span><span>;</span> <span>// string | number</span>
<span>type</span> <span><span>T1</span></span> <span>=</span> NonNullable<span>&lt;</span><span>string</span><span>[</span><span>]</span> <span>|</span> <span>null</span> <span>|</span> <span>undefined</span><span>></span><span>;</span> <span>// string[]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="returntype-t-获取函数-t-的返回类型"> <code>ReturnType&lt;T&gt;</code> 获取函数 T 的返回类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>ReturnType<span>&lt;</span><span>T</span> <span>extends</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span></span> <span>any</span><span>></span> <span>=</span> <span>T</span> <span>extends</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span> infer <span>R</span> <span>?</span> <span>R</span> <span>:</span> <span>any</span>

<span>// 示例</span>
<span>type</span> <span><span>T0</span></span> <span>=</span> ReturnType<span>&lt;</span><span>(</span><span>)</span> <span>=></span><span>string</span><span>></span><span>;</span> <span>// string</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="instancetype-获取构造函数类型的实例类型"> <code>InstanceType</code> 获取构造函数类型的实例类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>InstanceType<span>&lt;</span><span>T</span> <span>extendsnew</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span></span> <span>any</span><span>></span> <span>=</span> <span>T</span> <span>extendsnew</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span> infer <span>R</span> <span>?</span> <span>R</span> <span>:</span> <span>any</span>

<span>// 示例</span>
<span>class</span> <span><span>C</span></span> <span>{</span>
  x <span>=</span> <span>0</span><span>;</span>
  y <span>=</span> <span>0</span><span>;</span>
<span>}</span>

<span>type</span> <span><span>T0</span></span> <span>=</span> InstanceType<span>&lt;</span><span>typeof</span> <span>C</span><span>></span> <span>// C</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="thistype-t-用于指定上下文对象的类型"> <code>ThisType&lt;T&gt;</code> 用于指定上下文对象的类型</h4>
<div><pre><code><span>// 实现</span>
<span>interface</span> <span>ThisType<span>&lt;</span><span>T</span><span>></span></span> <span>{</span> <span>}</span>

<span>// 示例</span>
<span>// 注意：使用 ThisType&lt;T> 时，必须确保 --noImplicitThis 标志设置为 true。</span>
<span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span>
  age<span>:</span> <span>number</span>
<span>}</span>

<span>const</span> obj<span>:</span> ThisType<span>&lt;</span>Person<span>></span> <span>=</span> <span>{</span>
  <span>dosth</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>// string</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="parameters-t-获得函数的参数类型组成的元组类型"> <code>Parameters&lt;T&gt;</code> 获得函数的参数类型组成的元组类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>Parameters<span>&lt;</span><span>T</span> <span>extends</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span></span> <span>any</span><span>></span> <span>=</span> <span>T</span> <span>extends</span> <span>(</span><span>...</span>args<span>:</span> infer <span>P</span><span>)</span> <span>=></span> <span>any</span>
  <span>?</span> <span>P</span> <span>:</span> <span>never</span>

<span>// 示例</span>
<span>type</span> <span><span>A</span></span> <span>=</span> Parameters<span>&lt;</span><span>(</span><span>)</span> <span>=></span><span>void</span><span>></span><span>;</span> <span>// []</span>
<span>type</span> <span><span>B</span></span> <span>=</span> Parameters<span>&lt;</span>typeofArray<span>.</span>isArray<span>></span><span>;</span> <span>// [any]</span>
<span>type</span> <span><span>C</span></span> <span>=</span> Parameters<span>&lt;</span>typeofparseInt<span>></span><span>;</span> <span>// [string, (number | undefined)?]</span>
<span>type</span> <span><span>D</span></span> <span>=</span> Parameters<span>&lt;</span>typeofMath<span>.</span>max<span>></span><span>;</span> <span>// number[]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="constructorparameters-t-提取构造函数类型的所有参数类型"> <code>ConstructorParameters&lt;T&gt;</code> 提取构造函数类型的所有参数类型</h4>
<div><pre><code><span>// 实现</span>
<span>type</span> <span>ConstructorParameters<span>&lt;</span><span>T</span> <span>extendsnew</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>)</span> <span>=></span></span> <span>any</span><span>></span> <span>=</span> <span>T</span> <span>extendsnew</span> <span>(</span><span>...</span>args<span>:</span> infer <span>P</span><span>)</span> <span>=></span> <span>any</span> <span>?</span> <span>P</span> <span>:</span> <span>never</span>

<span>// 示例</span>
<span>type</span> <span><span>A</span></span> <span>=</span> ConstructorParameters<span>&lt;</span>ErrorConstructor<span>></span><span>;</span> <span>// [(string | undefined)?]</span>
<span>type</span> <span><span>B</span></span> <span>=</span> ConstructorParameters<span>&lt;</span>FunctionConstructor<span>></span><span>;</span> <span>// string[]</span>
<span>type</span> <span><span>C</span></span> <span>=</span> ConstructorParameters<span>&lt;</span>RegExpConstructor<span>></span><span>;</span> <span>// [string, (string | undefined)?]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="typeof-用来获取一个变量声明或对象的类型。"> <code>typeof</code> 用来获取一个变量声明或对象的类型。</h4>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
  name<span>:</span> <span>string</span>
  age<span>:</span> <span>number</span>
<span>}</span>

<span>const</span> sem<span>:</span> Person <span>=</span> <span>{</span> name<span>:</span> <span>'semlinker'</span><span>,</span> age<span>:</span> <span>30</span> <span>}</span><span>;</span>
<span>type</span> <span>Sem</span><span>=</span> <span>typeof</span> sem<span>;</span> <span>// -> Person</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="keyof-用来获取一个对象中的所有-key-值"> <code>keyof</code> 用来获取一个对象中的所有 key 值</h4>
<div><pre><code><span>interface</span> <span>Person</span> <span>{</span>
    name<span>:</span> <span>string</span><span>;</span>
    age<span>:</span> <span>number</span><span>;</span>
<span>}</span>

<span>type</span> <span><span>K1</span></span> <span>=</span> <span>keyof</span> Person<span>;</span> <span>// "name" | "age"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="in-用来遍历枚举类型"> <code>in</code> 用来遍历枚举类型</h4>
<div><pre><code><span>type</span> <span>Keys</span> <span>=</span> <span>"a"</span> <span>|</span> <span>"b"</span> <span>|</span> <span>"c"</span>

<span>type</span> <span>Obj</span> <span>=</span>  <span>{</span>
  <span>[</span>p <span>in</span> Keys<span>]</span><span>:</span> <span>any</span>
<span>}</span> <span>// -> { a: any, b: any, c: any }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="infer-在条件类型语句中-可以用-infer-声明一个类型变量并且对它进行使用"> <code>infer</code> 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用</h4>
<div><pre><code><span>// 提取 T 函数的返回值类型</span>
<span>type</span> <span>ReturnType<span>&lt;</span><span>T</span><span>></span></span> <span>=</span> <span>T</span> <span>extends</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>=></span> infer <span>R</span> 
  <span>?</span> <span>R</span> 
  <span>:</span> <span>any</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="运算符"> &amp; 运算符</h2>
<p>将多个类型合并为一个类型</p>
<div><pre><code><span>type</span> <span>PartialPointX</span> <span>=</span> <span>{</span> x<span>:</span> <span>number</span> <span>}</span>
<span>type</span> <span>Point</span> <span>=</span> PartialPointX <span>&amp;</span> <span>{</span> y<span>:</span> <span>number</span> <span>}</span>

<span>let</span> point<span>:</span> Point <span>=</span> <span>{</span>
  x<span>:</span> <span>1</span><span>,</span>
  y<span>:</span> <span>1</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="分隔符"> | 分隔符</h2>
<p>表示取值可以为多种类型中的一种</p>
<div><pre><code><span>const</span> <span>sayHello</span> <span>=</span> <span>(</span>name<span>:</span> <span>string</span> <span>|</span> <span>undefined</span><span>)</span> <span>=></span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="类型保护"> 类型保护</h3>
<p>联合类型是将类型的可能性拓宽了，但是很多时候我们也需要将这种可能性收窄，这就要用到类型保护了。</p>
<h4 id="in"> in</h4>
<div><pre><code><span>interface</span> <span>Admin</span> <span>{</span>
  name<span>:</span> <span>string</span>
  privileges<span>:</span> <span>string</span><span>[</span><span>]</span>
<span>}</span>

<span>interface</span> <span>Employee</span> <span>{</span>
  name<span>:</span> <span>string</span>
  startDate<span>:</span> Date
<span>}</span>

<span>type</span> <span>UnknownEmployee</span> <span>=</span> Employee <span>|</span> Admin

<span>function</span> <span>printEmployeeInformation</span><span>(</span>emp<span>:</span> UnknownEmployee<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>"privileges"</span> <span>in</span> emp<span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Privileges: "</span> <span>+</span> emp<span>.</span>privileges<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>"startDate"</span> <span>in</span> emp<span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>"Start Date: "</span> <span>+</span> emp<span>.</span>startDate<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="typeof"> typeof</h4>
<div><pre><code><span>function</span> <span>padLeft</span><span>(</span>value<span>:</span> <span>string</span><span>,</span> padding<span>:</span> <span>string</span> <span>|</span> <span>number</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> padding <span>===</span> <span>"number"</span><span>)</span> <span>{</span>
      <span>return</span> <span>Array</span><span>(</span>padding <span>+</span> <span>1</span><span>)</span><span>.</span><span>join</span><span>(</span><span>" "</span><span>)</span> <span>+</span> value<span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>typeof</span> padding <span>===</span> <span>"string"</span><span>)</span> <span>{</span>
      <span>return</span> padding <span>+</span> value<span>;</span>
  <span>}</span>
  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>Expected string or number, got '</span><span><span>${</span>padding<span>}</span></span><span>'.</span><span>`</span></span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="instanceof"> instanceof</h4>
<div><pre><code><span>interface</span> <span>Padder</span> <span>{</span>
  <span>getPaddingString</span><span>(</span><span>)</span><span>:</span> <span>string</span><span>;</span>
<span>}</span>

<span>class</span> <span>SpaceRepeatingPadder</span> <span>implements</span> <span>Padder</span> <span>{</span><span>}</span>

<span>class</span> <span>StringPadder</span> <span>implements</span> <span>Padder</span> <span>{</span><span>}</span>

<span>let</span> padder<span>:</span> Padder <span>=</span> <span>new</span> <span>SpaceRepeatingPadder</span><span>(</span><span>)</span><span>;</span>

<span>if</span> <span>(</span>padder <span>instanceof</span> <span>SpaceRepeatingPadder</span><span>)</span> <span>{</span>
  <span>// padder的类型收窄为 'SpaceRepeatingPadder'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">文件上传</title>
    <id>https://x-vic.gitee.io/code/code/views/JS/upload/</id>
    <link href="https://x-vic.gitee.io/code/code/views/JS/upload/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="请求端"> 请求端</h2>
<p>上传文件我们一般使用 <code>multipart/form-data</code>。这个规范首先需要请求类型（也就是 multipart/form-data）；然后就是一个 boundary（分隔符，文件分片上传的时候，需要用到）；然后就是声明内容的描述是 form-data 类型（字段名/文件名）。</p>
<h3 id="发送-formdata-请求的几种方式"> 发送 formData 请求的几种方式</h3>
<div><pre><code><span>const</span> file <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'file'</span><span>)</span><span>.</span>files<span>[</span><span>0</span><span>]</span>
<span>const</span> form <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>
form<span>.</span><span>append</span><span>(</span><span>'file'</span><span>,</span> file<span>)</span><span>;</span>
<span>// 方式一：使用 axios</span>
axios<span>.</span><span>post</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> form<span>)</span>
<span>// 方式二：使用 fecth</span>
<span>fetch</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> <span>{</span>
  method<span>:</span> <span>'POST'</span><span>,</span>
  body<span>:</span> form
<span>}</span><span>)</span>
<span>// 方式三：使用 xhr</span>
<span>const</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>
xhr<span>.</span><span>open</span><span>(</span><span>'POST'</span><span>,</span> <span>'http://localhost:3333/files'</span><span>,</span> <span>true</span><span>)</span>
xhr<span>.</span><span>onload</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>xhr<span>.</span>responseText<span>)</span>
<span>}</span>
xhr<span>.</span><span>send</span><span>(</span>form<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>主要还是要关注如何构造formData请求</p>
<ul>
<li>Request Headers
<ul>
<li>Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjlY2Kd7OA1gqxdb7</li>
</ul>
</li>
<li>Form Data
<ul>
<li>file: (binary)</li>
</ul>
</li>
</ul>
</div>
<h3 id="blob"> Blob</h3>
<p>使用 Blob 构造 formData 对象。</p>
<div><pre><code><span>const</span> json <span>=</span> <span>{</span> hello<span>:</span> <span>"world"</span> <span>}</span>
<span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>json<span>,</span> <span>null</span><span>,</span> <span>2</span><span>)</span><span>]</span><span>,</span> <span>{</span> type<span>:</span> <span>'application/json'</span> <span>}</span><span>)</span>
    
<span>const</span> form <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span>
form<span>.</span><span>append</span><span>(</span><span>'file'</span><span>,</span> blob<span>,</span> <span>'1.json'</span><span>)</span>
axios<span>.</span><span>post</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> form<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用 File 对 Blob 再一次进行包装（File 兼容性可能会差一些）</p>
<div><pre><code><span>const</span> json <span>=</span> <span>{</span> hello<span>:</span> <span>"world"</span> <span>}</span>
<span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>json<span>,</span> <span>null</span><span>,</span> <span>2</span><span>)</span><span>]</span><span>,</span> <span>{</span> type<span>:</span> <span>'application/json'</span> <span>}</span><span>)</span>
    
<span>const</span> file <span>=</span> <span>new</span> <span>File</span><span>(</span><span>[</span>blob<span>]</span><span>,</span> <span>'1.json'</span><span>)</span>
form<span>.</span><span>append</span><span>(</span><span>'file'</span><span>,</span> file<span>)</span>
axios<span>.</span><span>post</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> form<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="arraybuffer"> ArrayBuffer</h3>
<p><code>ArrayBuffer</code> 对象用来表示通用的、固定长度的原始二进制数据缓冲区。虽然它用的比较少，但是他是最贴近文件流的方式了。在浏览器中，他每个字节以十进制的方式存在。</p>
<div><pre><code><span>const</span> bufferArrary <span>=</span> <span>[</span><span>137</span><span>,</span><span>80</span><span>,</span><span>78</span><span>,</span><span>71</span><span>,</span><span>13</span><span>,</span><span>10</span><span>,</span><span>26</span><span>,</span><span>10</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>13</span><span>,</span><span>73</span><span>,</span><span>72</span><span>,</span><span>68</span><span>,</span><span>82</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>,</span><span>1</span><span>,</span><span>3</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>37</span><span>,</span><span>219</span><span>,</span><span>86</span><span>,</span><span>202</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>6</span><span>,</span><span>80</span><span>,</span><span>76</span><span>,</span><span>84</span><span>,</span><span>69</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>255</span><span>,</span><span>128</span><span>,</span><span>128</span><span>,</span><span>128</span><span>,</span><span>76</span><span>,</span><span>108</span><span>,</span><span>191</span><span>,</span><span>213</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>9</span><span>,</span><span>112</span><span>,</span><span>72</span><span>,</span><span>89</span><span>,</span><span>115</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>14</span><span>,</span><span>196</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>14</span><span>,</span><span>196</span><span>,</span><span>1</span><span>,</span><span>149</span><span>,</span><span>43</span><span>,</span><span>14</span><span>,</span><span>27</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>10</span><span>,</span><span>73</span><span>,</span><span>68</span><span>,</span><span>65</span><span>,</span><span>84</span><span>,</span><span>8</span><span>,</span><span>153</span><span>,</span><span>99</span><span>,</span><span>96</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>2</span><span>,</span><span>0</span><span>,</span><span>1</span><span>,</span><span>244</span><span>,</span><span>113</span><span>,</span><span>100</span><span>,</span><span>166</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>,</span><span>73</span><span>,</span><span>69</span><span>,</span><span>78</span><span>,</span><span>68</span><span>,</span><span>174</span><span>,</span><span>66</span><span>,</span><span>96</span><span>,</span><span>130</span><span>]</span>
<span>const</span> array <span>=</span> Uint8Array<span>.</span><span>from</span><span>(</span>bufferArrary<span>)</span>
<span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>array<span>]</span><span>,</span> <span>{</span>type<span>:</span> <span>'image/png'</span><span>}</span><span>)</span>
<span>const</span> form <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span>
form<span>.</span><span>append</span><span>(</span><span>'file'</span><span>,</span> blob<span>,</span> <span>'1.png'</span><span>)</span>
axios<span>.</span><span>post</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> form<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="base64"> Base64</h3>
<div><pre><code><span>const</span> base64 <span>=</span> <span>'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEUAAP+AgIBMbL/VAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg=='</span>
<span>const</span> byteCharacters <span>=</span> <span>atob</span><span>(</span>base64<span>)</span>
<span>const</span> byteNumbers <span>=</span> <span>new</span> <span>Array</span><span>(</span>byteCharacters<span>.</span>length<span>)</span>
<span>// 将字节转换成数组</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> byteCharacters<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
	byteNumbers<span>[</span>i<span>]</span> <span>=</span> byteCharacters<span>.</span><span>charCodeAt</span><span>(</span>i<span>)</span>
<span>}</span>
<span>// 将字节数组转换成为 Uint8Array 类型</span>
<span>const</span> array <span>=</span> Uint8Array<span>.</span><span>from</span><span>(</span>byteNumbers<span>)</span>
<span>// 将 Uint8Array 转换成 Blob 类型</span>
<span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>array<span>]</span><span>,</span> <span>{</span>type<span>:</span> <span>'image/png'</span><span>}</span><span>)</span>
<span>const</span> form <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span>
form<span>.</span><span>append</span><span>(</span><span>'file'</span><span>,</span> blob<span>,</span> <span>'1.png'</span><span>)</span>
axios<span>.</span><span>post</span><span>(</span><span>'http://localhost:3333/files'</span><span>,</span> form<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="服务端发送-formdata-请求"> 服务端发送 formData 请求</h3>
<p>首先来看看 <code>multipart/form-data</code> 规范：</p>
<div><pre><code>Content-type: multipart/form-data, boundary=AaB03x

--AaB03x
content-disposition: form-data; name=&quot;field1&quot;
Joe Blow
--AaB03x
content-disposition: form-data; name=&quot;pics&quot;; filename=&quot;file1.txt&quot;
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>原生 node 来构造 <code>multipart/form-data</code> 请求</p>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>
<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>
<span>// 定义一个分隔符，要确保唯一性</span>
<span>const</span> boundaryKey <span>=</span> <span>'-------------------------461591080941622511336662'</span><span>;</span>
<span>const</span> request <span>=</span> http<span>.</span><span>request</span><span>(</span><span>{</span>
    method<span>:</span> <span>'post'</span><span>,</span>
    host<span>:</span> <span>'localhost'</span><span>,</span>
    port<span>:</span> <span>'3333'</span><span>,</span>
    path<span>:</span> <span>'/files'</span><span>,</span>
    headers<span>:</span> <span>{</span>
        <span>'Content-Type'</span><span>:</span> <span>'multipart/form-data; boundary='</span> <span>+</span> boundaryKey<span>,</span> <span>// 在请求头上加上分隔符</span>
        <span>'Connection'</span><span>:</span> <span>'keep-alive'</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>// 写入内容头部</span>
request<span>.</span><span>write</span><span>(</span>
    <span><span>`</span><span>--</span><span><span>${</span>boundaryKey<span>}</span></span><span>\r\nContent-Disposition: form-data; name="file"; filename="1.png"\r\nContent-Type: image/jpeg\r\n\r\n</span><span>`</span></span>
<span>)</span><span>;</span>
<span>// 写入内容</span>
<span>const</span> fileStream <span>=</span> fs<span>.</span><span>createReadStream</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'../1.png'</span><span>)</span><span>)</span><span>;</span>
fileStream<span>.</span><span>pipe</span><span>(</span>request<span>,</span> <span>{</span> end<span>:</span> <span>false</span> <span>}</span><span>)</span><span>;</span>
fileStream<span>.</span><span>on</span><span>(</span><span>'end'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 写入尾部</span>
    request<span>.</span><span>end</span><span>(</span><span>'\r\n--'</span> <span>+</span> boundaryKey <span>+</span> <span>'--'</span> <span>+</span> <span>'\r\n'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
request<span>.</span><span>on</span><span>(</span><span>'response'</span><span>,</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>.</span>statusCode<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="接收端"> 接收端</h2>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span>
<span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> querystring <span>=</span> <span>require</span><span>(</span><span>'querystring'</span><span>)</span>
<span>const</span> server <span>=</span> http<span>.</span><span>createServer</span><span>(</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>req<span>.</span>url <span>===</span> <span>"/files"</span> <span>&amp;&amp;</span> req<span>.</span>method<span>.</span><span>toLowerCase</span><span>(</span><span>)</span> <span>===</span> <span>"post"</span><span>)</span> <span>{</span>
    <span>parseFile</span><span>(</span>req<span>,</span> res<span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
<span>function</span> <span>parseFile</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  req<span>.</span><span>setEncoding</span><span>(</span><span>"binary"</span><span>)</span>
  <span>let</span> body <span>=</span> <span>""</span>
  <span>let</span> fileName <span>=</span> <span>""</span>
  <span>// 边界字符</span>
  <span>let</span> boundary <span>=</span> req<span>.</span>headers<span>[</span><span>'content-type'</span><span>]</span>
    <span>.</span><span>split</span><span>(</span><span>'; '</span><span>)</span><span>[</span><span>1</span><span>]</span>
    <span>.</span><span>replace</span><span>(</span><span>"boundary="</span><span>,</span> <span>""</span><span>)</span>
  
  req<span>.</span><span>on</span><span>(</span><span>"data"</span><span>,</span> <span>function</span><span>(</span><span>chunk</span><span>)</span> <span>{</span>
    body <span>+=</span> chunk
  <span>}</span><span>)</span>
  req<span>.</span><span>on</span><span>(</span><span>"end"</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>// 按照分解符切分</span>
    <span>const</span> list <span>=</span> body<span>.</span><span>split</span><span>(</span>boundary<span>)</span>
    <span>let</span> contentType <span>=</span> <span>''</span>
    <span>let</span> fileName <span>=</span> <span>''</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> list<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>list<span>[</span>i<span>]</span><span>.</span><span>includes</span><span>(</span><span>'Content-Disposition'</span><span>)</span><span>)</span> <span>{</span>
        <span>const</span> data <span>=</span> list<span>[</span>i<span>]</span><span>.</span><span>split</span><span>(</span><span>'\r\n'</span><span>)</span>
        <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> data<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span>
          <span>// 从头部拆分出名字和类型</span>
          <span>if</span> <span>(</span>data<span>[</span>j<span>]</span><span>.</span><span>includes</span><span>(</span><span>'Content-Disposition'</span><span>)</span><span>)</span> <span>{</span>
            <span>const</span> info <span>=</span> data<span>[</span>j<span>]</span><span>.</span><span>split</span><span>(</span><span>':'</span><span>)</span><span>[</span><span>1</span><span>]</span><span>.</span><span>split</span><span>(</span><span>';'</span><span>)</span>
            fileName <span>=</span> info<span>[</span>info<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span><span>split</span><span>(</span><span>'='</span><span>)</span><span>[</span><span>1</span><span>]</span><span>.</span><span>replace</span><span>(</span><span><span>/</span><span>"</span><span>/</span><span>g</span></span><span>,</span> <span>''</span><span>)</span>
            console<span>.</span><span>log</span><span>(</span>fileName<span>)</span>
          <span>}</span>
          <span>if</span> <span>(</span>data<span>[</span>j<span>]</span><span>.</span><span>includes</span><span>(</span><span>'Content-Type'</span><span>)</span><span>)</span> <span>{</span>
            contentType <span>=</span> data<span>[</span>j<span>]</span><span>;</span>
            console<span>.</span><span>log</span><span>(</span>data<span>[</span>j<span>]</span><span>.</span><span>split</span><span>(</span><span>':'</span><span>)</span><span>[</span><span>1</span><span>]</span><span>)</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>// 去除前面的请求头</span>
    <span>const</span> start <span>=</span> body<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>indexOf</span><span>(</span>contentType<span>)</span> <span>+</span> contentType<span>.</span>length <span>+</span> <span>4</span> <span>// 有多\r\n\r\n</span>
    <span>const</span> startBinary <span>=</span> body<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>substring</span><span>(</span>start<span>)</span>
    <span>const</span> end <span>=</span> startBinary<span>.</span><span>indexOf</span><span>(</span><span>"--"</span> <span>+</span> boundary <span>+</span> <span>"--"</span><span>)</span> <span>-</span> <span>2</span> <span>// 前面有多\r\n</span>
     <span>// 去除后面的分隔符</span>
    <span>const</span> binary <span>=</span> startBinary<span>.</span><span>substring</span><span>(</span><span>0</span><span>,</span> end<span>)</span>
    <span>const</span> bufferData <span>=</span> Buffer<span>.</span><span>from</span><span>(</span>binary<span>,</span> <span>"binary"</span><span>)</span>
    fs<span>.</span><span>writeFile</span><span>(</span>fileName<span>,</span> bufferData<span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
      res<span>.</span><span>end</span><span>(</span><span>"sucess"</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

server<span>.</span><span>listen</span><span>(</span><span>3333</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">webpack</title>
    <id>https://x-vic.gitee.io/code/code/views/JS/webpack/</id>
    <link href="https://x-vic.gitee.io/code/code/views/JS/webpack/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p>本文部分摘录<a href="https://segmentfault.com/a/1190000023016347" target="_blank" rel="noopener noreferrer">webpack 系列</a></p>
<h2 id="loader"> loader</h2>
<p>loader 文件处理器是一个 CommonJs 风格的函数，该函数接收一个 String/Buffer 类型的入参，并返回一个 String/Buffer 类型的返回值。</p>
<h3 id="同步-loader"> 同步 loader</h3>
<div><pre><code><span>// content：文件内容；map：sourcemap；meta：一些源信息</span>
module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>content<span>,</span> map<span>,</span> meta</span><span>)</span> <span>{</span>
  <span>// 一些同步操作</span>
  outputContent <span>=</span> <span>syncFn</span><span>(</span>content<span>)</span>
  <span>return</span> outputContent
<span>}</span>

<span>// 如果返回结果只有一个，也可以直接使用 return 返回结果。但是，如果有些情况下还需要返回其他内容，如 sourceMap 或是 AST 语法树，这个时候可以借助 webpack 提供的 api this.callback</span>
module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>content<span>,</span> map<span>,</span> meta</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span><span>callback</span><span>(</span>
    err<span>:</span> Error <span>|</span> <span>null</span><span>,</span>
    content<span>:</span> string <span>|</span> Buffer<span>,</span>
    sourceMap<span>?</span><span>:</span> SourceMap<span>,</span>
    meta<span>?</span><span>:</span> any
  <span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="异步-loader"> 异步 loader</h3>
<p>异步 loader，使用 <code>this.async</code> 来获取 <code>callback</code> 函数。</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>source</span><span>)</span> <span>{</span>
  <span>var</span> callback <span>=</span> <span>this</span><span>.</span><span>async</span><span>(</span><span>)</span>
  <span>// 做异步的事</span>
  <span>asyncFn</span><span>(</span>content<span>,</span> <span>function</span><span>(</span><span>err<span>,</span> result</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>err<span>)</span> <span>return</span> <span>callback</span><span>(</span>err<span>)</span>
    <span>callback</span><span>(</span><span>null</span><span>,</span> result<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="一个简单的-md-loader-示例"> 一个简单的 md-loader 示例</h3>
<div><pre><code><span>const</span> marked <span>=</span> <span>require</span><span>(</span><span>'marked'</span><span>)</span>

<span>const</span> loaderUtils <span>=</span> <span>require</span><span>(</span><span>'loader-utils'</span><span>)</span>
module<span>.</span><span>exports</span> <span>=</span> <span>function</span><span>(</span><span>content</span><span>)</span> <span>{</span>
  <span>// 有缓存的情况下，合理利用缓存</span>
  <span>this</span><span>.</span>cacheable <span>&amp;&amp;</span> <span>this</span><span>.</span><span>cacheable</span><span>(</span><span>)</span>
  <span>const</span> options <span>=</span> loaderUtils<span>.</span><span>getOptions</span><span>(</span><span>this</span><span>)</span>
  <span>try</span> <span>{</span>
    marked<span>.</span><span>setOptions</span><span>(</span>options<span>)</span>
    <span>return</span> <span>marked</span><span>(</span>content<span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>emitError</span><span>(</span>err<span>)</span>
    <span>return</span> <span>null</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="插件"> 插件</h2>
<p>通过插件我们可以扩展webpack，在合适的时机通过Webpack提供的 API 改变输出结果，使webpack可以执行更广泛的任务，拥有更强的构建能力。</p>
<h3 id="插件结构"> 插件结构</h3>
<ol>
<li>读取配置的过程中会先执行 new HelloPlugin(options) 初始化一个 HelloPlugin 获得其实例</li>
<li>初始化 compiler 对象后调用 HelloPlugin.apply(compiler) 给插件实例传入 compiler 对象</li>
<li>插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件</li>
</ol>
<div><pre><code><span>class</span> <span>HelloPlugin</span> <span>{</span>
  <span>// 配置处理</span>
  <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span><span>}</span>
  <span>// Webpack 会调用这个方法给插件实例传入 compiler 对象</span>
  <span>apply</span><span>(</span><span>compiler</span><span>)</span> <span>{</span>
    <span>// 在emit阶段插入钩子函数，用于特定时机处理额外的逻辑；</span>
    compiler<span>.</span>hooks<span>.</span>emit<span>.</span><span>tap</span><span>(</span><span>'HelloPlugin'</span><span>,</span> <span>(</span><span>compilation</span><span>)</span> <span>=></span> <span>{</span>
      <span>// 在功能流程完成后可以调用 webpack 提供的回调函数；</span>
    <span>}</span><span>)</span>
    <span>// 监听 webpack 发射出来的 emit 事件</span>
    compiler<span>.</span><span>plugin</span><span>(</span><span>'emit'</span><span>,</span> <span>function</span> <span>(</span><span>compilation<span>,</span> callback</span><span>)</span> <span>{</span>
      <span>// 支持处理逻辑</span>
      <span>// 处理完毕后执行 callback 以通知 Webpack</span>
      <span>// 如果不执行 callback，运行流程将会一直卡在这不往下执行</span>
      <span>callback</span><span>(</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> HelloPlugin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="构建流程"> 构建流程</h3>
<ol>
<li>
<p>校验配置文件 ：读取命令行传入或者 webpack.config.js 文件，初始化本次构建的配置参数</p>
</li>
<li>
<p>生成 <code>Compiler</code> 对象：执行配置文件中的插件实例化语句 new MyWebpackPlugin()，为 webpack 事件流挂上自定义 hooks</p>
</li>
<li>
<p>进入 entryOption 阶段：webpack 开始读取配置的 Entries，递归遍历所有的入口文件</p>
</li>
<li>
<p>run/watch：如果运行在 watch 模式则执行 watch 方法，否则执行 run 方法</p>
</li>
<li>
<p>compilation：创建 Compilation 对象回调 compilation 相关钩子，依次进入每一个入口文件(entry)，使用 loader 对文件进行编译。通过 compilation 我可以可以读取到 module 的 resource（资源路径）、loaders（使用的 loader）等信息。再将编译好的文件内容使用 acorn 解析生成 AST 静态语法树。然后递归、重复的执行这个过程，
所有模块和和依赖分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装    <strong>webpack_require</strong> 来模拟模块化操作</p>
</li>
<li>
<p>emit：所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的 compilation.assets 上拿到所需数据，其中包括即将输出的资源、代码块 Chunk 等等信息。</p>
</li>
</ol>
<h3 id="compiler-与-compilation"> compiler 与 compilation</h3>
<p>compiler 对象包含了当前运行 webpack 的配置，包括 entry、output、loaders 等配置，这个对象在启动 webpack 时被实例化，而且是全局唯一的。plugin 可以通过该对象获取到 webpack 的配置信息进行处理。</p>
<p>compilation 的职责就是构建模块和 chunk，并利用插件优化构建过程。它和 compiler 用法相同，钩子类型不同，也可以在某些钩子上访问 tapAsync 和 tapPromise。</p>
<h2 id="简单实现打包器"> 简单实现打包器</h2>
<p>先来看看 webpack 的整体运行流程：</p>
<ol>
<li>读取参数</li>
<li>实例化 Compiler</li>
<li>entryOption 阶段，读取入口文件</li>
<li>Loader 编译对应文件，解析成 AST</li>
<li>找到对应依赖，递归编译处理，生成 chunk</li>
<li>输出到 dist</li>
</ol>
<p>下边的简单实现流程为：</p>
<ol>
<li>解析 entry，得到 dependencies、code</li>
<li>解析 entry 的过程中遇到依赖，则回到第一步，直到得到所有文件的路径、依赖、代码信息</li>
<li>根据上面得到的所有文件信息，生成 bundle</li>
<li>调用自定义的 require 函数，传入文件路径</li>
<li>eval code 注入 require 函数</li>
</ol>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
<span>const</span> parser <span>=</span> <span>require</span><span>(</span><span>'@babel/parser'</span><span>)</span> <span>//解析成ast</span>
<span>const</span> traverse <span>=</span> <span>require</span><span>(</span><span>'@babel/traverse'</span><span>)</span><span>.</span>default <span>//遍历ast</span>
<span>const</span> <span>{</span> transformFromAst <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'@babel/core'</span><span>)</span> <span>//ES6转换ES5</span>
module<span>.</span>exports <span>=</span> <span>class</span> <span>Webpack</span> <span>{</span>
  <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> entry<span>,</span> output <span>}</span> <span>=</span> options
    <span>this</span><span>.</span>entry <span>=</span> entry
    <span>this</span><span>.</span>output <span>=</span> output
    <span>this</span><span>.</span>modulesArr <span>=</span> <span>[</span><span>]</span>
  <span>}</span>
  <span>// 生成一个大对象，键为文件路径，每个键包含该文件的依赖和代码字符</span>
  <span>run</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> info <span>=</span> <span>this</span><span>.</span><span>build</span><span>(</span><span>this</span><span>.</span>entry<span>)</span>
    <span>this</span><span>.</span>modulesArr<span>.</span><span>push</span><span>(</span>info<span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>this</span><span>.</span>modulesArr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>// 判断有依赖对象,递归解析所有依赖项</span>
      <span>const</span> item <span>=</span> <span>this</span><span>.</span>modulesArr<span>[</span>i<span>]</span>
      <span>const</span> <span>{</span> dependencies <span>}</span> <span>=</span> item
      <span>if</span> <span>(</span>dependencies<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>let</span> j <span>in</span> dependencies<span>)</span> <span>{</span>
          <span>this</span><span>.</span>modulesArr<span>.</span><span>push</span><span>(</span><span>this</span><span>.</span><span>build</span><span>(</span>dependencies<span>[</span>j<span>]</span><span>)</span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
    <span>//数组结构转换</span>
    <span>const</span> obj <span>=</span> <span>{</span><span>}</span>
    <span>this</span><span>.</span>modulesArr<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span>
      obj<span>[</span>item<span>.</span>entryFile<span>]</span> <span>=</span> <span>{</span>
        dependencies<span>:</span> item<span>.</span>dependencies<span>,</span>
        code<span>:</span> item<span>.</span>code<span>,</span>
      <span>}</span>
    <span>}</span><span>)</span>
    <span>this</span><span>.</span><span>emitFile</span><span>(</span>obj<span>)</span>
  <span>}</span>
  <span>build</span><span>(</span><span>entryFile</span><span>)</span> <span>{</span>
    <span>const</span> conts <span>=</span> fs<span>.</span><span>readFileSync</span><span>(</span>entryFile<span>,</span> <span>'utf-8'</span><span>)</span>
    <span>const</span> ast <span>=</span> parser<span>.</span><span>parse</span><span>(</span>conts<span>,</span> <span>{</span>
      sourceType<span>:</span> <span>'module'</span><span>,</span>
    <span>}</span><span>)</span>
    <span>//  console.log(ast)</span>
    <span>// 遍历所有的 import 模块,存入dependecies</span>
    <span>const</span> dependencies <span>=</span> <span>{</span><span>}</span>
    <span>traverse</span><span>(</span>ast<span>,</span> <span>{</span>
      <span>//  类型为 ImportDeclaration 的 AST 节点，</span>
      <span>// 其实就是我们的 import xxx from xxxx</span>
      <span>ImportDeclaration</span><span>(</span><span><span>{</span> node <span>}</span></span><span>)</span> <span>{</span>
        <span>const</span> newPath <span>=</span>
          <span>'./'</span> <span>+</span> path<span>.</span><span>join</span><span>(</span>path<span>.</span><span>dirname</span><span>(</span>entryFile<span>)</span><span>,</span> node<span>.</span>source<span>.</span>value<span>)</span>
        dependencies<span>[</span>node<span>.</span>source<span>.</span>value<span>]</span> <span>=</span> newPath
        <span>// console.log(dependencies)</span>
      <span>}</span><span>,</span>
    <span>}</span><span>)</span>
    <span>// 将转化后 ast 的代码重新转化成代码</span>
    <span>// 并通过配置 @babel/preset-env 预置插件编译成 es5</span>
    <span>const</span> <span>{</span> code <span>}</span> <span>=</span> <span>transformFromAst</span><span>(</span>ast<span>,</span> <span>null</span><span>,</span> <span>{</span>
      presets<span>:</span> <span>[</span><span>'@babel/preset-env'</span><span>]</span><span>,</span>
    <span>}</span><span>)</span>
    <span>return</span> <span>{</span>
      entryFile<span>,</span>
      dependencies<span>,</span>
      code<span>,</span>
    <span>}</span>
  <span>}</span>
  <span>emitFile</span><span>(</span><span>allInfo</span><span>)</span> <span>{</span>
    <span>//生成bundle.js</span>
    <span>const</span> filePath <span>=</span> path<span>.</span><span>join</span><span>(</span><span>this</span><span>.</span>output<span>.</span>path<span>,</span> <span>this</span><span>.</span>output<span>.</span>filename<span>)</span>
    <span>const</span> allInfoString <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>allInfo<span>)</span>
    <span>const</span> bundle <span>=</span> <span><span>`</span><span>(function(modules){
      // moduleId 为传入的 filename ，即模块的唯一标识符
      function require(moduleId){
        function localRequire(relativePath){
          return require(modules[moduleId].dependencies[relativePath]) 
        }
        var exports = {};
        (function(require,exports,code){
          eval(code)
        })(localRequire,exports,modules[moduleId].code)
        return exports;
      }
      require('</span><span><span>${</span><span>this</span><span>.</span>entry<span>}</span></span><span>')
    })(</span><span><span>${</span>allInfoString<span>}</span></span><span>)</span><span>`</span></span>
    fs<span>.</span><span>writeFileSync</span><span>(</span>filePath<span>,</span> bundle<span>,</span> <span>'utf-8'</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// 使用如下：</span>
<span>// new Webapck(options).run()</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">堆</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/heap/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/heap/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="堆的实现"> 堆的实现</h2>
<div><pre><code><span>class</span> <span>Heap</span> <span>{</span>
  <span>constructor</span><span>(</span>list <span>=</span> <span>[</span><span>]</span><span>,</span> <span>compare</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>(</span>a <span>-</span> b<span>)</span><span>)</span> <span>{</span>
    <span>// 数组维护的堆</span>
    <span>this</span><span>.</span>list <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>compare <span>=</span> compare
    list<span>.</span><span>forEach</span><span>(</span><span>e</span> <span>=></span> <span>this</span><span>.</span><span>push</span><span>(</span>e<span>)</span><span>)</span>
  <span>}</span>
  <span>get</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>list<span>.</span>length
  <span>}</span>
  <span>get</span> <span>top</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>list<span>[</span><span>0</span><span>]</span>
  <span>}</span>
  <span>// 入队</span>
  <span>push</span><span>(</span><span>e</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>list<span>.</span><span>push</span><span>(</span>e<span>)</span>
    <span>this</span><span>.</span><span>shiftUp</span><span>(</span><span>)</span>
  <span>}</span>
  <span>// 出队</span>
  <span>pop</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>size <span>&lt;=</span> <span>0</span><span>)</span> <span>return</span> <span>'没有元素了'</span>
    <span>const</span> front <span>=</span> <span>this</span><span>.</span>list<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>size <span>>=</span> <span>1</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>list<span>.</span><span>unshift</span><span>(</span><span>this</span><span>.</span>list<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span>
      <span>this</span><span>.</span><span>shiftDown</span><span>(</span><span>)</span>
    <span>}</span>
    <span>return</span> front
  <span>}</span>
  <span>// 上浮</span>
  <span>shiftUp</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> i <span>=</span> <span>this</span><span>.</span>size <span>-</span> <span>1</span>
    <span>while</span> <span>(</span>i <span>></span> <span>0</span><span>)</span> <span>{</span>
      <span>const</span> parentIndex <span>=</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>)</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span><span>compare</span><span>(</span><span>this</span><span>.</span>list<span>[</span>i<span>]</span><span>,</span> <span>this</span><span>.</span>list<span>[</span>parentIndex<span>]</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>swap</span><span>(</span>i<span>,</span> parentIndex<span>)</span>
        i <span>=</span> parentIndex
      <span>}</span> <span>else</span> <span>{</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>// 下潜</span>
  <span>shiftDown</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> i <span>=</span> <span>0</span>
    <span>while</span> <span>(</span>i <span>&lt;</span> <span>this</span><span>.</span>size <span>-</span> <span>1</span><span>)</span> <span>{</span>
      <span>let</span> findIndex <span>=</span> i
      <span>const</span> subLeftIndex <span>=</span> <span>2</span> <span>*</span> i <span>+</span> <span>1</span><span>,</span> subRightIndex <span>=</span> <span>2</span> <span>*</span> i <span>+</span> <span>2</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span><span>compare</span><span>(</span><span>this</span><span>.</span>list<span>[</span>findIndex<span>]</span><span>,</span> <span>this</span><span>.</span>list<span>[</span>subLeftIndex<span>]</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        findIndex <span>=</span> subLeftIndex
      <span>}</span>
      <span>if</span> <span>(</span><span>this</span><span>.</span><span>compare</span><span>(</span><span>this</span><span>.</span>list<span>[</span>findIndex<span>]</span><span>,</span> <span>this</span><span>.</span>list<span>[</span>subRightIndex<span>]</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        findIndex <span>=</span> subRightIndex
      <span>}</span>
      <span>if</span> <span>(</span>i <span>!==</span> findIndex<span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>swap</span><span>(</span>i<span>,</span> findIndex<span>)</span>
        i <span>=</span> findIndex
      <span>}</span> <span>else</span> <span>{</span>
        <span>break</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>swap</span><span>(</span><span>index1<span>,</span> index2</span><span>)</span> <span>{</span>
    <span>const</span> temp <span>=</span> <span>this</span><span>.</span>list<span>[</span>index1<span>]</span>
    <span>this</span><span>.</span>list<span>[</span>index1<span>]</span> <span>=</span> <span>this</span><span>.</span>list<span>[</span>index2<span>]</span>
    <span>this</span><span>.</span>list<span>[</span>index2<span>]</span> <span>=</span> temp
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h2 id="基础应用"> 基础应用</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener noreferrer">#剑指 Offer 40 最小的k个数</a></li>
</ol>
<div><pre><code><span>function</span> <span>getLeastNumbers</span><span>(</span><span>arr<span>,</span> k</span><span>)</span> <span>{</span>
  <span>// 维护 k 个元素的大顶堆</span>
  <span>const</span> heap <span>=</span> <span>new</span> <span>Heap</span><span>(</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>// 数量不足时，直接入队</span>
    <span>if</span> <span>(</span>heap<span>.</span>size <span>&lt;</span> k<span>)</span> <span>{</span>
      heap<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span>heap<span>.</span>list<span>[</span><span>0</span><span>]</span> <span>></span> arr<span>[</span>i<span>]</span><span>)</span> <span>{</span>
      heap<span>.</span><span>pop</span><span>(</span><span>)</span>
      heap<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> heap<span>.</span>list
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/last-stone-weight/" target="_blank" rel="noopener noreferrer">#1046 最后一块石头的重量</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener noreferrer">#703 数据流中的第 K 大元素</a></li>
</ol>
<div><pre><code><span>class</span> <span>KthLargest</span> <span>{</span>
  <span>constructor</span><span>(</span><span>k<span>,</span> nums</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>k <span>=</span> k
    <span>// 维护 k 个元素的小顶堆</span>
    <span>this</span><span>.</span>heap <span>=</span> <span>new</span> <span>Heap</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>(</span>b <span>-</span> a<span>)</span><span>)</span>
    <span>for</span> <span>(</span><span>const</span> x <span>of</span> nums<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>add</span><span>(</span>x<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>add</span><span>(</span><span>val</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>heap<span>.</span><span>push</span><span>(</span>val<span>)</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>heap<span>.</span>size <span>></span> <span>this</span><span>.</span>k<span>)</span> <span>this</span><span>.</span>heap<span>.</span><span>pop</span><span>(</span><span>)</span>
    <span>return</span> <span>this</span><span>.</span>heap<span>.</span>top
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener noreferrer">#373 查找和最小的K对数字</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener noreferrer">#215 数组中的第K个最大元素</a></li>
</ol>
<div><pre><code><span>function</span> <span>findKthLargest</span><span>(</span><span>nums<span>,</span> k</span><span>)</span> <span>{</span>
  <span>// 维护容量为 k 的小顶堆</span>
  <span>const</span> heap <span>=</span> <span>new</span> <span>Heap</span><span>(</span><span>[</span><span>]</span><span>,</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> b <span>-</span> a<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>heap<span>.</span>size <span>&lt;</span> k<span>)</span> <span>{</span>
      heap<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>heap<span>.</span>top <span>&lt;</span> nums<span>[</span>i<span>]</span><span>)</span> <span>{</span>
      heap<span>.</span><span>pop</span><span>(</span><span>)</span>
      heap<span>.</span><span>push</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> heap<span>.</span>top
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="堆的进阶应用"> 堆的进阶应用</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener noreferrer">#355 设计推特</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-words/" target="_blank" rel="noopener noreferrer">#692 前K个高频单词</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/continuous-median-lcci/" target="_blank" rel="noopener noreferrer">#面试题 17.20. 连续中值</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener noreferrer">#295. 数据流的中位数</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/" target="_blank" rel="noopener noreferrer">#1801. 积压订单中的订单总数</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">数据结构与算法</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">链表</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/linked-list/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/linked-list/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链表访问"> 链表访问</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener noreferrer">#141 判断链表是否有环</a></li>
</ol>
<div><pre><code><span>var</span> <span>hasCycle</span> <span>=</span> <span>function</span><span>(</span><span>head</span><span>)</span> <span>{</span>
    <span>// 判断是否为空节点节点</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span>
    <span>let</span> slowNode <span>=</span> head
    <span>let</span> fastNode <span>=</span> head<span>.</span>next
    <span>// 快慢节点进行追击，重合的时候证明有环</span>
    <span>while</span><span>(</span>fastNode <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fastNode<span>.</span>next <span>!=</span> <span>null</span> <span>&amp;&amp;</span> slowNode <span>!==</span> fastNode<span>)</span> <span>{</span>
        slowNode <span>=</span> slowNode<span>.</span>next
        fastNode <span>=</span> fastNode<span>.</span>next<span>.</span>next
    <span>}</span>
    <span>return</span> slowNode <span>===</span> fastNode
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener noreferrer">#142 判断环状链表的环在何处</a></li>
</ol>
<div><pre><code><span>var</span> <span>detectCycle</span> <span>=</span> <span>function</span><span>(</span><span>head</span><span>)</span> <span>{</span>
    <span>// 空节点</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span>
    
    <span>let</span> slowNode <span>=</span> fastNode <span>=</span> head
    <span>while</span><span>(</span>fastNode <span>!=</span> <span>null</span> <span>&amp;&amp;</span> fastNode<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        slowNode <span>=</span> slowNode<span>.</span>next
        fastNode <span>=</span> fastNode<span>.</span>next<span>.</span>next
        <span>// 在此处相遇，跳出循环</span>
        <span>if</span> <span>(</span>fastNode <span>===</span> slowNode<span>)</span> <span>{</span>
            <span>break</span>
        <span>}</span>
    <span>}</span>
    <span>// 没有环</span>
    <span>if</span> <span>(</span>fastNode <span>==</span> <span>null</span> <span>||</span> fastNode<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span>

    slowNode <span>=</span> head
    <span>while</span><span>(</span>slowNode <span>!==</span> fastNode<span>)</span> <span>{</span>
        slowNode <span>=</span> slowNode<span>.</span>next
        fastNode <span>=</span> fastNode<span>.</span>next
    <span>}</span>
    <span>return</span> slowNode
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener noreferrer">#202 快乐树</a></li>
</ol>
<div><pre><code><span>// 使用判断链表是否有环的思维来判断是否为快乐树</span>
<span>var</span> <span>isHappy</span> <span>=</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>true</span>
    <span>let</span> slowNode <span>=</span> fastNode <span>=</span> n
    <span>while</span><span>(</span>fastNode <span>!==</span> <span>1</span> <span>&amp;&amp;</span> <span>getNext</span><span>(</span>fastNode<span>)</span> <span>!==</span> <span>1</span><span>)</span> <span>{</span>
        slowNode <span>=</span> <span>getNext</span><span>(</span>slowNode<span>)</span>
        fastNode <span>=</span> <span>getNext</span><span>(</span><span>getNext</span><span>(</span>fastNode<span>)</span><span>)</span>
        <span>if</span> <span>(</span>slowNode <span>===</span> fastNode<span>)</span> <span>break</span>
    <span>}</span>
    <span>// 如果 fastNode 到底或 getNext(fastNode) 到底，则说明这个链表没有环</span>
    <span>return</span> fastNode <span>===</span> <span>1</span> <span>||</span> <span>getNext</span><span>(</span>fastNode<span>)</span> <span>===</span> <span>1</span>
<span>}</span><span>;</span>

<span>function</span> <span>getNext</span><span>(</span><span>num</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>num <span>+</span> <span>''</span><span>)</span><span>.</span><span>split</span><span>(</span><span>''</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span> curr</span><span>)</span> <span>=></span> prev <span>+</span> curr <span>*</span> curr<span>,</span> <span>0</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="链表的反转"> 链表的反转</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">#206 反转链表</a></li>
</ol>
<div><pre><code><span>// 遍历解法</span>
<span>var</span> <span>reverseList</span> <span>=</span> <span>function</span><span>(</span><span>head</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> head
    <span>let</span> prev <span>=</span> <span>null</span>
    <span>let</span> curr <span>=</span> head
    <span>let</span> next <span>=</span> head<span>.</span>next

    <span>while</span> <span>(</span>curr <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        curr<span>.</span>next <span>=</span> prev
        prev <span>=</span> curr
        <span>;</span><span>(</span>curr <span>=</span> next<span>)</span> <span>&amp;&amp;</span> <span>(</span>next <span>=</span> next<span>.</span>next<span>)</span>
    <span>}</span>
    <span>return</span> prev
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>// 递归解法</span>
<span>// 这是一个递归回溯过程，所以考虑问题的时候要从最小单位来考虑，此处的最小单位为 最后一个节点指向null</span>
<span>var</span> <span>reverseList</span> <span>=</span> <span>function</span><span>(</span><span>head</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> head
    <span>const</span> tail <span>=</span> head<span>.</span>next
    <span>const</span> list <span>=</span> <span>reverseList</span><span>(</span>head<span>.</span>next<span>)</span>
    <span>// 本质上，head 从 tail 手上接过来的就是一个 null</span>
    <span>// head.next = tail.next</span>
    head<span>.</span>next <span>=</span> <span>null</span>
    tail<span>.</span>next <span>=</span> head
    <span>return</span> list
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener noreferrer">#92 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表</a></li>
</ol>
<div><pre><code><span>var</span> <span>reverseBetween</span> <span>=</span> <span>function</span><span>(</span><span>head<span>,</span> m<span>,</span> n</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>m <span>===</span> <span>1</span><span>)</span> <span>return</span> <span>reverseN</span><span>(</span>head<span>,</span> n<span>)</span>

    <span>// 相对于 head.next，翻转区间应该是 [m - 1, n - 1]</span>
    head<span>.</span>next <span>=</span> <span>reverseBetween</span><span>(</span>head<span>.</span>next<span>,</span> m <span>-</span> <span>1</span><span>,</span> n <span>-</span> <span>1</span><span>)</span>
    <span>return</span> head
<span>}</span><span>;</span>

<span>let</span> successor <span>=</span> <span>null</span>

<span>function</span> <span>reverseN</span><span>(</span><span>head<span>,</span> n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>1</span><span>)</span> <span>{</span>
    successor <span>=</span> head<span>.</span>next
    <span>return</span> head
  <span>}</span>
  <span>const</span> list <span>=</span> <span>reverseN</span><span>(</span>head<span>.</span>next<span>,</span> n <span>-</span> <span>1</span><span>)</span>
  head<span>.</span>next<span>.</span>next <span>=</span> head
  head<span>.</span>next <span>=</span> successor
  <span>return</span> list
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener noreferrer">#25 K个一组翻转链表</a></li>
</ol>
<div><pre><code><span>function</span> <span>reverseKGroup</span><span>(</span><span>head<span>,</span> k</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span>
  <span>let</span> a <span>=</span> b <span>=</span> head
  <span>// 循环有两个目的：1、判断个数是否大于 k;2、得到翻转的终止节点</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> k<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>// 个数不足，无需反转</span>
    <span>if</span> <span>(</span>b <span>==</span> <span>null</span><span>)</span> <span>return</span> head
    b <span>=</span> b<span>.</span>next
  <span>}</span>
  <span>const</span> newHead <span>=</span> <span>reverse</span><span>(</span>a<span>,</span> b<span>)</span>
  a<span>.</span>next <span>=</span> <span>reverseKGroup</span><span>(</span>b<span>,</span> k<span>)</span>
  <span>return</span> newHead
<span>}</span>

<span>// 左闭右开，两个节点</span>
<span>function</span> <span>reverse</span><span>(</span><span>head<span>,</span> end</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> head
  <span>let</span> prev <span>=</span> <span>null</span><span>,</span> curr <span>=</span> head<span>,</span> next <span>=</span> head<span>.</span>next
  <span>// 与反转整个链表唯一的不同点</span>
  <span>while</span> <span>(</span>curr <span>!=</span> end<span>)</span> <span>{</span>
    curr<span>.</span>next <span>=</span> prev
    prev <span>=</span> curr
    curr <span>=</span> next
    curr <span>&amp;&amp;</span> <span>(</span>next <span>=</span> curr<span>.</span>next<span>)</span>
  <span>}</span>
  <span>return</span> prev
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener noreferrer">#61 旋转链表</a></li>
</ol>
<div><pre><code><span>function</span> <span>rotateRight</span><span>(</span><span>head<span>,</span> k</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> head
  <span>// 将链表变成一个环</span>
  <span>let</span> curr <span>=</span> head<span>,</span> size <span>=</span> <span>1</span>
  <span>while</span> <span>(</span>curr<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    curr <span>=</span> curr<span>.</span>next
    size<span>++</span>
  <span>}</span>
  curr<span>.</span>next <span>=</span> head
  <span>let</span> newHead <span>=</span> head<span>,</span> newTail <span>=</span> curr
  <span>// 计算旋转的步数</span>
  <span>const</span> times <span>=</span> size <span>-</span> <span>(</span>k <span>%</span> size<span>)</span>
  <span>// 一步一步走</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> times<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    newHead <span>=</span> newHead<span>.</span>next
    newTail <span>=</span> newTail<span>.</span>next
  <span>}</span>
  <span>// 断开首尾的连接</span>
  newTail<span>.</span>next <span>=</span> <span>null</span>
  <span>return</span> newHead
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener noreferrer">#24 两两交换链表中的节点</a></li>
</ol>
<div><pre><code><span>function</span> <span>swapPairs</span><span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>// 递归终止条件</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> head
  <span>// 最终要返回的 head</span>
  <span>const</span> newHead <span>=</span> head<span>.</span>next
  <span>// 下一次递归要用到的 head</span>
  <span>const</span> nextHead <span>=</span> head<span>.</span>next<span>.</span>next
  <span>// 两两交换</span>
  newHead<span>.</span>next <span>=</span> head
  head<span>.</span>next <span>=</span> <span>swapPairs</span><span>(</span>nextHead<span>)</span>
  <span>return</span> newHead
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="链表节点的删除"> 链表节点的删除</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener noreferrer">#19 删除链表的倒数第 N 个结点</a></li>
</ol>
<div><pre><code><span>function</span> <span>removeNthFromEnd</span><span>(</span><span>head<span>,</span> n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span><span>)</span> <span>return</span> head
  <span>let</span> size <span>=</span> <span>1</span><span>,</span> curr <span>=</span> head
  <span>while</span> <span>(</span>curr<span>.</span>next <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    curr <span>=</span> curr<span>.</span>next
    size<span>++</span>
  <span>}</span>
  <span>// 数量不足</span>
  <span>if</span> <span>(</span>size <span>&lt;</span> n<span>)</span> <span>return</span> head
  <span>// 删除第一个（因为后面遍历是从 head 开始的）</span>
  <span>if</span> <span>(</span>size <span>===</span> n<span>)</span> <span>return</span> head<span>.</span>next
  <span>// 计算需要走多少步</span>
  <span>const</span> times <span>=</span> size <span>-</span> n
  curr <span>=</span> head
  <span>let</span> prev <span>=</span> <span>null</span><span>,</span> next <span>=</span> curr<span>.</span>next
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> times<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    prev <span>=</span> curr
    curr <span>=</span> next
    next <span>=</span> next<span>.</span>next
  <span>}</span>
  <span>// 只有唯一一个元素</span>
  <span>if</span> <span>(</span>prev <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span>
  prev<span>.</span>next <span>=</span> next
  <span>return</span> head
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="noopener noreferrer">#82 删除排序链表中的重复元素 II</a></li>
</ol>
<div><pre><code><span>function</span> <span>deleteDuplicates</span><span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span>next <span>==</span> <span>null</span><span>)</span> <span>return</span> head
  <span>let</span> prev <span>=</span> <span>{</span><span>}</span><span>,</span> curr <span>=</span> head<span>,</span> next <span>=</span> head<span>.</span>next
  <span>let</span> newHead <span>=</span> <span>null</span><span>,</span> newTail <span>=</span> <span>null</span>
  <span>while</span> <span>(</span>curr <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 某个元素跟它的前面和后面都不相同，那么这个元素有效</span>
    <span>if</span> <span>(</span>prev<span>.</span>val <span>!==</span> curr<span>.</span>val <span>&amp;&amp;</span> <span>(</span>next <span>||</span> <span>{</span><span>}</span><span>)</span><span>.</span>val <span>!==</span> curr<span>.</span>val<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>newHead <span>==</span> <span>null</span><span>)</span> <span>{</span>
        newHead <span>=</span> newTail <span>=</span> <span>new</span> <span>ListNode</span><span>(</span>curr<span>.</span>val<span>,</span> <span>null</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        newTail<span>.</span>next <span>=</span> <span>new</span> <span>ListNode</span><span>(</span>curr<span>.</span>val<span>,</span> <span>null</span><span>)</span>
        newTail <span>=</span> newTail<span>.</span>next
      <span>}</span>
    <span>}</span>
    <span>// 往后走</span>
    prev <span>=</span> curr
    curr <span>=</span> next
    curr <span>&amp;&amp;</span> <span>(</span>next <span>=</span> curr<span>.</span>next<span>)</span>
  <span>}</span>
  <span>return</span> newHead
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">队列</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/queue/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/queue/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><a href="https://leetcode-cn.com/problems/partition-list" target="_blank" rel="noopener noreferrer">#86 分隔链表</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer" target="_blank" rel="noopener noreferrer">#138 复制带随机指针的链表</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/design-circular-queue" target="_blank" rel="noopener noreferrer">#622 设计循环队列</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="4">
<li>
<p><a href="https://leetcode-cn.com/problems/design-circular-deque" target="_blank" rel="noopener noreferrer">#641 设计循环双端队列</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue" target="_blank" rel="noopener noreferrer">#1670 设计前中后队列 </a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/number-of-recent-calls" target="_blank" rel="noopener noreferrer">#933 最近的请求次数</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/buddy-strings" target="_blank" rel="noopener noreferrer">#859 亲密字符串</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/lemonade-change" target="_blank" rel="noopener noreferrer">#860 柠檬水找零</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/pancake-sorting" target="_blank" rel="noopener noreferrer">#969 煎饼排序</a></p>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/task-scheduler" target="_blank" rel="noopener noreferrer">#621 任务调度器</a></p>
</li>
</ol>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">快速排序</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/quick-sort/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/quick-sort/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基础应用"> 基础应用</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener noreferrer">#148. 排序链表</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener noreferrer">#912. 排序数组</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener noreferrer">#剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><h2 id="快排扩展"> 快排扩展</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener noreferrer">#面试题 17.14. 最小K个数</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener noreferrer">#75. 颜色分类</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><h2 id="智力发散"> 智力发散</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener noreferrer">#11. 盛最多水的容器</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener noreferrer">#470. 用 Rand7() 实现 Rand10()</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><h2 id="附加"> 附加</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">#239. 滑动窗口最大值</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">递归与栈</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/stack/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/stack/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener noreferrer">#946 验证栈序列</a></li>
</ol>
<div><pre><code><span>function</span> <span>validateStackSequences</span><span>(</span><span>pushed<span>,</span> popped</span><span>)</span> <span>{</span>
  <span>// 两个长度不同，直接判 false</span>
  <span>if</span> <span>(</span>pushed<span>.</span>length <span>!==</span> popped<span>.</span>length<span>)</span> <span>return</span> <span>false</span>
  <span>const</span> len <span>=</span> pushed<span>.</span>length
  <span>// 两个序列都是空</span>
  <span>if</span> <span>(</span>len <span>===</span> <span>0</span><span>)</span> <span>return</span> <span>true</span>
  <span>const</span> stack <span>=</span> <span>[</span><span>]</span>
  stack<span>.</span><span>push</span><span>(</span>pushed<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>2</span> <span>*</span> len <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>// 判断栈顶元素与第二个序列的第一个元素是否相等</span>
    <span>if</span> <span>(</span>stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>===</span> popped<span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>
      stack<span>.</span><span>pop</span><span>(</span><span>)</span>
      popped<span>.</span><span>shift</span><span>(</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      stack<span>.</span><span>push</span><span>(</span>pushed<span>.</span><span>shift</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> stack<span>.</span>length <span>===</span> <span>0</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener noreferrer">#20 有效的括号</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/" target="_blank" rel="noopener noreferrer">#1021 删除最外层的括号</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener noreferrer">#1249 移除无效的括号</a></li>
</ol>
<p>利用计数器对左括号进行计数，数字大于 0 时，右括号才是有效的</p>
<div><pre><code><span>function</span> <span>minRemoveToMakeValid</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>let</span> count <span>=</span> <span>0</span>
  <span>// 从左往右遍历，删除多余右括号</span>
  <span>let</span> res1 <span>=</span> <span>''</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>// 左括号入栈</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>'('</span><span>)</span> <span>{</span>
      count<span>++</span>
      res1 <span>+=</span> s<span>[</span>i<span>]</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span>s<span>[</span>i<span>]</span> <span>===</span> <span>')'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>count <span>></span> <span>0</span><span>)</span> <span>{</span>
        count<span>--</span>
        res1 <span>+=</span> s<span>[</span>i<span>]</span>
      <span>}</span>
      <span>continue</span>
    <span>}</span>
    res1 <span>+=</span> s<span>[</span>i<span>]</span>
  <span>}</span>
  count <span>=</span> <span>0</span>
  <span>// 从右往左遍历，删除多余左括号</span>
  <span>let</span> res2 <span>=</span> <span>''</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> res1<span>.</span>length <span>-</span> <span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
    <span>// 左括号入栈</span>
    <span>if</span> <span>(</span>res1<span>[</span>i<span>]</span> <span>===</span> <span>')'</span><span>)</span> <span>{</span>
      count<span>++</span>
      res2 <span>=</span> res1<span>[</span>i<span>]</span> <span>+</span> res2
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span>res1<span>[</span>i<span>]</span> <span>===</span> <span>'('</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>count <span>></span> <span>0</span><span>)</span> <span>{</span>
        res2 <span>=</span> res1<span>[</span>i<span>]</span> <span>+</span> res2
        count<span>--</span>
      <span>}</span>
      <span>continue</span>
    <span>}</span>
    res2 <span>=</span> res1<span>[</span>i<span>]</span> <span>+</span> res2
  <span>}</span>
  <span>return</span> res2
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener noreferrer">#145 二叉树的后序遍历</a></li>
</ol>
<div><pre><code><span>function</span> <span>postorderTraversal</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  <span>const</span> stack <span>=</span> <span>[</span>root<span>]</span>
  <span>while</span> <span>(</span>stack<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span>
    <span>if</span> <span>(</span><span>typeof</span> item <span>===</span> <span>"number"</span><span>)</span> <span>{</span>
      res<span>.</span><span>push</span><span>(</span>item<span>)</span>
      <span>continue</span>
    <span>}</span>
    <span>if</span> <span>(</span>item <span>==</span> <span>null</span><span>)</span> <span>continue</span>
    <span>if</span> <span>(</span>item<span>.</span>val<span>)</span> <span>{</span>
      stack<span>.</span><span>push</span><span>(</span>item<span>.</span>val<span>,</span> item<span>.</span>right<span>,</span> item<span>.</span>left<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ol start="6">
<li><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">#331 验证二叉树的前序序列化</a></li>
</ol>
<p>关键在于将 <code>3##</code> 这样的序列融合成 <code>#</code></p>
<div><pre><code><span>function</span> <span>isValidSerialization</span><span>(</span><span>preorder</span><span>)</span> <span>{</span>
  <span>// 一个数字后面跟两个 # 的可以合并为一个 #</span>
  <span>const</span> stack <span>=</span> <span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> preorder<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>preorder<span>[</span>i<span>]</span> <span>!==</span> <span>','</span><span>)</span> <span>{</span>
      <span>// 处理多位数字的情况，只将最后一位数字推入栈</span>
      <span>if</span><span>(</span>preorder<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>!==</span> <span>'#'</span> <span>&amp;&amp;</span> preorder<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>!==</span> <span>undefined</span> <span>&amp;&amp;</span> preorder<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>!==</span> <span>','</span><span>)</span> <span>{</span>
        <span>continue</span>
      <span>}</span>
      <span>// 入栈</span>
      stack<span>.</span><span>push</span><span>(</span>preorder<span>[</span>i<span>]</span><span>)</span>
      <span>// 判断栈顶三个元素是否符合 数字、#、#</span>
      <span>while</span> <span>(</span>stack<span>[</span>stack<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>===</span> <span>'#'</span> <span>&amp;&amp;</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>2</span><span>]</span> <span>===</span> <span>'#'</span> <span>&amp;&amp;</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>3</span><span>]</span> <span>!==</span> <span>'#'</span> <span>&amp;&amp;</span> stack<span>[</span>stack<span>.</span>length <span>-</span> <span>3</span><span>]</span> <span>!==</span> <span>undefined</span><span>)</span> <span>{</span>
        stack<span>.</span><span>pop</span><span>(</span><span>)</span>
        stack<span>.</span><span>pop</span><span>(</span><span>)</span>
        stack<span>.</span><span>pop</span><span>(</span><span>)</span>
        stack<span>.</span><span>push</span><span>(</span><span>'#'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> stack<span>.</span>length <span>===</span> <span>1</span> <span>&amp;&amp;</span> stack<span>[</span><span>0</span><span>]</span> <span>===</span> <span>'#'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ol start="7">
<li><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener noreferrer">#227 基本计算器 II</a></li>
</ol>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">二叉树</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/tree/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/tree/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本操作"> 基本操作</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">#144 二叉树的前序遍历</a></li>
</ol>
<div><pre><code><span>function</span> <span>preorderTraversal</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  res<span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
  <span>preorderTraversal</span><span>(</span>root<span>.</span>left<span>,</span> res<span>)</span>
  <span>preorderTraversal</span><span>(</span>root<span>.</span>right<span>,</span> res<span>)</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">#589 N 叉树的前序遍历</a></li>
</ol>
<div><pre><code><span>function</span> <span>preorder</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  res<span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> root<span>.</span>children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>preorder</span><span>(</span>root<span>.</span>children<span>[</span>i<span>]</span><span>,</span> res<span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener noreferrer">#226 翻转二叉树</a></li>
</ol>
<div><pre><code><span>function</span> <span>invertTree</span><span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> root
  <span>const</span> right <span>=</span> <span>invertTree</span><span>(</span>root<span>.</span>right<span>)</span>
  <span>const</span> left <span>=</span> <span>invertTree</span><span>(</span>root<span>.</span>left<span>)</span>
  root<span>.</span>left <span>=</span> right
  root<span>.</span>right <span>=</span> left
  <span>return</span> root
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener noreferrer">#剑指 Offer 32 - II 从上到下打印二叉树 II</a></li>
</ol>
<p>递归的时候，传入层级信息</p>
<div><pre><code><span>function</span> <span>levelOrder</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> level <span>=</span> <span>0</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  <span>if</span> <span>(</span><span>(</span>res<span>[</span>level<span>]</span> <span>||</span> <span>[</span><span>]</span><span>)</span><span>.</span>length<span>)</span> <span>{</span>
    res<span>[</span>level<span>]</span><span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    res<span>[</span>level<span>]</span> <span>=</span> <span>[</span>root<span>.</span>val<span>]</span>
  <span>}</span>
  <span>levelOrder</span><span>(</span>root<span>.</span>left<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>)</span>
  <span>levelOrder</span><span>(</span>root<span>.</span>right<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>)</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener noreferrer">#107 二叉树的层序遍历 II</a></li>
</ol>
<p>自底向上层序遍历，利用 <code>res.length - 1 - level</code></p>
<div><pre><code><span>function</span> <span>levelOrderBottom</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> level <span>=</span> <span>0</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  <span>// 已经存有这层的数据</span>
  <span>if</span> <span>(</span>res<span>.</span>length <span>></span> level<span>)</span> <span>{</span>
    res<span>[</span>res<span>.</span>length <span>-</span> <span>1</span> <span>-</span> level<span>]</span><span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    res<span>.</span><span>unshift</span><span>(</span><span>[</span>root<span>.</span>val<span>]</span><span>)</span>
  <span>}</span>
  <span>levelOrderBottom</span><span>(</span>root<span>.</span>left<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>)</span>
  <span>levelOrderBottom</span><span>(</span>root<span>.</span>right<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>)</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="6">
<li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener noreferrer">#103 二叉树的锯齿形层序遍历</a></li>
</ol>
<div><pre><code><span>function</span> <span>zigzagLevelOrder</span><span>(</span><span>root<span>,</span> res <span>=</span> <span>[</span><span>]</span><span>,</span> level <span>=</span> <span>0</span><span>,</span> order <span>=</span> <span>true</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>[</span><span>]</span>
  <span>// 已经存在该层元素</span>
  <span>if</span> <span>(</span><span>(</span>res<span>[</span>level<span>]</span> <span>||</span> <span>[</span><span>]</span><span>)</span><span>.</span>length<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>order<span>)</span> <span>{</span>
      res<span>[</span>level<span>]</span><span>.</span><span>push</span><span>(</span>root<span>.</span>val<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      res<span>[</span>level<span>]</span><span>.</span><span>unshift</span><span>(</span>root<span>.</span>val<span>)</span>
    <span>}</span>
  <span>}</span> <span>else</span> <span>{</span>
    res<span>[</span>level<span>]</span> <span>=</span> <span>[</span>root<span>.</span>val<span>]</span>
  <span>}</span>
  <span>zigzagLevelOrder</span><span>(</span>root<span>.</span>left<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>,</span> <span>!</span>order<span>)</span>
  <span>zigzagLevelOrder</span><span>(</span>root<span>.</span>right<span>,</span> res<span>,</span> level <span>+</span> <span>1</span><span>,</span> <span>!</span>order<span>)</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="进阶操作"> 进阶操作</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener noreferrer">#110 平衡二叉树</a></li>
</ol>
<div><pre><code><span>function</span> <span>isBalanced</span><span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>// 重新定义这个函数的功能，如果不平衡，则返回一个负的高度</span>
  <span>const</span> <span>getHeight</span> <span>=</span> <span>(</span><span>root</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span>
    <span>const</span> lHeight <span>=</span> <span>getHeight</span><span>(</span>root<span>.</span>left<span>)</span>
    <span>const</span> rHeight <span>=</span> <span>getHeight</span><span>(</span>root<span>.</span>right<span>)</span>
    <span>// 左右子树任意一颗已经不平衡了</span>
    <span>if</span> <span>(</span>lHeight <span>&lt;</span> <span>0</span> <span>||</span> rHeight <span>&lt;</span> <span>0</span><span>)</span> <span>return</span> <span>-</span><span>1</span>
    <span>// 以当前节点为根节点的二叉树已经不平衡了</span>
    <span>if</span> <span>(</span>Math<span>.</span><span>abs</span><span>(</span>lHeight <span>-</span> rHeight<span>)</span> <span>></span> <span>1</span><span>)</span> <span>return</span> <span>-</span><span>1</span>
    <span>return</span> Math<span>.</span><span>max</span><span>(</span>lHeight<span>,</span> rHeight<span>)</span> <span>+</span> <span>1</span>
  <span>}</span>

  <span>return</span> <span>getHeight</span><span>(</span>root<span>)</span> <span>>=</span> <span>0</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener noreferrer">#112 路径总和</a></li>
</ol>
<div><pre><code><span>function</span> <span>hasPathSum</span><span>(</span><span>root<span>,</span> targetSum<span>,</span> sum <span>=</span> <span>0</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span>
  <span>// 处理 [], 0 的案例</span>
  <span>if</span> <span>(</span>root<span>.</span>left <span>==</span> <span>null</span> <span>&amp;&amp;</span> root<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>targetSum <span>===</span> sum <span>+</span> root<span>.</span>val<span>)</span> <span>return</span> <span>true</span>
    <span>return</span> <span>false</span>
  <span>}</span>
  <span>return</span> <span>hasPathSum</span><span>(</span>root<span>.</span>left<span>,</span> targetSum<span>,</span> sum <span>+</span> root<span>.</span>val<span>)</span> <span>||</span> <span>hasPathSum</span><span>(</span>root<span>.</span>right<span>,</span> targetSum<span>,</span> sum <span>+</span> root<span>.</span>val<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">#105 从前序与中序遍历序列构造二叉树</a></li>
</ol>
<div><pre><code><span>function</span> <span>buildTree</span><span>(</span><span>preorder<span>,</span> inorder</span><span>)</span> <span>{</span>
  <span>return</span> <span>build</span><span>(</span>
    preorder<span>,</span> 
    <span>0</span><span>,</span>
    preorder<span>.</span>length <span>-</span> <span>1</span><span>,</span>
    inorder<span>,</span>
    <span>0</span><span>,</span>
    inorder<span>.</span>length <span>-</span> <span>1</span><span>,</span>
  <span>)</span>
<span>}</span>

<span>function</span> <span>build</span><span>(</span>
  <span>preorder<span>,</span> 
  preStart <span>=</span> <span>0</span><span>,</span>
  preEnd <span>=</span> preorder<span>.</span>length <span>-</span> <span>1</span><span>,</span>
  inorder<span>,</span>
  inStart <span>=</span> <span>0</span><span>,</span>
  inEnd <span>=</span> inorder<span>.</span>length <span>-</span> <span>1</span><span>,</span></span>
<span>)</span> <span>{</span>
  <span>// 递归终止条件</span>
  <span>if</span> <span>(</span>preStart <span>></span> preEnd<span>)</span> <span>return</span> <span>null</span>

  <span>// 获取根结点值</span>
  <span>const</span> rootVal <span>=</span> preorder<span>[</span>preStart<span>]</span>

  <span>// 遍历中序数组获取左子树的节点数</span>
  <span>let</span> index <span>=</span> <span>-</span><span>1</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> inStart<span>;</span> i <span>&lt;=</span> inEnd<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>inorder<span>[</span>i<span>]</span> <span>===</span> rootVal<span>)</span> <span>{</span>
      index <span>=</span> i
      <span>break</span>
    <span>}</span>
  <span>}</span>
  <span>const</span> leftSize <span>=</span> index <span>-</span> inStart

  <span>// 构造根结点，递归构造左右子树</span>
  <span>const</span> root <span>=</span> <span>new</span> <span>TreeNode</span><span>(</span>rootVal<span>)</span>
  root<span>.</span>left <span>=</span> <span>build</span><span>(</span>
    preorder<span>,</span> preStart <span>+</span> <span>1</span><span>,</span> preStart <span>+</span> leftSize<span>,</span>
    inorder<span>,</span> inStart<span>,</span> index <span>-</span> <span>1</span><span>,</span>
  <span>)</span>
  root<span>.</span>right <span>=</span> <span>build</span><span>(</span>
    preorder<span>,</span> preStart <span>+</span> leftSize <span>+</span> <span>1</span><span>,</span> preEnd<span>,</span>
    inorder<span>,</span> index <span>+</span> <span>1</span><span>,</span> inEnd<span>,</span>
  <span>)</span>

  <span>// 返回根结点</span>
  <span>return</span> root
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener noreferrer">#222 完全二叉树的节点个数</a></li>
</ol>
<div><pre><code><span>// 这种算法不太好，有更优解法</span>
<span>function</span> <span>countNodes</span><span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span>
  <span>return</span> <span>countNodes</span><span>(</span>root<span>.</span>left<span>)</span> <span>+</span> <span>countNodes</span><span>(</span>root<span>.</span>right<span>)</span> <span>+</span> <span>1</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener noreferrer">#剑指 Offer 54 二叉搜索树的第 k 大节点</a></li>
</ol>
<div><pre><code><span>function</span> <span>kthLargest</span><span>(</span><span>root<span>,</span> k</span><span>)</span> <span>{</span>
  <span>let</span> count <span>=</span> <span>0</span><span>,</span> res
  <span>// 从右子树开始遍历</span>
  <span>const</span> <span>inOrder</span> <span>=</span> <span>(</span><span>root</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>count <span>></span> k<span>)</span> <span>return</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span>
    <span>inOrder</span><span>(</span>root<span>.</span>right<span>)</span>
    count<span>++</span>
    <span>if</span> <span>(</span>count <span>===</span> k<span>)</span> <span>return</span> res <span>=</span> root<span>.</span>val
    <span>inOrder</span><span>(</span>root<span>.</span>left<span>)</span>
  <span>}</span>
  <span>inOrder</span><span>(</span>root<span>)</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol start="6">
<li><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener noreferrer">#剑指 Offer 26 树的子结构</a></li>
</ol>
<div><pre><code><span>function</span> <span>isSubStructure</span><span>(</span><span><span>A</span><span>,</span> <span>B</span></span><span>)</span> <span>{</span>
  <span>const</span> <span>isMatch</span> <span>=</span> <span>(</span><span><span>A</span><span>,</span> <span>B</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>B</span> <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>true</span>
    <span>if</span> <span>(</span><span>A</span> <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span>
    <span>if</span> <span>(</span><span>A</span><span>.</span>val <span>!==</span> <span>B</span><span>.</span>val<span>)</span> <span>return</span> <span>false</span>
    <span>return</span> <span>isMatch</span><span>(</span><span>A</span><span>.</span>left<span>,</span> <span>B</span><span>.</span>left<span>)</span> <span>&amp;&amp;</span> <span>isMatch</span><span>(</span><span>A</span><span>.</span>right<span>,</span> <span>B</span><span>.</span>right<span>)</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>A</span> <span>==</span> <span>null</span> <span>||</span> <span>B</span> <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span>
  <span>if</span> <span>(</span><span>isMatch</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>)</span><span>)</span> <span>return</span> <span>true</span>
  <span>return</span> <span>isSubStructure</span><span>(</span><span>A</span><span>.</span>left<span>,</span> <span>B</span><span>)</span> <span>||</span> <span>isSubStructure</span><span>(</span><span>A</span><span>.</span>right<span>,</span> <span>B</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="7">
<li><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener noreferrer">#968 监控二叉树</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="8">
<li><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener noreferrer">#662 二叉树最大宽度</a></li>
</ol>
<p>关键在于如何在层序遍历中统计每一层的信息，技巧是 <code>while</code> 遍历层，<code>for</code> 遍历层中的每一个元素</p>
<div><pre><code><span>function</span> <span>widthOfBinaryTree</span><span>(</span><span>root</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span>
  <span>let</span> maxWidth <span>=</span> <span>0</span>
  <span>// 使用队列对每一层的宽度进行统计</span>
  <span>const</span> queue <span>=</span> <span>[</span><span>{</span> node<span>:</span> root<span>,</span> i<span>:</span> <span>0</span> <span>}</span><span>]</span>
  <span>// 有多少层就 while 多少次（同一层里的元素交给内部的 for 循环处理了）</span>
  <span>while</span> <span>(</span>queue<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> len <span>=</span> queue<span>.</span>length
    <span>let</span> l <span>=</span> queue<span>[</span><span>0</span><span>]</span><span>.</span>i<span>,</span> r <span>=</span> queue<span>[</span>len <span>-</span> <span>1</span><span>]</span><span>.</span>i
    maxWidth <span>=</span> Math<span>.</span><span>max</span><span>(</span>maxWidth<span>,</span> r <span>-</span> l <span>+</span> <span>1</span><span>)</span>
    <span>// 记录该层最小编号</span>
    <span>const</span> lastMinIndex <span>=</span> queue<span>[</span><span>0</span><span>]</span><span>.</span>i
    <span>// 代码至此，队列里面的所有元素都是同一层的</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> len<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>const</span> <span>{</span> node<span>,</span> i <span>}</span> <span>=</span> queue<span>.</span><span>shift</span><span>(</span><span>)</span>
      <span>if</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>// i 的取值正常来说是取父节点编号 * 2，但是直接这样写的话，编号增量太大，导致后面有用例跑不过去</span>
        <span>// 解决方案是用 (父节点最大编号 - 与父节点同层的最小编号) * 2</span>
        queue<span>.</span><span>push</span><span>(</span><span>{</span> node<span>:</span> node<span>.</span>left<span>,</span> i<span>:</span> <span>2</span> <span>*</span> <span>(</span>i <span>-</span> lastMinIndex<span>)</span> <span>}</span><span>)</span>
      <span>}</span>
      <span>if</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        queue<span>.</span><span>push</span><span>(</span><span>{</span> node<span>:</span> node<span>.</span>right<span>,</span> i<span>:</span> <span>2</span> <span>*</span> <span>(</span>i <span>-</span> lastMinIndex<span>)</span> <span>+</span> <span>1</span> <span>}</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> maxWidth
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">并查集</title>
    <id>https://x-vic.gitee.io/code/code/views/algorithm/union-find/</id>
    <link href="https://x-vic.gitee.io/code/code/views/algorithm/union-find/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="并查集的实现"> 并查集的实现</h2>
<div><pre><code><span>class</span> <span>UnineFind</span> <span>{</span>
  <span>constructor</span><span>(</span><span>size</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>set <span>=</span> <span>Array</span><span>(</span>size<span>)</span><span>.</span><span>fill</span><span>(</span><span>null</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=></span> i<span>)</span>
  <span>}</span>

  <span>// 返回根节点的编号（启用根结点压缩）</span>
  <span>get</span><span>(</span>x<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>set<span>[</span>x<span>]</span> <span>=</span> <span>(</span><span>this</span><span>.</span>set<span>[</span>x<span>]</span> <span>===</span> x <span>?</span> x <span>:</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>this</span><span>.</span>set<span>[</span>x<span>]</span><span>)</span><span>)</span>
  <span>}</span>

  <span>// a 的根节点的的值 = b 的根节点的编号</span>
  <span>merge</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>set<span>[</span><span>this</span><span>.</span><span>get</span><span>(</span>a<span>)</span><span>]</span> <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>b<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="基础应用"> 基础应用</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener noreferrer">#547. 省份数量</a></li>
</ol>
<div><pre><code><span>function</span> <span>findCircleNum</span><span>(</span><span>isConnected</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> isConnected<span>.</span>length
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span>len<span>)</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>isConnected<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> u<span>.</span><span>merge</span><span>(</span>i<span>,</span> j<span>)</span>
    <span>}</span>
  <span>}</span>
  <span>let</span> ans <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>u<span>.</span><span>get</span><span>(</span>i<span>)</span> <span>===</span> i<span>)</span> ans <span>+=</span> <span>1</span>
  <span>}</span>
  <span>return</span> ans
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener noreferrer">#200. 岛屿数量</a></li>
</ol>
<p>递归回溯解法</p>
<div><pre><code><span>function</span> <span>numIslands</span><span>(</span><span>grid</span><span>)</span> <span>{</span>
  <span>const</span> c <span>=</span> grid<span>.</span>length<span>,</span> r <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length
  <span>// 记录是否已经被访问</span>
  <span>const</span> visited <span>=</span> <span>Array</span><span>(</span>c<span>)</span><span>.</span><span>fill</span><span>(</span><span>null</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>Array</span><span>(</span>r<span>)</span><span>.</span><span>fill</span><span>(</span><span>false</span><span>)</span><span>)</span>
  <span>let</span> ans <span>=</span> <span>0</span>
  <span>const</span> directions <span>=</span> <span>[</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>0</span><span>]</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>]</span><span>,</span> <span>[</span><span>-</span><span>1</span><span>,</span> <span>0</span><span>]</span><span>]</span>

  <span>const</span> <span>subFunc</span> <span>=</span> <span>(</span><span>i<span>,</span> j</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 越界、已经被访问、不属于它的领域</span>
    <span>if</span> <span>(</span>i <span>&lt;</span> <span>0</span> <span>||</span> i <span>>=</span> c <span>||</span> j <span>&lt;</span> <span>0</span> <span>||</span> j <span>>=</span> r<span>)</span> <span>return</span> <span>false</span>
    <span>if</span> <span>(</span>visited<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span> <span>return</span> <span>false</span>
    <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>'0'</span><span>)</span> <span>return</span> <span>false</span>

    <span>// 能够走到这一步就说明发现新的岛屿了，接下来就是把边上的岛屿染上颜色</span>
    visited<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> <span>true</span>
    <span>for</span> <span>(</span><span>let</span> m <span>=</span> <span>0</span><span>;</span> m <span>&lt;</span> directions<span>.</span>length<span>;</span> m<span>++</span><span>)</span> <span>{</span>
      <span>subFunc</span><span>(</span>i <span>+</span> directions<span>[</span>m<span>]</span><span>[</span><span>0</span><span>]</span><span>,</span> j <span>+</span> directions<span>[</span>m<span>]</span><span>[</span><span>1</span><span>]</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>true</span>
  <span>}</span>

  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> c<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> r<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>subFunc</span><span>(</span>i<span>,</span> j<span>)</span><span>)</span> ans<span>++</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> ans
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>并查集解法</p>
<div><pre><code><span>function</span> <span>numIslands</span><span>(</span><span>grid</span><span>)</span> <span>{</span>
  <span>const</span> col <span>=</span> grid<span>.</span>length<span>,</span> row <span>=</span> grid<span>[</span><span>0</span><span>]</span><span>.</span>length

  <span>// 将二维网格进行编号，从 1 开始，拉成一维的</span>
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span>col <span>*</span> row<span>)</span>

  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> col<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> row<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>'0'</span><span>)</span> <span>continue</span>
      <span>// 判断 上、左 方向是否为 1</span>
      <span>if</span> <span>(</span>i <span>></span> <span>0</span> <span>&amp;&amp;</span> grid<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>'1'</span><span>)</span> u<span>.</span><span>merge</span><span>(</span><span>getIndex</span><span>(</span>i<span>,</span> j<span>,</span> row<span>)</span><span>,</span> <span>getIndex</span><span>(</span>i <span>-</span> <span>1</span><span>,</span> j<span>,</span> row<span>)</span><span>)</span>
      <span>if</span> <span>(</span>j <span>></span> <span>0</span> <span>&amp;&amp;</span> grid<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>===</span> <span>'1'</span><span>)</span> u<span>.</span><span>merge</span><span>(</span><span>getIndex</span><span>(</span>i<span>,</span> j<span>,</span> row<span>)</span><span>,</span> <span>getIndex</span><span>(</span>i<span>,</span> j <span>-</span> <span>1</span><span>,</span> row<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>let</span> ans <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> col<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> row<span>;</span> j<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>grid<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>===</span> <span>'1'</span> <span>&amp;&amp;</span> u<span>.</span><span>get</span><span>(</span><span>getIndex</span><span>(</span>i<span>,</span> j<span>,</span> row<span>)</span><span>)</span> <span>===</span> <span>getIndex</span><span>(</span>i<span>,</span> j<span>,</span> row<span>)</span><span>)</span> ans<span>++</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> ans
<span>}</span>

<span>function</span> <span>getIndex</span><span>(</span><span>i<span>,</span> j<span>,</span> row</span><span>)</span> <span>{</span>
  <span>return</span> i <span>*</span> row <span>+</span> j
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener noreferrer">#990. 等式方程的可满足性</a></li>
</ol>
<div><pre><code><span>// 相等关系本身可以理解为一种连通关系</span>
<span>function</span> <span>equationsPossible</span><span>(</span><span>equations</span><span>)</span> <span>{</span>
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span><span>26</span><span>)</span>
  <span>// 遍历这些等式，找到相等关系，并将之连通</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> equations<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> equations<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> <span>'='</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>item<span>[</span><span>0</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>,</span> item<span>[</span><span>3</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// 找到不等关系，如果两者已经连通，那么返回 false</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> equations<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> equations<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>item<span>[</span><span>1</span><span>]</span> <span>===</span> <span>'!'</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>u<span>.</span><span>get</span><span>(</span>item<span>[</span><span>0</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>)</span> <span>===</span> u<span>.</span><span>get</span><span>(</span>item<span>[</span><span>3</span><span>]</span><span>.</span><span>charCodeAt</span><span>(</span><span>)</span> <span>-</span> <span>97</span><span>)</span><span>)</span> <span>return</span> <span>false</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="进阶"> 进阶</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener noreferrer">#684. 冗余连接</a></li>
</ol>
<div><pre><code><span>function</span> <span>findRedundantConnection</span><span>(</span><span>edges</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> edges<span>.</span>length
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span>len <span>+</span> <span>1</span><span>)</span>

  <span>// 遍历数组</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> edges<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span>a<span>,</span> b<span>]</span> <span>=</span> edges<span>[</span>i<span>]</span>
    <span>// 之前没有连接</span>
    <span>if</span> <span>(</span>u<span>.</span><span>get</span><span>(</span>a<span>)</span> <span>!==</span> u<span>.</span><span>get</span><span>(</span>b<span>)</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>a<span>,</span> b<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span> <span>[</span>a<span>,</span> b<span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener noreferrer">#1319. 连通网络的操作次数</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="3">
<li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener noreferrer">#128. 最长连续序列</a></li>
</ol>
<p>应题目要求，需要统计每个集合的元素数量，所以需要对我们实现的并查集进行功能增强</p>
<div><div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>// 带统计元素个数的并查集实现</span>
<span>class</span> <span>UnineFind</span> <span>{</span>
  <span>constructor</span><span>(</span><span>size</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>boss <span>=</span> <span>Array</span><span>(</span>size<span>)</span><span>.</span><span>fill</span><span>(</span><span>null</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=></span> i<span>)</span>
    <span>// 开始每个集合中都只有它自己</span>
    <span>this</span><span>.</span>count <span>=</span> <span>Array</span><span>(</span>size<span>)</span><span>.</span><span>fill</span><span>(</span><span>null</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>_<span>,</span> i</span><span>)</span> <span>=></span> <span>1</span><span>)</span>
  <span>}</span>

  <span>// 返回根节点的编号</span>
  <span>get</span><span>(</span>x<span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>boss<span>[</span>x<span>]</span> <span>=</span> <span>(</span><span>this</span><span>.</span>boss<span>[</span>x<span>]</span> <span>===</span> x <span>?</span> x <span>:</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>this</span><span>.</span>boss<span>[</span>x<span>]</span><span>)</span><span>)</span>
  <span>}</span>

  <span>// a 的根节点的的值 = b 的根节点的编号</span>
  <span>merge</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span><span>get</span><span>(</span>a<span>)</span> <span>===</span> <span>this</span><span>.</span><span>get</span><span>(</span>b<span>)</span><span>)</span> <span>return</span>
    <span>this</span><span>.</span>count<span>[</span><span>this</span><span>.</span><span>get</span><span>(</span>b<span>)</span><span>]</span> <span>+=</span> <span>this</span><span>.</span>count<span>[</span><span>this</span><span>.</span><span>get</span><span>(</span>a<span>)</span><span>]</span>
    <span>this</span><span>.</span>boss<span>[</span><span>this</span><span>.</span><span>get</span><span>(</span>a<span>)</span><span>]</span> <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span>b<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>题解</p>
<div><pre><code><span>function</span> <span>longestConsecutive</span><span>(</span><span>nums</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> nums<span>.</span>length
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span>len<span>)</span>
  <span>// 存储已经访问过的元素，以及其下标</span>
  <span>const</span> visited <span>=</span> <span>{</span><span>}</span>

  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> item <span>=</span> nums<span>[</span>i<span>]</span>
    <span>if</span> <span>(</span>visited<span>[</span>item<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>continue</span>
    <span>// 连接前一个</span>
    <span>if</span> <span>(</span>visited<span>[</span>item <span>-</span> <span>1</span><span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>i<span>,</span> visited<span>[</span>item <span>-</span> <span>1</span><span>]</span><span>)</span>
    <span>}</span>
    <span>// 连接后一个</span>
    <span>if</span> <span>(</span>visited<span>[</span>item <span>+</span> <span>1</span><span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>i<span>,</span> visited<span>[</span>item <span>+</span> <span>1</span><span>]</span><span>)</span>
    <span>}</span>
    visited<span>[</span>item<span>]</span> <span>=</span> i
  <span>}</span>

  <span>let</span> ans <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    ans <span>=</span> Math<span>.</span><span>max</span><span>(</span>ans<span>,</span> u<span>.</span>count<span>[</span>i<span>]</span><span>)</span>
  <span>}</span>
  
  <span>return</span> ans
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><ol start="4">
<li><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener noreferrer">#947. 移除最多的同行或同列石头</a></li>
</ol>
<div><pre><code><span>function</span> <span>removeStones</span><span>(</span><span>stones</span><span>)</span> <span>{</span>
  <span>const</span> len <span>=</span> stones<span>.</span>length
  <span>const</span> u <span>=</span> <span>new</span> <span>UnineFind</span><span>(</span>len<span>)</span>
  <span>// x、y 方向缓存数据</span>
  <span>const</span> visitedX <span>=</span> <span>{</span><span>}</span><span>,</span> visitedY <span>=</span> <span>{</span><span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>[</span>x<span>,</span> y<span>]</span> <span>=</span> stones<span>[</span>i<span>]</span>
    <span>// 连接 x 方向</span>
    <span>if</span> <span>(</span>visitedX<span>[</span>x<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>i<span>,</span> visitedX<span>[</span>x<span>]</span><span>)</span>
    <span>}</span>
    <span>// 连接 y 方向</span>
    <span>if</span> <span>(</span>visitedY<span>[</span>y<span>]</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
      u<span>.</span><span>merge</span><span>(</span>i<span>,</span> visitedY<span>[</span>y<span>]</span><span>)</span>
    <span>}</span>
    visitedX<span>[</span>x<span>]</span> <span>=</span> i
    visitedY<span>[</span>y<span>]</span> <span>=</span> i
  <span>}</span>

  <span>let</span> ans <span>=</span> <span>0</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>u<span>.</span><span>get</span><span>(</span>i<span>)</span> <span>===</span> i<span>)</span> ans <span>+=</span> <span>1</span>
  <span>}</span>
  <span>// 元素数量 - 集合数量</span>
  <span>return</span> len <span>-</span> ans
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><ol start="5">
<li><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener noreferrer">#1202. 交换字符串中的元素</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="6">
<li><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener noreferrer">#721. 账户合并</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><h2 id="附加"> 附加</h2>
<ol>
<li><a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener noreferrer">#765. 情侣牵手</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div><ol start="2">
<li><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener noreferrer">#685. 冗余连接 II</a></li>
</ol>
<div><pre><code></code></pre>
<div></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">applicative</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/applicative/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/applicative/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>applicative functor 是实现了 ap 方法的 pointed functor</p>
</blockquote>
<blockquote>
<p>ap 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上</p>
</blockquote>
<h2 id="瓶中之船"> 瓶中之船</h2>
<p>先看下面这个简单的加法运算</p>
<div><pre><code><span>// 这样是行不通的，因为 2 和 3 都藏在瓶子里。</span>
<span>add</span><span>(</span>Container<span>.</span><span>of</span><span>(</span><span>2</span><span>)</span><span>,</span> Container<span>.</span><span>of</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>
<span>//NaN</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>我们想要对瓶中之船进行直接的操作，巧的是，我们已经有这样的工具存在了。那就是 <code>chain</code> 函数</p>
<div><pre><code><span>// add 是接收两个参数的柯里化函数</span>
Container<span>.</span><span>of</span><span>(</span><span>2</span><span>)</span>
  <span>.</span><span>chain</span><span>(</span>
    <span>two</span> <span>=></span> Container<span>.</span><span>of</span><span>(</span><span>3</span><span>)</span><span>.</span><span>map</span><span>(</span><span>add</span><span>(</span>two<span>)</span><span>)</span>
  <span>)</span>
<span>// Container(5)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>只不过，这种方式有一个问题，那就是 <code>monad</code> 的顺序执行问题：所有的代码都只会在前一个 <code>monad</code> 执行完毕之后才执行。想想看，我们的这两个值足够强健且相互独立，如果仅仅为了满足 <code>monad</code> 的顺序要求而延迟 <code>Container(3)</code> 的创建，我觉得是非常没有必要的。</p>
<p>事实上，当遇到这种问题的时候，要是能够无需借助这些不必要的函数和变量，以一种简明扼要的方式把一个 <code>functor</code> 的值应用到另一个上去就好了。</p>
<h2 id="ap"> ap</h2>
<p>ap 是这样一种函数，能够把一个 functor（作为入参） 的<strong>函数值</strong>应用到另一个 functor（作为 this） 的值上。</p>
<div><pre><code><span>class</span> <span>Container</span> <span>{</span>
  <span>// 与 chain 相反，chain 自己提供转换函数，外部提供值；ap 外部提供转换函数，内部提供值；</span>
  <span>// 与 chain 相同的是，它们都是使用外部的壳</span>
  <span>ap</span><span>(</span><span>functor</span><span>)</span> <span>{</span>
    <span>return</span> functor<span>.</span><span>map</span><span>(</span><span>this</span><span>.</span>__value<span>)</span>
  <span>}</span>
<span>}</span>

<span>// 下面使用 ap</span>
Container<span>.</span><span>of</span><span>(</span><span>add</span><span>(</span><span>2</span><span>)</span><span>)</span><span>.</span><span>ap</span><span>(</span>Container<span>.</span><span>of</span><span>(</span><span>3</span><span>)</span><span>)</span>
<span>// 等价于</span>
Container<span>.</span><span>of</span><span>(</span><span>2</span><span>)</span><span>.</span><span>map</span><span>(</span>add<span>)</span><span>.</span><span>ap</span><span>(</span>Container<span>.</span><span>of</span><span>(</span><span>3</span><span>)</span><span>)</span>

<span>// 等待两个并行的异步任务</span>
Task<span>.</span><span>of</span><span>(</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>=></span> <span><span>`</span><span>name:</span><span><span>${</span>name<span>}</span></span><span>  age:</span><span><span>${</span>age<span>}</span></span><span>`</span></span><span>)</span><span>.</span><span>ap</span><span>(</span>Task<span>.</span><span>of</span><span>(</span>Http<span>.</span><span>get</span><span>(</span><span>'/name'</span><span>)</span><span>)</span><span>)</span><span>.</span><span>ap</span><span>(</span>Task<span>.</span><span>of</span><span>(</span>Http<span>.</span><span>get</span><span>(</span><span>'/age'</span><span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="lift"> lift</h2>
<p>一个函数在调用的时候，如果被 <code>map</code> 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。我们把这个过程叫做 <code>lift</code>。</p>
<p>一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 <code>lift</code> 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。</p>
<p>我们来试试以一种 pointfree 的方式调用 applicative functor。因为 map 等价于 <code>of/ap</code>，那么我们就可以定义无数个 <code>ap</code> 通用函数。</p>
<div><pre><code><span>const</span> liftA2 <span>=</span> <span>curry</span><span>(</span><span>(</span><span>fn<span>,</span> functor1<span>,</span> functor2</span><span>)</span> <span>=></span> functor1<span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>ap</span><span>(</span>functor2<span>)</span><span>)</span>

<span>const</span> liftA3 <span>=</span> <span>curry</span><span>(</span><span>(</span><span>fn<span>,</span> functor1<span>,</span> functor2<span>,</span> functor3</span><span>)</span> <span>=></span> functor1<span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>ap</span><span>(</span>functor2<span>)</span><span>.</span><span>ap</span><span>(</span>functor3<span>)</span><span>)</span>

<span>// liftA4, etc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>接下来看看实际用例：</p>
<div><pre><code><span>// checkEmail :: User -> Either String Email</span>
<span>// checkName :: User -> Either String String</span>

<span>//  createUser :: Email -> String -> IO User</span>
<span>var</span> createUser <span>=</span> <span>curry</span><span>(</span><span>function</span><span>(</span><span>email<span>,</span> name</span><span>)</span> <span>{</span> <span>/* creating... */</span> <span>}</span><span>)</span><span>;</span>

Either<span>.</span><span>of</span><span>(</span>createUser<span>)</span><span>.</span><span>ap</span><span>(</span><span>checkEmail</span><span>(</span>user<span>)</span><span>)</span><span>.</span><span>ap</span><span>(</span><span>checkName</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
<span>// Left("invalid email")</span>

<span>liftA2</span><span>(</span>createUser<span>,</span> <span>checkEmail</span><span>(</span>user<span>)</span><span>,</span> <span>checkName</span><span>(</span>user<span>)</span><span>)</span><span>;</span>
<span>// Left("invalid email")</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>上述两个执行语句是等价的，但是使用了 <code>liftA2</code> 的版本没有提到 <code>Either</code>，这就使得它更加通用灵活，因为不必与特定的数据类型耦合在一起。</p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函数的组合</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/compose/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/compose/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>实际生产中，我们经常需要对数据进行分阶段加工。在这个过程中，不可避免就会出现<code>a(b(c()))</code>的写法，这种写法不利于阅读以及修改，下面祭出函数组合的神器“compose”</p>
</blockquote>
<h2 id="compose"> compose</h2>
<p>compose 接收一系列的函数，返回一个新的函数。调用这个返回的函数时，会将右侧函数的返回值作为其左侧函数的参数传入，以此类推，直到执行完所有函数。</p>
<div><pre><code><span>// 简单实现，不建议在生产环境中使用</span>
<span>const</span> <span>compose</span> <span>=</span> <span>(</span><span><span>...</span>fns</span><span>)</span> <span>=></span> 
  fns<span>.</span>length <span>&lt;=</span> <span>1</span>
    <span>?</span> fns<span>[</span><span>0</span><span>]</span>
    ：fns<span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span> curr</span><span>)</span> <span>=></span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>prev</span><span>(</span><span>curr</span><span>(</span><span>...</span>args<span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函子</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/functor/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/functor/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？本章将对上述这些抽象概念赖以建立的基础作一番探究。</p>
</blockquote>
<h2 id="一个最简单的函子"> 一个最简单的函子</h2>
<div><pre><code><span>class</span> <span>Container</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Container</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>// 不同函子的 map 实现不一样，但它们的功能都是提供一个操作内部值(__value)的接口</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>fn</span><span>(</span><span>this</span><span>.</span>__value<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>Tips</p>
<p>functor 是实现了 map 函数并遵守一些特定规则的容器类型。</p>
</div>
<h2 id="maybe"> Maybe</h2>
<p>最大名鼎鼎的 Maybe 大概是薛定谔的猫了。它代表一种不确定的状态（在我们打开容器之前）。</p>
<div><pre><code><span>class</span> <span>Maybe</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Maybe</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>isNothing</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>__value <span>===</span> <span>null</span> <span>||</span> <span>this</span><span>.</span>__value <span>===</span> <span>undefined</span>
  <span>}</span>
  <span>// Maybe 的 map 会检测内部的值是否有效</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>isNothing</span><span>(</span><span>)</span> <span>?</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>null</span><span>)</span> <span>:</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>fn</span><span>(</span><span>this</span><span>.</span>__value<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="一个安全取值的例子"> 一个安全取值的例子</h3>
<div><pre><code><span>const</span> <span>map</span> <span>=</span> <span>(</span><span>fn<span>,</span> functor</span><span>)</span> <span>=></span> functor<span>.</span><span>map</span><span>(</span>fn<span>)</span>

<span>const</span> prop <span>=</span> <span>curry</span><span>(</span><span>(</span><span>prop<span>,</span> obj</span><span>)</span> <span>=></span> obj<span>[</span>prop<span>]</span><span>)</span>
<span>const</span> safeprop <span>=</span> <span>curry</span><span>(</span><span>(</span><span>prop<span>,</span> obj</span><span>)</span> <span>=></span> Maybe<span>.</span><span>of</span><span>(</span>obj<span>[</span>prop<span>]</span><span>)</span><span>)</span>

<span>const</span> getC <span>=</span> <span>compose</span><span>(</span><span>map</span><span>(</span><span>prop</span><span>(</span><span>'c'</span><span>)</span><span>)</span><span>,</span> <span>safeprop</span><span>(</span><span>'b'</span><span>)</span><span>,</span> <span>prop</span><span>(</span><span>'a'</span><span>)</span><span>)</span>

<span>getC</span><span>(</span><span>{</span>
  a<span>:</span> <span>{</span>
    b<span>:</span> <span>{</span>
      c<span>:</span> <span>2</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
<span>// Maybe { __value: 2 }</span>

<span>getC</span><span>(</span><span>{</span>
  a<span>:</span> <span>{</span><span>}</span>
<span>}</span><span>)</span>
<span>// Maybe { __value: null }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>Tips</p>
<p>实际当中，Maybe 最常用在那些可能会无法成功返回结果的函数中。<br>
这个例子依然存在很严重的问题：如果每一个属性都要试探性地取值，那我们最终会得到一个嵌套多层地 Maybe。后面我们会来解决这个问题。</p>
</div>
<h3 id="maybe-2"> maybe</h3>
<p>我们最终是要拿到 Maybe 里面的值进行操作的，下面我们来定义一个 maybe 函数来处理最终结果</p>
<div><pre><code><span>const</span> maybe <span>=</span> <span>curry</span><span>(</span><span>(</span><span>errMsg<span>,</span> fn<span>,</span> functor</span><span>)</span> <span>=></span> functor<span>.</span><span>isNothing</span><span>(</span><span>)</span> <span>?</span> errMsg <span>:</span> <span>fn</span><span>(</span>functor<span>.</span>__value<span>)</span><span>)</span>

<span>// 延续上面安全取值的例子</span>
<span>const</span> handleC <span>=</span> <span>compose</span><span>(</span><span>maybe</span><span>(</span><span>'失败了！'</span><span>,</span> <span>val</span> <span>=></span> val<span>)</span><span>,</span> getC<span>)</span>

<span>handleC</span><span>(</span><span>{</span>
  a<span>:</span> <span>{</span>
    b<span>:</span> <span>{</span>
      c<span>:</span> <span>2</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
<span>// 2</span>
<span>handleC</span><span>(</span><span>{</span>
  a<span>:</span> <span>{</span><span>}</span>
<span>}</span><span>)</span>
<span>// 失败了！</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="either"> Either</h2>
<p>Either 函子是一个抽象类，用来进行错误处理，那就是返回一条有礼貌的的错误消息作为回应。<br>
Either 本身不能使用，真正起作用的是它的两个子类：Left 和 Right。<br>
下面看看它们的实现：</p>
<div><pre><code><span>class</span> <span>Left</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Left</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>// Left 会忽略 fn</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Right</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Right</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> Right<span>.</span><span>of</span><span>(</span><span>fn</span><span>(</span><span>this</span><span>.</span>__value<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="either-的实例"> Either 的实例</h3>
<div><pre><code><span>// 退 10 钱，看看余额够不够</span>
<span>const</span> <span>withdrow</span> <span>=</span> <span>total</span> <span>=></span> total <span>-</span> <span>10</span> <span>>=</span> <span>0</span> <span>?</span> Right<span>.</span><span>of</span><span>(</span>total <span>-</span> <span>10</span><span>)</span> <span>:</span> Left<span>.</span><span>of</span><span>(</span><span>'没得退了！'</span><span>)</span>


<span>withdrow</span><span>(</span><span>20</span><span>)</span>
<span>// Right { __value: 10 }</span>
<span>withdrow</span><span>(</span><span>5</span><span>)</span>
<span>// Left { __value: '没得退了！' }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="either-取出值"> either 取出值</h3>
<p>使用 Either 进行错误处理之后会有两种结果的函子出现，在不能确定函子类型的情况下，我们很难确定下一个函数怎么来处理上一个函数返回的值。<br>
此时就可以祭出 either 辅助函数将 Either 中的值取出来，交给下一个函数处理。</p>
<div><pre><code><span>const</span> either <span>=</span> <span>curry</span><span>(</span><span>(</span><span>leftFn<span>,</span> rightFn<span>,</span> functor</span><span>)</span> <span>=></span> <span>{</span>
  <span>switch</span><span>(</span>functor<span>.</span>constructor<span>)</span> <span>{</span>
    <span>case</span> Left<span>:</span> <span>return</span> <span>leftFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
    <span>case</span> Right<span>:</span> <span>return</span> <span>rightFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>继续上一个例子：</p>
<div><pre><code><span>const</span> withdrow2 <span>=</span> <span>compose</span><span>(</span>console<span>.</span>log<span>,</span> <span>either</span><span>(</span><span>val</span> <span>=></span> <span>'失败！！'</span> <span>+</span> val<span>,</span> <span>val</span> <span>=></span> <span>'成功！'</span> <span>+</span> val<span>)</span><span>,</span> withdrow<span>)</span>

<span>withdrow2</span><span>(</span><span>20</span><span>)</span>
<span>// 成功！10</span>
<span>withdrow2</span><span>(</span><span>5</span><span>)</span>
<span>// 失败！！没得退了！</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="io"> IO</h2>
<blockquote>
<p>现在我们用我们的纯函数去接触真是环境中的脏东西了。这个脏东西就是“副作用”。</p>
</blockquote>
<h3 id="处理副作用的办法"> 处理副作用的办法</h3>
<p>副作用会让函数的输出变得不可靠，而我们的编程希望使用纯函数来让代码变得透明可靠。采取的方式就是“<strong>延迟</strong>”，实际上的做法就是将副作用封印到一个函数中，在我们纯函数链条中不去使用它，而是将副作用使用交到调用者的手上。而我们的输入与输出都是纯的函数。</p>
<h3 id="io-函子的实现"> IO 函子的实现</h3>
<div><pre><code><span>// IO 函子实际上是将副作用包裹在一个函数中延迟执行，这样一来，它还是一个纯函数</span>
<span>class</span> <span>IO</span> <span>{</span>
  <span>constructor</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>unsafePerformIO <span>=</span> fn
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>fn<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>IO</span><span>(</span>fn<span>)</span>
  <span>}</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>// 与普通函子不同的是：普通函数调用 fn，而 IO 函子组合 fn</span>
    <span>return</span> <span>IO</span><span>.</span><span>of</span><span>(</span><span>compose</span><span>(</span>fn<span>,</span> <span>this</span><span>.</span>unsafePerformIO<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="io-的应用实例"> IO 的应用实例</h3>
<div><pre><code><span>const</span> <span>$</span> <span>=</span> <span>selector</span> <span>=></span> <span>IO</span><span>.</span><span>of</span><span>(</span><span>(</span><span>)</span> <span>=></span> document<span>.</span><span>querySelectorAll</span><span>(</span>selector<span>)</span><span>)</span>

<span>const</span> getValue <span>=</span> <span>compose</span><span>(</span><span>map</span><span>(</span><span>dom</span> <span>=></span> dom<span>.</span>value<span>)</span><span>,</span> <span>map</span><span>(</span><span>domList</span> <span>=></span> domList<span>[</span><span>0</span><span>]</span><span>)</span><span>,</span> $<span>)</span>

<span>getValue</span><span>(</span><span>'#sb_form_q'</span><span>)</span><span>.</span><span>unsafePerformIO</span><span>(</span><span>)</span>
<span>// 这段代码可以查看 bing 搜索框中的内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="task-精密的时间胶囊"> Task 精密的时间胶囊</h2>
<p>除了IO读写这种阻塞式的副作用，还有一种常见的非阻塞式的副作用，即异步。<br>
而将异步操作变纯的思路跟 IO 函子纯化副作用的思路一致，都是将副作用延迟执行。不同之处在于 IO 函子可以直接返回所需的值，而 Task 函子则需要传入函数，通过函数的参数来得到所需的值。<br>
使用 Task 需要调用它的 fork 方法。</p>
<h3 id="task-的简单实现"> Task 的简单实现</h3>
<div><pre><code><span>class</span> <span>Task</span> <span>{</span>
  <span>constructor</span><span>(</span><span>computation</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>fork <span>=</span> computation
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>resFn<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>_<span>,</span> resolve</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span>resFn<span>)</span><span>)</span>
  <span>}</span>
  <span>// fn 要作用到 resolve 接收的参数上</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>const</span> fork <span>=</span> <span>this</span><span>.</span>fork
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>fork</span><span>(</span>
      <span>rejFn</span> <span>=></span> <span>reject</span><span>(</span>rejFn<span>)</span><span>,</span>
      <span>resFn</span> <span>=></span> <span>resolve</span><span>(</span><span>fn</span><span>(</span>resFn<span>)</span><span>)</span>
    <span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="使用-task-的例子"> 使用 Task 的例子</h3>
<div><pre><code><span>const</span> <span>delayPrint</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span><span>'hehe'</span><span>)</span><span>,</span> <span>2000</span><span>)</span>
<span>}</span><span>)</span>

<span>const</span> getPrint <span>=</span> <span>compose</span><span>(</span><span>map</span><span>(</span><span>res</span> <span>=></span> res <span>+</span> <span>'!!!'</span><span>)</span><span>,</span> delayPrint<span>)</span>

<span>// fork 方法执行的时候，异步动作才真正执行</span>
<span>getPrint</span><span>(</span><span>)</span><span>.</span><span>fork</span><span>(</span>
  <span>rej</span> <span>=></span> rej<span>,</span>
  console<span>.</span>log
<span>)</span>
<span>// 2秒之后打印 hehe!!!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="一个综合的例子-either、io、task"> 一个综合的例子（Either、IO、Task）</h2>
<ol>
<li>判断用户输入的路径，返回不同的 Either(__value)</li>
<li>Right 分支上读取文件，返回 Either(IO(unsafePerformIO))</li>
<li>将文件内容传入异步任务，返回 Either(IO(Task))</li>
</ol>
<div><pre><code><span>const</span> either <span>=</span> <span>curry</span><span>(</span><span>(</span><span>leftFn<span>,</span> rightFn<span>,</span> functor</span><span>)</span> <span>=></span> <span>{</span>
  <span>switch</span><span>(</span>functor<span>.</span>constructor<span>)</span> <span>{</span>
    <span>case</span> Left<span>:</span> <span>return</span> <span>leftFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
    <span>case</span> Right<span>:</span> <span>return</span> <span>rightFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>const</span> <span>IOFn</span> <span>=</span> <span>filePath</span> <span>=></span> <span>new</span> <span>IO</span><span>(</span>
  <span>(</span><span>)</span> <span>=></span> <span>readFileSync</span><span>(</span>filePath<span>,</span> <span>'utf-8'</span><span>)</span>
<span>)</span>

<span>const</span> <span>eitherFn</span> <span>=</span> <span>str</span> <span>=></span> str<span>.</span>length <span>>=</span> <span>14</span> <span>?</span> Right<span>.</span><span>of</span><span>(</span>str<span>)</span> <span>:</span> Left<span>.</span><span>of</span><span>(</span><span>'文件路径少于14个字符'</span><span>)</span>

<span>const</span> <span>taskFn</span> <span>=</span> <span>content</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span>content<span>)</span><span>,</span> <span>2000</span><span>)</span>
<span>}</span><span>)</span>

<span>// 直接使用这个函数的话会得到一个嵌套多层容器的结果，需要这般使用：res.__value.unsafePerformIO().fork(resFn, rejFn)</span>
<span>// res.__value.unsafePerformIO().fork(resFn, rejFn) 这样的调用方式只适用 Right 分支；Left 分支只有一层 Either 容器</span>
<span>const</span> asyncGetFile <span>=</span> <span>compose</span><span>(</span><span>map</span><span>(</span><span>map</span><span>(</span>taskFn<span>)</span><span>)</span><span>,</span> <span>map</span><span>(</span>IOFn<span>)</span><span>,</span> eitherFn<span>)</span>

removeNeedlessContainer <span>=</span> <span>compose</span><span>(</span><span>either</span><span>(</span><span>val</span> <span>=></span> val<span>,</span> <span>val</span> <span>=></span> val<span>.</span><span>unsafePerformIO</span><span>(</span><span>)</span><span>)</span><span>,</span> asyncGetFile<span>)</span>

<span>removeNeedlessContainer</span><span>(</span><span>'./src/test.txt'</span><span>)</span><span>.</span><span>fork</span><span>(</span>
  console<span>.</span>log<span>,</span>
  console<span>.</span>log
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><p>Tips</p>
<p>至此，四类常用的函子已经介绍完毕。可以延伸的话题还很多，例如 Task 与 Promise 的关系...这些暂不准备展开来讲。<br>
在最后一个综合示例中我们可以看到一些别扭的地方，如 compose 中的嵌套 map、返回结果的多层容器嵌套。下面准备请出 monad 登场来解决这两个问题。</p>
</div>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函数式编程</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p>函数式编程总结（使用 javascript 语言）。预计会有一下几块：</p>
<ol>
<li>函数参数处理</li>
<li>函数组合</li>
<li>函子</li>
<li>monad functor</li>
<li>applicative functor</li>
<li>响应函数式编程</li>
</ol>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函数输入处理</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/inputs/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/inputs/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要对函数的参数进行处理"> 为什么要对函数的参数进行处理</h2>
<p>多个参数的输入会增加函数的复杂性，这违背了<strong>一个函数只做一件事</strong>。</p>
<h2 id="如何减少函数参数"> 如何减少函数参数</h2>
<p>我们可以利用闭包来收集参数，让函数延迟执行，等到函数参数收集完成，再最终执行函数</p>
<h3 id="偏函数-partial"> 偏函数(partial)</h3>
<ol>
<li>传入原始函数以及提前确定好的参数（能提前确定的参数一定要定义到靠前位置）</li>
<li>返回新的函数</li>
<li>调用新的函数，传入剩下的参数</li>
</ol>
<div><pre><code><span>const</span> <span>partial</span> <span>=</span> <span>(</span><span>fn<span>,</span> <span>...</span>presetArgs</span><span>)</span> <span>=></span>
  <span>(</span><span><span>...</span>laterArgs</span><span>)</span> <span>=></span> 
    <span>fn</span><span>(</span><span>...</span>presetArgs<span>,</span> <span>...</span>laterArgs<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="柯里化-currying"> 柯里化(currying)</h3>
<ol>
<li>传入原始函数</li>
<li>返回新的函数</li>
<li>调用新的函数，传入提前确定好的参数（这个过程可以进行多次，直到参数收集完成）</li>
</ol>
<div><pre><code><span>const</span> <span>curry</span> <span>=</span> <span>(</span><span>fn<span>,</span> arity <span>=</span> fn<span>.</span>length<span>,</span> nextCurried</span><span>)</span> <span>=></span> 
  <span>(</span><span>nextCurried</span> <span>=</span> <span>prevArgs</span> <span>=></span> 
    <span>(</span><span><span>...</span>nextArgs</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> args <span>=</span> <span>[</span> <span>...</span>prevArgs<span>,</span> <span>...</span>nextArgs <span>]</span>
      <span>return</span> args<span>.</span>length <span>>=</span> arity
        <span>?</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span>
        <span>:</span> <span>nextCurried</span><span>(</span>args<span>)</span>
    <span>}</span>
  <span>)</span><span>(</span><span>[</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>Tips</p>
<p>这里我们只需要关注偏函数与柯里化的用法（这两个工具在几乎所有函数式编程的库里都已经实现），至于它们的实现原理，不用太过深究。</p>
</div>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">monad</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/monad/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/monad/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>monad 是可以变扁（flatten）的 pointed functor。</p>
</blockquote>
<h2 id="容器嵌套引发的灾难"> 容器嵌套引发的灾难</h2>
<p>先看下面一个例子：</p>
<div><pre><code><span>const</span> safeProp <span>=</span> <span>curry</span><span>(</span><span>(</span><span>prop<span>,</span> obj</span><span>)</span> <span>=></span> Maybe<span>.</span><span>of</span><span>(</span>obj<span>[</span>prop<span>]</span><span>)</span><span>)</span>

<span>const</span> getD <span>=</span> <span>compose</span><span>(</span><span>map</span><span>(</span><span>map</span><span>(</span><span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'d'</span><span>)</span><span>)</span><span>)</span><span>)</span><span>,</span> <span>map</span><span>(</span><span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'c'</span><span>)</span><span>)</span><span>)</span><span>,</span> <span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'b'</span><span>)</span><span>)</span><span>,</span> <span>safeProp</span><span>(</span><span>'a'</span><span>)</span><span>)</span>

<span>getD</span><span>(</span><span>{</span> a<span>:</span> <span>{</span> b<span>:</span> <span>{</span> c<span>:</span> <span>{</span> d<span>:</span> <span>'d'</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>)</span>
<span>// Maybe { __value: Maybe { __value: Maybe { __value: [Maybe] } } }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="join-来解围"> join 来解围</h2>
<p>往 Maybe 函子里面添加 join 方法来解开一层外衣（不同函子的 join 实现不一样）</p>
<div><pre><code><span>// 依然用上面的例子</span>
<span>class</span> <span>Maybe</span> <span>{</span>
  <span>// ...</span>
  <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>__value
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>下面我们来重构上面的这个例子</p>
<div><pre><code><span>const</span> <span>join</span> <span>=</span> <span>functor</span> <span>=></span> functor<span>.</span><span>join</span><span>(</span><span>)</span>

<span>// 每当外套达到两件时，就用 join 脱掉一件</span>
<span>const</span> getD <span>=</span> <span>compose</span><span>(</span>join<span>,</span> <span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'d'</span><span>)</span><span>)</span><span>,</span> join<span>,</span> <span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'c'</span><span>)</span><span>)</span><span>,</span> join<span>,</span> <span>map</span><span>(</span><span>safeProp</span><span>(</span><span>'b'</span><span>)</span><span>)</span><span>,</span> <span>safeProp</span><span>(</span><span>'a'</span><span>)</span><span>)</span>

<span>getD</span><span>(</span><span>{</span> a<span>:</span> <span>{</span> b<span>:</span> <span>{</span> c<span>:</span> <span>{</span> d<span>:</span> <span>'d'</span> <span>}</span> <span>}</span> <span>}</span> <span>}</span><span>)</span>
<span>// Maybe { __value: 'd' }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="chain-更进一步"> chain 更进一步</h2>
<p>我们总是在紧跟着 map 的后面调用 join。让我们把这个行为抽象到一个叫做 chain 的函数里。<br>
chain 将 map 之后再 join 的行为整合到一起，从而简化我们的书写。</p>
<div><pre><code><span>class</span> <span>Maybe</span> <span>{</span>
  <span>// ...</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>join</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>使用 chain 来重构上面的例子</p>
<div><pre><code><span>const</span> chain <span>=</span> <span>curry</span><span>(</span><span>(</span><span>fn<span>,</span> functor</span><span>)</span> <span>=></span> functor<span>.</span><span>chain</span><span>(</span>fn<span>)</span><span>)</span>

<span>const</span> getD <span>=</span> <span>compose</span><span>(</span><span>chain</span><span>(</span><span>safeProp</span><span>(</span><span>'d'</span><span>)</span><span>)</span><span>,</span> <span>chain</span><span>(</span><span>safeProp</span><span>(</span><span>'c'</span><span>)</span><span>)</span><span>,</span> <span>chain</span><span>(</span><span>safeProp</span><span>(</span><span>'b'</span><span>)</span><span>)</span><span>,</span> <span>safeProp</span><span>(</span><span>'a'</span><span>)</span><span>)</span>
<span>// Maybe { __value: 'd' }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="其他函子的-chain-实现"> 其他函子的 chain 实现</h2>
<p>Either</p>
<div><pre><code><span>class</span> <span>Left</span> <span>{</span>
  <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span>
<span>class</span> <span>Right</span> <span>{</span>
  <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>__value
  <span>}</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>join</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>IO</p>
<div><pre><code><span>class</span> <span>IO</span> <span>{</span>
  <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>unsafePerformIO</span><span>(</span><span>)</span>
  <span>}</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>join</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Task</p>
<div><pre><code><span>class</span> <span>Task</span> <span>{</span>
  <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> fork <span>=</span> <span>this</span><span>.</span>fork
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>fork</span><span>(</span>
      <span>err</span> <span>=></span> <span>reject</span><span>(</span>err<span>)</span><span>,</span>
      <span>res</span> <span>=></span> res<span>.</span><span>fork</span><span>(</span>reject<span>,</span> resolve<span>)</span>
    <span>)</span><span>)</span>
  <span>}</span>
  <span>// 借助 map 和 join 方法（尝试用 . 的方式调用 chain 方法执行串行的两个任务看看，会有惊喜）</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>map</span><span>(</span>fn<span>)</span><span>.</span><span>join</span><span>(</span><span>)</span>
  <span>}</span>
  <span>// 完整实现</span>
  <span>chain</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>const</span> fork <span>=</span> <span>this</span><span>.</span>fork
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>fork</span><span>(</span>
      <span>err</span> <span>=></span> <span>reject</span><span>(</span>err<span>)</span><span>,</span> 
      <span>res</span> <span>=></span> <span>fn</span><span>(</span>res<span>)</span><span>.</span><span>fork</span><span>(</span>reject<span>,</span> resolve<span>)</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="换个角度看-chain"> 换个角度看 chain</h2>
<blockquote>
<p>使用传入的函数处理自己的值，使用外部的壳（如果外部带壳的话）</p>
</blockquote>
<p>前面我们由 <code>map</code> 和 <code>join</code> 进化为 <code>chain</code>。但如果只是把 <code>chain</code> 当作是一个吸尘器的话，还是太小看 <code>chain</code> 了。而且每次理解 <code>chain</code> 都要借助 map 和 join 的话，对我们心智也是个不小的负担。</p>
<p>因为 <code>chain</code> 可以轻松地嵌套多个作用，因此我们就能以一种纯函数的方式来表示序列(sequence)和变量赋值(variable assignment)。</p>
<div><pre><code><span>// getJSON :: Url -> Params -> Task JSON</span>
<span>// querySelector :: Selector -> IO DOM</span>

<span>getJSON</span><span>(</span><span>'/authenticate'</span><span>,</span> <span>{</span>username<span>:</span> <span>'stale'</span><span>,</span> password<span>:</span> <span>'crackers'</span><span>}</span><span>)</span>
  <span>.</span><span>chain</span><span>(</span><span>user</span> <span>=></span> <span>getJSON</span><span>(</span><span>'/friends'</span><span>,</span> <span>{</span>user_id<span>:</span> user<span>.</span>id<span>}</span><span>)</span><span>)</span>

<span>querySelector</span><span>(</span><span>"input.username"</span><span>)</span>
  <span>.</span><span>chain</span><span>(</span><span>uname</span> <span>=></span> <span>querySelector</span><span>(</span><span>"input.email"</span><span>)</span>
    <span>.</span><span>chain</span><span>(</span><span>email</span> <span>=></span> <span>IO</span><span>.</span><span>of</span><span>(</span><span>"Welcome "</span> <span>+</span> uname<span>.</span>value <span>+</span> <span>" "</span> <span>+</span> <span>"prepare for spam at "</span> <span>+</span> email<span>.</span>value<span>)</span><span>)</span>
  <span>)</span>

Maybe<span>.</span><span>of</span><span>(</span><span>3</span><span>)</span>
  <span>.</span><span>chain</span><span>(</span><span>three</span> <span>=></span> Maybe<span>.</span><span>of</span><span>(</span><span>2</span><span>)</span><span>.</span><span>map</span><span>(</span><span>add</span><span>(</span>three<span>)</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">Observable</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/rxjs/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/rxjs/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Observable 是 rx 体系中的一个概念，而 rx 本身就是一个很大的话题。但是这里我们只是单纯地从函数式编程的角度来理解 Observable</p>
</blockquote>
<h2 id="observable-如何使用"> Observable 如何使用</h2>
<p><code>Observable</code> 接收一个生产数据的函数，每当这个函数（生产者）生产出新的数据，就会调用 <code>subscribe</code> 传入的函数（消费者）。<br>
它看起来有点像之前提到过的 Task functor，同样是传入生产函数，通过某个方法传入回调函数。不同之处在于 <code>Task</code> 有成功、pedding、失败三种状态。而 <code>Observable</code> 由成功变为完成状态，pedding 变成不断发射值的 next 状态，失败状态与 <code>Task</code> 保持一致。<br>
用一句糙话来讲就是：<code>Observable</code> 是 <code>Task</code> 或是 <code>Promise</code> 的加强版。</p>
<div><pre><code><span>const</span> observable <span>=</span> <span>new</span> <span>Observable</span><span>(</span><span>observer</span> <span>=></span> <span>{</span>
  <span>let</span> i <span>=</span> <span>1</span>
  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> observer<span>.</span><span>next</span><span>(</span>i<span>++</span><span>)</span><span>,</span> <span>1000</span><span>)</span>
<span>}</span><span>)</span>

observable
  <span>.</span><span>pipe</span><span>(</span>
    <span>val</span> <span>=></span> val <span>*</span> <span>2</span><span>,</span>
    <span>val</span> <span>=></span> <span>++</span>val
  <span>)</span>
  <span>.</span><span>subscribe</span><span>(</span>
    console<span>.</span>log
  <span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="observable-简单实现"> Observable 简单实现</h2>
<div><pre><code><span>class</span> <span>Observable</span> <span>{</span>
  <span>constructor</span><span>(</span><span>createFn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>createFn <span>=</span> createFn
  <span>}</span>
  <span>next</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>resFn</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>subscribe</span><span>(</span><span>resFn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>createFn</span><span>(</span><span>this</span><span>)</span>
    <span>this</span><span>.</span>resFn <span>=</span> <span>compose</span><span>(</span>resFn<span>,</span> <span>this</span><span>.</span>handleFn<span>)</span>
  <span>}</span>
  <span>pipe</span><span>(</span><span><span>...</span>fns</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>handleFn <span>=</span> <span>compose</span><span>(</span><span>...</span>fns<span>.</span><span>reverse</span><span>(</span><span>)</span><span>)</span>
    <span>return</span> <span>this</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="next-是对-resolve-的升维"> next 是对 resolve 的升维</h2>
<p>对于 Task 而言，resolve 意味着该函子生命周期的结束。而放到一个应用中看，我们需要许许多多的 Task 来管理我们的应用。而经过 next 这个状态的扩展之后，前段中的很多场景都可以被抽象为 Observable 了。如：事件响应、ajax、websocket......<br>
增加一个维度，表现力大增。<br>
夹一个私货：为什么毛笔的艺术表现力强于钢笔，窃以为毛笔比钢笔多了线条宽度这样一个维度。</p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函子之间的转换</title>
    <id>https://x-vic.gitee.io/code/code/views/functional/transform/</id>
    <link href="https://x-vic.gitee.io/code/code/views/functional/transform/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>我们在借用函子的各种能力的时候，不可避免会出现函子嵌套函子的情况。前面两章，我们分别介绍了 chain 以及 ap 工具来避免了这种嵌套的情况。</p>
</blockquote>
<h2 id="totask"> toTask</h2>
<p><code>Task</code> 之外的函子转换比较简单，这里不再赘述。这里只能看到其他函子转成 Task，而不能看到 Task 转成其他函子，因为我们没法将异步操作转为同步操作。</p>
<div><pre><code><span>// eitherToTask :: Either a b -> Task a b</span>
<span>const</span> eitherToTask <span>=</span> <span>either</span><span>(</span>Task<span>.</span>rejected<span>,</span> Task<span>.</span>of<span>)</span>

<span>// ioToTask :: IO a -> Task () a</span>
<span>const</span> <span>ioToTask</span> <span>=</span> <span>x</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>resolve</span><span>(</span>x<span>.</span><span>unsafePerform</span><span>(</span><span>)</span><span>)</span><span>)</span>

<span>// maybeToTask :: Maybe a -> Task () a</span>
<span>const</span> <span>maybeToTask</span> <span>=</span> <span>x</span> <span>=></span> <span>(</span>x<span>.</span>isNothing <span>?</span> Task<span>.</span><span>rejected</span><span>(</span><span>)</span> <span>:</span> Task<span>.</span><span>of</span><span>(</span>x<span>.</span>$value<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="同构-promise-与-task"> 同构 Promise 与 Task</h2>
<div><pre><code><span>// promiseToTask :: Promise a b -> Task a b</span>
<span>const</span> <span>promiseToTask</span> <span>=</span> <span>x</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> x<span>.</span><span>then</span><span>(</span>resolve<span>)</span><span>.</span><span>catch</span><span>(</span>reject<span>)</span><span>)</span>

<span>// taskToPromise :: Task a b -> Promise a b</span>
<span>const</span> <span>taskToPromise</span> <span>=</span> <span>x</span> <span>=></span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> x<span>.</span><span>fork</span><span>(</span>reject<span>,</span> resolve<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="使用示例-顺便复习前面的内容"> 使用示例（顺便复习前面的内容）</h2>
<p>下面来模拟一个场景：读取本地文件的内容，将之提交给服务器。</p>
<ol>
<li>校验传入的文件路径（文件读取失败时，reject 一个 Maybe 包装值）</li>
<li>将 Maybe 转为 Task</li>
<li>校验内容长度</li>
<li>将 Either 转为 Task</li>
<li>提交内容</li>
</ol>
<div><pre><code><span>const</span> <span>{</span> readFile <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span>
<span>const</span> <span>{</span> compose<span>,</span> curry <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'ramda'</span><span>)</span>

<span>class</span> <span>Maybe</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Maybe</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>isNothing</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>__value <span>===</span> <span>undefined</span> <span>||</span> <span>this</span><span>.</span>__value <span>===</span> <span>null</span>
  <span>}</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>isNothing
      <span>?</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>null</span><span>)</span>
      <span>:</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>fn</span><span>(</span><span>this</span><span>.</span>__value<span>)</span><span>)</span>
  <span>}</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>fn</span><span>(</span><span>this</span><span>.</span>__value<span>)</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Either</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>__value <span>=</span> value
  <span>}</span>
<span>}</span>

<span>class</span> <span>Left</span> <span>extends</span> <span>Either</span> <span>{</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Left</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span>
  <span>}</span>
  <span>isLeft</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span>
  <span>}</span>
  <span>isRight</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Right</span> <span>extends</span> <span>Either</span> <span>{</span>
  <span>static</span> <span>of</span><span>(</span>value<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Right</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>constructor<span>.</span><span>of</span><span>(</span><span>fn</span><span>(</span><span>this</span><span>.</span>constructor<span>)</span><span>)</span>
  <span>}</span>
  <span>isLeft</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span>
  <span>}</span>
  <span>isRight</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>Task</span> <span>{</span>
  <span>constructor</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>fork <span>=</span> fn
  <span>}</span>
  <span>// 组合 resolve 与 fn</span>
  <span>map</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>fork</span><span>(</span>
      reject<span>,</span>
      <span>compose</span><span>(</span>resolve<span>,</span> fn<span>)</span>
    <span>)</span><span>)</span>
  <span>}</span>
  <span>// 调用 fork 之后，返回的依然是 Task</span>
  <span>chain</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>fork</span><span>(</span>
      reject<span>,</span>
      <span>res</span> <span>=></span> <span>fn</span><span>(</span>res<span>)</span><span>.</span><span>fork</span><span>(</span>reject<span>,</span> resolve<span>)</span><span>)</span>
    <span>)</span>
  <span>}</span>
  <span>ap</span><span>(</span><span>functor</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span><span>chain</span><span>(</span><span>fn</span> <span>=></span> functor<span>.</span><span>map</span><span>(</span>fn<span>)</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>const</span> map <span>=</span> <span>curry</span><span>(</span><span>(</span><span>fn<span>,</span> functor</span><span>)</span> <span>=></span> functor<span>.</span><span>map</span><span>(</span>fn<span>)</span><span>)</span>
<span>const</span> either <span>=</span> <span>curry</span><span>(</span><span>(</span><span>leftFn<span>,</span> rightFn<span>,</span> functor</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>functor<span>.</span><span>isLeft</span><span>(</span><span>)</span><span>)</span> <span>return</span> <span>leftFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
  <span>if</span> <span>(</span>functor<span>.</span><span>isRight</span><span>(</span><span>)</span><span>)</span> <span>return</span> <span>rightFn</span><span>(</span>functor<span>.</span>__value<span>)</span>
<span>}</span><span>)</span>
<span>const</span> chain <span>=</span> <span>curry</span><span>(</span><span>(</span><span>fn<span>,</span> functor</span><span>)</span> <span>=></span> functor<span>.</span><span>chain</span><span>(</span>fn<span>)</span><span>)</span>

<span>const</span> <span>maybeToTask</span> <span>=</span> <span>functor</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> functor<span>.</span><span>isNothing</span><span>(</span><span>)</span> <span>?</span> <span>reject</span><span>(</span><span>)</span> <span>:</span> <span>resolve</span><span>(</span>functor<span>.</span>__value<span>)</span><span>)</span>
<span>const</span> <span>eitherToTask</span> <span>=</span> <span>functor</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>either</span><span>(</span>reject<span>,</span> resolve<span>,</span> functor<span>)</span><span>)</span>

<span>// 读取文件</span>
<span>const</span> <span>read</span> <span>=</span> <span>(</span><span>path</span><span>)</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>path<span>)</span> <span>return</span> <span>reject</span><span>(</span><span>'非法 path'</span><span>)</span>
  <span>readFile</span><span>(</span>path<span>,</span> <span>'utf8'</span><span>,</span> <span>(</span><span>err<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span><span>(</span>err<span>)</span> <span>return</span> <span>reject</span><span>(</span>err<span>)</span>
    <span>resolve</span><span>(</span>Maybe<span>.</span><span>of</span><span>(</span>res<span>)</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
<span>const</span> <span>validateLen</span> <span>=</span> <span>str</span> <span>=></span> str<span>.</span>length <span>&lt;</span> <span>3</span> <span>?</span> Left<span>.</span><span>of</span><span>(</span>str<span>)</span> <span>:</span> Right<span>.</span><span>of</span><span>(</span>str<span>)</span>
<span>const</span> <span>submitStr</span> <span>=</span> <span>str</span> <span>=></span> <span>new</span> <span>Task</span><span>(</span><span>(</span><span>reject<span>,</span> resolve</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>str<span>.</span>length <span>&lt;=</span> <span>10</span><span>)</span> <span>return</span> <span>resolve</span><span>(</span><span>'响应内容：'</span> <span>+</span> str<span>)</span>
  <span>return</span> <span>reject</span><span>(</span><span>'长度超过10'</span> <span>+</span> str<span>)</span>
<span>}</span><span>)</span>

<span>// 永远记住：对 Task 进行 chain 相当于执行了上一个 Task.fork 函数</span>
<span>const</span> run <span>=</span> <span>compose</span><span>(</span>
  <span>chain</span><span>(</span>submitStr<span>)</span><span>,</span>
  <span>chain</span><span>(</span>eitherToTask<span>)</span><span>,</span>
  <span>map</span><span>(</span>validateLen<span>)</span><span>,</span>
  <span>chain</span><span>(</span>maybeToTask<span>)</span><span>,</span>
  read
<span>)</span>

<span>run</span><span>(</span><span>'./src/00.txt'</span><span>)</span><span>.</span><span>fork</span><span>(</span>
  <span>rej</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'rej:::'</span><span>,</span> rej<span>)</span><span>,</span>
  <span>res</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'res:::'</span><span>,</span> res<span>)</span>
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">redux-observable 源码解读</title>
    <id>https://x-vic.gitee.io/code/code/views/others/redux-observable/</id>
    <link href="https://x-vic.gitee.io/code/code/views/others/redux-observable/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>redux-observable 是一个 redux 中间件。与多数 redux 中间件不同的是：其他中间件做的是改造 action 的工作，而 redux-observable 是在 action 的上层添加了一个对 action 流的监听，获取它所需要的 action，最后处理成不同的 action.</p>
</blockquote>
<h2 id="提问"> 提问</h2>
<ul>
<li>redux-observable 如何能够监听到所有的 action ？</li>
<li>业务里面的 epic 是何时被调用的？</li>
<li>其他中间件如何接管 redux-observable 映射出来的 action？</li>
</ul>
<h2 id="createepicmiddleware-创建中间件"> createEpicMiddleware 创建中间件</h2>
<ol>
<li>创建 action 流</li>
<li>创建 state 流（有初始值）</li>
<li>创建 result 流（后面经过一次 run 会转化成各种 $action 的变形）</li>
<li>监听 result$ 出发 dispatch</li>
</ol>
<div><pre><code><span>const</span> epicMiddleware<span>:</span> EpicMiddleware<span>&lt;</span><span>T</span><span>,</span> <span>O</span><span>,</span> <span>S</span><span>,</span> <span>D</span><span>></span> <span>=</span> _store <span>=></span> <span>{</span>
    store <span>=</span> _store<span>;</span>
    <span>const</span> actionSubject$ <span>=</span> <span>new</span> <span>Subject<span>&lt;</span><span>T</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>const</span> stateSubject$ <span>=</span> <span>new</span> <span>Subject<span>&lt;</span><span>S</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>const</span> action$ <span>=</span> actionSubject$
      <span>.</span><span>asObservable</span><span>(</span><span>)</span>
      <span>.</span><span>pipe</span><span>(</span><span>observeOn</span><span>(</span>uniqueQueueScheduler<span>)</span><span>)</span><span>;</span>
    <span>const</span> state$ <span>=</span> <span>new</span> <span>StateObservable</span><span>(</span>
      stateSubject$<span>.</span><span>pipe</span><span>(</span><span>observeOn</span><span>(</span>uniqueQueueScheduler<span>)</span><span>)</span><span>,</span>
      store<span>.</span><span>getState</span><span>(</span><span>)</span>
    <span>)</span><span>;</span>

    <span>const</span> result$ <span>=</span> epic$<span>.</span><span>pipe</span><span>(</span>
      <span>map</span><span>(</span>epic <span>=></span> <span>{</span>
        <span>const</span> output$ <span>=</span> <span>epic</span><span>(</span>action$<span>,</span> state$<span>,</span> options<span>.</span>dependencies<span>!</span><span>)</span><span>;</span>
        <span>return</span> output$<span>;</span>
      <span>}</span><span>)</span><span>,</span>
      <span>// 合并所有 epic 返回的流</span>
      <span>mergeMap</span><span>(</span>output$ <span>=></span>
        <span>from</span><span>(</span>output$<span>)</span><span>.</span><span>pipe</span><span>(</span>
          <span>subscribeOn</span><span>(</span>uniqueQueueScheduler<span>)</span><span>,</span>
          <span>observeOn</span><span>(</span>uniqueQueueScheduler<span>)</span>
        <span>)</span>
      <span>)</span>
    <span>)</span><span>;</span>

    result$<span>.</span><span>subscribe</span><span>(</span>store<span>.</span>dispatch<span>)</span><span>;</span>

    <span>// 返回的这一整块是 redux 中间件</span>
    <span>return</span> next <span>=></span> <span>{</span>
      <span>return</span> action <span>=></span> <span>{</span>
        <span>const</span> result <span>=</span> <span>next</span><span>(</span>action<span>)</span><span>;</span>
        stateSubject$<span>.</span><span>next</span><span>(</span>store<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 每次有 action 发出，就通知 epic 里面的监听器</span>
        actionSubject$<span>.</span><span>next</span><span>(</span>action<span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
      <span>}</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>;</span>

  epicMiddleware<span>.</span><span>run</span> <span>=</span> rootEpic <span>=></span> <span>{</span>
    epic$<span>.</span><span>next</span><span>(</span>rootEpic<span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> epicMiddleware<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="combineepics-合并所有-epic-返回新的-epic"> combineEpics 合并所有 epic 返回新的 epic</h2>
<div><pre><code><span>export</span> <span>function</span> <span>combineEpics</span><span>(</span><span><span>...</span>epics</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>merge</span><span>(</span>
    <span>...</span>epics<span>.</span><span>map</span><span>(</span><span>epic</span> <span>=></span> <span>{</span>
      <span>return</span> <span>epic</span><span>(</span><span>...</span>args<span>)</span>
    <span>}</span><span>)</span>
  <span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="最后"> 最后</h2>
<p>redux-observable 如何能够监听到所有的 action ？</p>
<p>epic 里边监听了 action$；每次有 action 发射的时候，action$ 会将这个 action 发射出去。</p>
<p>其他中间件如何接管 redux-observable 映射出来的 action ？</p>
<p>$result 被监听最终会执行 dispatch</p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">rxjs-hooks 源码解读</title>
    <id>https://x-vic.gitee.io/code/code/views/others/rxjs-hooks/</id>
    <link href="https://x-vic.gitee.io/code/code/views/others/rxjs-hooks/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<div><p>Tips</p>
<p>这里一共 useObservable 以及 useEventCallback 两个 hook。<br>
useObservable 从虚无中或是变化的 props 中得到衍生的数据。<br>
useEventCallback 从点击事件、变化的 props 中得到衍生数据。</p>
</div>
<h2 id="useobservable"> useObservable</h2>
<ol>
<li>创建 state</li>
<li>调用传入的函数，得到输出流，监听该流，更新 state</li>
<li>组件销毁时做一些清理工作</li>
</ol>
<div><pre><code><span>export</span> <span>function</span> <span>useObservable</span><span>(</span>
  inputFactory<span>,</span>
  initialState<span>,</span>
  inputs<span>,</span>
<span>)</span> <span>{</span>
  <span>const</span> <span>[</span>state<span>,</span> setState<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>typeof</span> initialState <span>!==</span> <span>'undefined'</span> <span>?</span> initialState <span>:</span> <span>null</span><span>)</span>

  <span>const</span> state$ <span>=</span> <span>useConstant</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>new</span> <span>BehaviorSubject</span><span>(</span>initialState<span>)</span><span>)</span>
  <span>const</span> inputs$ <span>=</span> <span>useConstant</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>new</span> <span>BehaviorSubject</span><span>(</span>inputs<span>)</span><span>)</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    inputs$<span>.</span><span>next</span><span>(</span>inputs<span>)</span>
  <span>}</span><span>,</span> inputs <span>||</span> <span>[</span><span>]</span><span>)</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>let</span> output$
    <span>if</span> <span>(</span>inputs<span>)</span> <span>{</span>
      output$ <span>=</span> <span>inputFactory</span><span>(</span>state$<span>,</span> inputs$<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      output$ <span>=</span> <span>inputFactory</span><span>(</span>state$<span>)</span>
    <span>}</span>
    <span>const</span> subscription <span>=</span> output$<span>.</span><span>subscribe</span><span>(</span><span>(</span>value<span>)</span> <span>=></span> <span>{</span>
      state$<span>.</span><span>next</span><span>(</span>value<span>)</span>
      <span>setState</span><span>(</span>value<span>)</span>
    <span>}</span><span>)</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      subscription<span>.</span><span>unsubscribe</span><span>(</span><span>)</span>
      inputs$<span>.</span><span>complete</span><span>(</span><span>)</span>
      state$<span>.</span><span>complete</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span>

  <span>return</span> state
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h2 id="useeventcallback"> useEventCallback</h2>
<p>与 useObservable 相似，不过是提供了从外部发射事件的能力。</p>
<div><pre><code><span>export</span> <span>function</span> <span>useEventCallback</span><span>(</span>
  callback<span>,</span>
  initialState<span>,</span>
  inputs<span>,</span>
<span>)</span> <span>{</span>
  <span>const</span> initialValue <span>=</span> <span>typeof</span> initialState <span>!==</span> <span>'undefined'</span> <span>?</span> initialState <span>:</span> <span>null</span>
  <span>const</span> <span>[</span>state<span>,</span> setState<span>]</span> <span>=</span> <span>useState</span><span>(</span>initialValue<span>)</span>
  <span>const</span> event$ <span>=</span> <span>useConstant</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>new</span> <span>Subject</span><span>(</span><span>)</span><span>)</span>
  <span>const</span> state$ <span>=</span> <span>useConstant</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>new</span> <span>BehaviorSubject</span><span>(</span>initialValue<span>)</span><span>)</span>
  <span>const</span> inputs$ <span>=</span> <span>useConstant</span><span>(</span>
    <span>(</span><span>)</span> <span>=></span> <span>new</span> <span>BehaviorSubject</span><span>(</span><span>typeof</span> inputs <span>===</span> <span>'undefined'</span> <span>?</span> <span>null</span> <span>:</span> inputs<span>)</span><span>,</span>
  <span>)</span>

  <span>function</span> <span>eventCallback</span><span>(</span>e<span>)</span> <span>{</span>
    <span>return</span> event$<span>.</span><span>next</span><span>(</span>e<span>)</span>
  <span>}</span>
  <span>const</span> returnedCallback <span>=</span> <span>useCallback</span><span>(</span>eventCallback<span>,</span> <span>[</span><span>]</span><span>)</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    inputs$<span>.</span><span>next</span><span>(</span>inputs<span>!</span><span>)</span>
  <span>}</span><span>,</span> inputs <span>||</span> <span>[</span><span>]</span><span>)</span>

  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>setState</span><span>(</span>initialValue<span>)</span>
    <span>let</span> value$

    <span>if</span> <span>(</span><span>!</span>inputs<span>)</span> <span>{</span>
      value$ <span>=</span> <span>callback</span><span>(</span>event$<span>,</span> state$<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      value$ <span>=</span> <span>callback</span><span>(</span>event$<span>,</span> state$<span>,</span> inputs$<span>)</span>
    <span>}</span>
    <span>const</span> subscription <span>=</span> value$<span>.</span><span>subscribe</span><span>(</span><span>(</span>value<span>)</span> <span>=></span> <span>{</span>
      state$<span>.</span><span>next</span><span>(</span>value<span>)</span>
      <span>setState</span><span>(</span>value<span>)</span>
    <span>}</span><span>)</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      subscription<span>.</span><span>unsubscribe</span><span>(</span><span>)</span>
      state$<span>.</span><span>complete</span><span>(</span><span>)</span>
      inputs$<span>.</span><span>complete</span><span>(</span><span>)</span>
      event$<span>.</span><span>complete</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span> <span>// immutable forever</span>

  <span>return</span> <span>[</span>returnedCallback<span>,</span> state<span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">koa</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-koa/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-koa/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>koa 给我印象比较深刻的是 ctx 以及中间件的洋葱模型，本次简单实现中，重点实现这两个特性</p>
</blockquote>
<h2 id="目录结构"> 目录结构</h2>
<p>koa 主要有以下几个模块：</p>
<ul>
<li>application.js 核心模块</li>
<li>context.js 上下文模块</li>
<li>response.js 响应对象模块</li>
<li>request.js 请求对象模块</li>
</ul>
<h2 id="request"> request</h2>
<div><pre><code><span>const</span> url <span>=</span> <span>require</span><span>(</span><span>'url'</span><span>)</span>

<span>const</span> request <span>=</span> <span>{</span>
  <span>get</span> <span>url</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>req<span>.</span>url
  <span>}</span><span>,</span>
  <span>get</span> <span>path</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> url<span>.</span><span>parse</span><span>(</span><span>this</span><span>.</span>req<span>.</span>url<span>)</span><span>.</span>pathname
  <span>}</span><span>,</span>
  <span>get</span> <span>query</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> url<span>.</span><span>parse</span><span>(</span><span>this</span><span>.</span>req<span>.</span>url<span>)</span><span>.</span>query
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> request
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="response"> response</h2>
<div><pre><code><span>const</span> response <span>=</span> <span>{</span>
  <span>get</span> <span>body</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>_body
  <span>}</span><span>,</span>
  <span>set</span> <span>body</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>res<span>.</span>statusCode <span>=</span> <span>200</span>
    <span>this</span><span>.</span>_body <span>=</span> value
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> response
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="context"> context</h2>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> proto <span>=</span> <span>{</span><span>}</span>

<span>function</span> <span>defineGetter</span><span>(</span><span>prop<span>,</span> name</span><span>)</span> <span>{</span>
  proto<span>.</span><span>__defineGetter__</span><span>(</span>name<span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>[</span>prop<span>]</span><span>[</span>name<span>]</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>defineSetter</span><span>(</span><span>prop<span>,</span> name</span><span>)</span> <span>{</span>
  proto<span>.</span><span>__defineSetter__</span><span>(</span>name<span>,</span> <span>function</span><span>(</span><span>val</span><span>)</span> <span>{</span>
    <span>this</span><span>[</span>prop<span>]</span><span>[</span>name<span>]</span> <span>=</span> val
  <span>}</span><span>)</span>
<span>}</span>
<span>// 访问 ctx 的某个属性时，代理到 request 或 response 的对应属性上</span>
<span>defineGetter</span><span>(</span><span>'request'</span><span>,</span> <span>'url'</span><span>)</span>
<span>defineGetter</span><span>(</span><span>'request'</span><span>,</span> <span>'path'</span><span>)</span>
<span>defineGetter</span><span>(</span><span>'response'</span><span>,</span> <span>'body'</span><span>)</span>
<span>defineSetter</span><span>(</span><span>'response'</span><span>,</span> <span>'body'</span><span>)</span>

module<span>.</span>exports <span>=</span> proto
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="application"> application</h2>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> EventEmmit <span>=</span> <span>require</span><span>(</span><span>'events'</span><span>)</span>
<span>const</span> Stream <span>=</span> <span>require</span><span>(</span><span>'stream'</span><span>)</span>
<span>const</span> request <span>=</span> <span>require</span><span>(</span><span>'./request'</span><span>)</span>
<span>const</span> context <span>=</span> <span>require</span><span>(</span><span>'./context'</span><span>)</span>
<span>const</span> response <span>=</span> <span>require</span><span>(</span><span>'./response'</span><span>)</span>

<span>class</span> <span>VKoa</span> <span>extends</span> <span>EventEmmit</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>)</span>
    <span>this</span><span>.</span>middlewares <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>request <span>=</span> request
    <span>this</span><span>.</span>response <span>=</span> response
    <span>this</span><span>.</span>context <span>=</span> context
  <span>}</span>
  <span>use</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>middlewares<span>.</span><span>push</span><span>(</span>fn<span>)</span>
  <span>}</span>
  <span>// 实现洋葱模型中间件的关键逻辑</span>
  <span>async</span> <span>compose</span><span>(</span><span>middlewares<span>,</span> ctx</span><span>)</span> <span>{</span>
    <span>const</span> <span>dispatch</span> <span>=</span> <span>async</span><span>(</span><span>index</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>index <span>>=</span> middlewares<span>.</span>length<span>)</span> <span>return</span>
      <span>const</span> middleware <span>=</span> middlewares<span>[</span>index<span>]</span>
      <span>return</span> <span>middleware</span><span>(</span>ctx<span>,</span> <span>(</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span>index <span>+</span> <span>1</span><span>)</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>dispatch</span><span>(</span><span>0</span><span>)</span>
  <span>}</span>
  <span>// 这一块主要是让用户能够更方便地获取 ctx request response 三个对象</span>
  <span>createContext</span><span>(</span><span>req<span>,</span> res</span><span>)</span><span>{</span>
    <span>const</span> ctx <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>this</span><span>.</span>context<span>)</span>
    <span>const</span> request <span>=</span> ctx<span>.</span>request <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>this</span><span>.</span>request<span>)</span>
    <span>const</span> response <span>=</span> ctx<span>.</span>response <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>this</span><span>.</span>response<span>)</span>
    ctx<span>.</span>req <span>=</span> request<span>.</span>req <span>=</span> response<span>.</span>req <span>=</span> req
    ctx<span>.</span>res <span>=</span> request<span>.</span>res <span>=</span> response<span>.</span>res <span>=</span> res
    request<span>.</span>ctx <span>=</span> response<span>.</span>ctx <span>=</span> ctx
    request<span>.</span>response <span>=</span> response
    response<span>.</span>request <span>=</span> request
    <span>return</span> ctx
  <span>}</span>
  <span>// 执行完所有中间件之后，根据 ctx.body 的类型返回相应的 Content-Type</span>
  <span>handleRequest</span><span>(</span><span>req<span>,</span> res</span><span>)</span><span>{</span>
    res<span>.</span>statusCode <span>=</span> <span>404</span>
    <span>const</span> ctx <span>=</span> <span>this</span><span>.</span><span>createContext</span><span>(</span>req<span>,</span> res<span>)</span>
    <span>const</span> fn <span>=</span> <span>this</span><span>.</span><span>compose</span><span>(</span><span>this</span><span>.</span>middlewares<span>,</span> ctx<span>)</span>
    fn<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span><span>(</span><span>typeof</span> ctx<span>.</span>body <span>==</span> <span>'object'</span><span>)</span><span>{</span>
        res<span>.</span><span>setHeader</span><span>(</span><span>'Content-Type'</span><span>,</span> <span>'application/json;charset=utf8'</span><span>)</span>
        res<span>.</span><span>end</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>ctx<span>.</span>body<span>)</span><span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>ctx<span>.</span>body <span>instanceof</span> <span>Stream</span><span>)</span><span>{</span> <span>// 如果是流</span>
        ctx<span>.</span>body<span>.</span><span>pipe</span><span>(</span>res<span>)</span>
      <span>}</span>
      <span>else</span> <span>if</span> <span>(</span><span>typeof</span> ctx<span>.</span>body <span>===</span> <span>'string'</span> <span>||</span> Buffer<span>.</span><span>isBuffer</span><span>(</span>ctx<span>.</span>body<span>)</span><span>)</span> <span>{</span>
        res<span>.</span><span>setHeader</span><span>(</span><span>'Content-Type'</span><span>,</span> <span>'text/htmlcharset=utf8'</span><span>)</span>
        res<span>.</span><span>end</span><span>(</span>ctx<span>.</span>body<span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        res<span>.</span><span>end</span><span>(</span><span>'Not found'</span><span>)</span>
      <span>}</span>
    <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
      <span>this</span><span>.</span><span>emit</span><span>(</span><span>'error'</span><span>,</span> err<span>)</span>
      res<span>.</span>statusCode <span>=</span> <span>500</span>
      res<span>.</span><span>end</span><span>(</span><span>'server error'</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
  <span>listen</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>const</span> server <span>=</span> http<span>.</span><span>createServer</span><span>(</span><span>this</span><span>.</span><span>handleRequest</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>
    server<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span>
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> VKoa
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">Concurrent Mode &amp; fiber</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/fiber/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/fiber/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<div><p>主旨</p>
<p>上一版实现的 <code>render</code> 是通过递归的方式将 <code>dom</code> 层层插入，最终实现了虚拟dom到页面的渲染。<br>
但是这么做的问题在于递归的过程无法中断，从而导致阻塞用户点击事件和渲染动画这些高优先级的操作，给人一种卡顿的感觉。<br>
这次旨在解决上述问题。</p>
</div>
<p>Concurrent Mode
@flowstart
render=&gt;start: 设置下一个执行单元为根fiber
setNextUnitOfWork=&gt;operation: 设置下一个执行单元
nextUnitOfWork=&gt;condition: 浏览器空闲
handleCurrentFiber=&gt;parallel: 处理当前fiber
nextCallback=&gt;operation: 设置下一次空闲时的任务</p>
<p>createDom=&gt;operation: 给 fiber 创建 dom
appendChild=&gt;operation: 将自身的 dom 插到父 fiber 上
createChildrenFiber=&gt;subroutine: 为每一个子元素创建 fiber
fiberHasChild=&gt;condition: fiber 是否有 child
hasSibling=&gt;condition: 是否有 sibling
hasParentSibling=&gt;condition: 父节点是否有 sibling
returnParent=&gt;operation: 回到上层继续查找
end=&gt;end: 暂停遍历 fiber 树</p>
<p>render-&gt;setNextUnitOfWork-&gt;nextUnitOfWork(yes)-&gt;handleCurrentFiber(path1, left)-&gt;setNextUnitOfWork
nextUnitOfWork(no)-&gt;nextCallback-&gt;end
@flowend</p>
<h2 id="利用浏览器的空闲算力"> 利用浏览器的空闲算力</h2>
<p>在一个循环中执行任务单元；<br>
更新下一个任务单元，同时判断是否还有空闲时间；<br>
跳出循环之后将任务添加到下一次空闲操作中。
react 目前是使用自己实现的调度算法，这里使用 <code>requestIdleCallback</code> 这个浏览器提供的 API 实现。</p>
<div><pre><code><span>let</span> nextUnitOfWork <span>=</span> <span>null</span>

<span>// 一旦浏览器空闲，就触发执行单元任务</span>
<span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>

<span>function</span> <span>workLoop</span><span>(</span><span>deadline</span><span>)</span> <span>{</span>
  <span>let</span> shouldYield <span>=</span> <span>false</span><span>;</span>
  <span>while</span> <span>(</span>nextUnitOfWork <span>&amp;&amp;</span> <span>!</span>shouldYield<span>)</span> <span>{</span>
    nextUnitOfWork <span>=</span> <span>performUnitOfWork</span><span>(</span>nextUnitOfWork<span>)</span>
    shouldYield <span>=</span> deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span>
  <span>}</span>
  <span>requestIdleCallback</span><span>(</span>workLoop<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="如何处理一个-fiber"> 如何处理一个 fiber</h2>
<p><img src="/code/images/fiber.png" alt="fiber" /></p>
<ol>
<li>创建对应的 dom</li>
<li>将自身的 dom 插入到父 dom 上</li>
<li>为 children 创建 fiber
<ol>
<li>为每一个 child 创建 parent 指向当前 fiber</li>
<li>创建当前 fiber 到第一个 child 的指向</li>
<li>为相邻的 child 创建前一个到后一个的 sibling 指向</li>
</ol>
</li>
<li>找到下一个任务单元返回
<ol>
<li>当前 fiber 有 child 返回它</li>
<li>当前 fiber 有 sibling 返回它</li>
<li>没有 child 也没有 sibling，那就回到 4.2 找 parent 的 sibling</li>
</ol>
</li>
</ol>
<div><pre><code><span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    fiber<span>.</span>dom <span>=</span> <span>createDom</span><span>(</span>fiber<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>fiber<span>.</span>parent<span>)</span> <span>{</span>
    fiber<span>.</span>parent<span>.</span>dom<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span>
  <span>}</span>
  <span>// 为每个子元素创建新的 fiber</span>
  <span>const</span> elements <span>=</span> fiber<span>.</span>props<span>.</span>children
  <span>let</span> index <span>=</span> <span>0</span>
  <span>let</span> prevSibling <span>=</span> <span>null</span>
  <span>while</span> <span>(</span>index <span>&lt;</span> elements<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> element <span>=</span> elements<span>[</span>index<span>]</span>
    <span>const</span> newFiber <span>=</span> <span>{</span>
      type<span>:</span> element<span>.</span>type<span>,</span>
      props<span>:</span> element<span>.</span>props<span>,</span>
      parent<span>:</span> fiber<span>,</span>
      dom<span>:</span> <span>null</span>
    <span>}</span><span>;</span>
    <span>// 根据上面的图示，父节点只链接第一个子节点</span>
    <span>if</span> <span>(</span>index <span>===</span> <span>0</span><span>)</span> <span>{</span>
      fiber<span>.</span>child <span>=</span> newFiber
    <span>}</span> <span>else</span> <span>{</span>
      <span>// 兄节点链接弟节点</span>
      prevSibling<span>.</span>sibling <span>=</span> newFiber
    <span>}</span>
    prevSibling <span>=</span> newFiber
    index<span>++</span>
  <span>}</span>
  <span>// 返回下一个任务单元（fiber）</span>
  <span>// 有子节点直接返回</span>
  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>return</span> fiber<span>.</span>child
  <span>}</span>
  <span>// 没有子节点则找兄弟节点，兄弟节点也没有找父节点的兄弟节点，</span>
  <span>// 循环遍历直至找到为止</span>
  <span>let</span> nextFiber <span>=</span> fiber
  <span>while</span> <span>(</span>nextFiber<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextFiber<span>.</span>sibling<span>)</span> <span>{</span>
      <span>return</span> nextFiber<span>.</span>sibling
    <span>}</span>
    nextFiber <span>=</span> nextFiber<span>.</span>parent
  <span>}</span>
  <span>return</span> <span>null</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="整体一览"> 整体一览</h2>
<div><pre><code><span>let</span> nextUnitOfWork <span>=</span> <span>null</span>

<span>// 一旦浏览器空闲，就触发执行单元任务</span>
<span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>

<span>function</span> <span>createDom</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>const</span> dom <span>=</span> fiber<span>.</span>type <span>===</span> <span>'TEXT_ELEMENT'</span>
      <span>?</span> document<span>.</span><span>createTextNode</span><span>(</span><span>''</span><span>)</span>
      <span>:</span> document<span>.</span><span>createElement</span><span>(</span>fiber<span>.</span>type<span>)</span>
  <span>const</span> <span>isProperty</span> <span>=</span> <span>key</span> <span>=></span> key <span>!==</span> <span>'children'</span>
  Object<span>.</span><span>keys</span><span>(</span>fiber<span>.</span>props<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isProperty<span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      dom<span>[</span>name<span>]</span> <span>=</span> fiber<span>.</span>props<span>[</span>name<span>]</span><span>;</span>
    <span>}</span><span>)</span>
  <span>return</span> dom
<span>}</span>

<span>// render 设置 nextUnitOfWork 为根的 fiber</span>
<span>export</span> <span>function</span> <span>render</span><span>(</span><span>element<span>,</span> container</span><span>)</span> <span>{</span>
  nextUnitOfWork <span>=</span> <span>{</span>
    dom<span>:</span> container<span>,</span>
    props<span>:</span> <span>{</span>
      children<span>:</span> <span>[</span>element<span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>workLoop</span><span>(</span><span>deadline</span><span>)</span> <span>{</span>
  <span>let</span> shouldYield <span>=</span> <span>false</span><span>;</span>
  <span>while</span> <span>(</span>nextUnitOfWork <span>&amp;&amp;</span> <span>!</span>shouldYield<span>)</span> <span>{</span>
    nextUnitOfWork <span>=</span> <span>performUnitOfWork</span><span>(</span>nextUnitOfWork<span>)</span>
    shouldYield <span>=</span> deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span>
  <span>}</span>
  <span>requestIdleCallback</span><span>(</span>workLoop<span>)</span>
<span>}</span>

<span>// 处理一个 fiber</span>
<span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    fiber<span>.</span>dom <span>=</span> <span>createDom</span><span>(</span>fiber<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span>fiber<span>.</span>parent<span>)</span> <span>{</span>
    fiber<span>.</span>parent<span>.</span>dom<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span>
  <span>}</span>
  <span>// 为每个子元素创建新的 fiber</span>
  <span>const</span> elements <span>=</span> fiber<span>.</span>props<span>.</span>children
  <span>let</span> index <span>=</span> <span>0</span>
  <span>let</span> prevSibling <span>=</span> <span>null</span>
  <span>while</span> <span>(</span>index <span>&lt;</span> elements<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> element <span>=</span> elements<span>[</span>index<span>]</span>
    <span>const</span> newFiber <span>=</span> <span>{</span>
      type<span>:</span> element<span>.</span>type<span>,</span>
      props<span>:</span> element<span>.</span>props<span>,</span>
      parent<span>:</span> fiber<span>,</span>
      dom<span>:</span> <span>null</span>
    <span>}</span><span>;</span>
    <span>// 根据上面的图示，父节点只链接第一个子节点</span>
    <span>if</span> <span>(</span>index <span>===</span> <span>0</span><span>)</span> <span>{</span>
      fiber<span>.</span>child <span>=</span> newFiber
    <span>}</span> <span>else</span> <span>{</span>
      <span>// 兄节点链接弟节点</span>
      prevSibling<span>.</span>sibling <span>=</span> newFiber
    <span>}</span>
    prevSibling <span>=</span> newFiber
    index<span>++</span>
  <span>}</span>
  <span>// 返回下一个任务单元（fiber）</span>
  <span>// 有子节点直接返回</span>
  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>return</span> fiber<span>.</span>child
  <span>}</span>
  <span>// 没有子节点则找兄弟节点，兄弟节点也没有找父节点的兄弟节点，</span>
  <span>// 循环遍历直至找到为止</span>
  <span>let</span> nextFiber <span>=</span> fiber
  <span>while</span> <span>(</span>nextFiber<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextFiber<span>.</span>sibling<span>)</span> <span>{</span>
      <span>return</span> nextFiber<span>.</span>sibling
    <span>}</span>
    nextFiber <span>=</span> nextFiber<span>.</span>parent
  <span>}</span>
  <span>return</span> <span>null</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br></div></div><div><p>问题</p>
<p>目前虽然实现的中断遍历过程，但是中断之后可能会造成页面只渲染一部分的情况...</p>
</div>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">函数组件</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/functionComponent/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/functionComponent/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="函数组件是怎样转化的"> 函数组件是怎样转化的？</h2>
<div><pre><code><span>/** @jsx Redact.createElement */</span>
<span>function</span> <span>App</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>h1</span><span>></span></span><span>Hi </span><span>{</span>props<span>.</span>name<span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>;</span>
<span>}</span><span>;</span>
<span>// 等效 JS 代码 👇</span>
<span>function</span> <span>App</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> Redact<span>.</span><span>createElement</span><span>(</span>
    <span>"h1"</span><span>,</span>
    <span>null</span><span>,</span>
    <span>"Hi "</span><span>,</span>
    props<span>.</span>name
  <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><p>函数组件与普通`jsx`的不同点</p>
<ol>
<li>函数组件的 fiber 节点没有对应 DOM</li>
<li>函数组件的 children 来自函数执行结果，而不是像标签元素一样直接从 props 获取，因为 children 不只是函数组件使用时包含的子孙节点，还需要组合组件本身的结构</li>
</ol>
</div>
<h2 id="实现一览"> 实现一览</h2>
<blockquote>
<p>注意以下代码省略了未改动部分</p>
</blockquote>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>function</span> <span>commitWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>// 当 fiber 是函数组件时节点不存在 DOM，</span>
  <span>// 故需要遍历父节点以找到最近的有 DOM 的节点</span>
  <span>let</span> domParentFiber <span>=</span> fiber<span>.</span>parent<span>;</span>
  <span>while</span> <span>(</span><span>!</span>domParentFiber<span>.</span>dom<span>)</span> <span>{</span>
    domParentFiber <span>=</span> domParentFiber<span>.</span>parent<span>;</span>
  <span>}</span>
  <span>const</span> domParent <span>=</span> domParentFiber<span>.</span>dom<span>;</span>
  <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"PLACEMENT"</span> <span>&amp;&amp;</span> fiber<span>.</span>dom <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    domParent<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"UPDATE"</span> <span>&amp;&amp;</span> fiber<span>.</span>dom <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>updateDom</span><span>(</span>fiber<span>.</span>dom<span>,</span> fiber<span>.</span>alternate<span>.</span>props<span>,</span> fiber<span>.</span>props<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"DELETION"</span><span>)</span> <span>{</span>
    <span>// 直接移除 DOM 替换成 commitDeletion 函数</span>
    <span>commitDeletion</span><span>(</span>fiber<span>,</span> domParent<span>)</span><span>;</span>
  <span>}</span>

  <span>commitWork</span><span>(</span>fiber<span>.</span>child<span>)</span><span>;</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>sibling<span>)</span><span>;</span>
<span>}</span>

<span>// 新增函数，移除 DOM 节点</span>
<span>function</span> <span>commitDeletion</span><span>(</span><span>fiber<span>,</span> domParent</span><span>)</span> <span>{</span>
  <span>// 当 child 是函数组件时不存在 DOM，</span>
  <span>// 故需要递归遍历子节点找到真正的 DOM</span>
  <span>if</span> <span>(</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    domParent<span>.</span><span>removeChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>commitDeletion</span><span>(</span>fiber<span>.</span>child<span>,</span> domParent<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>const</span> isFunctionComponent <span>=</span> fiber<span>.</span>type <span>instanceof</span> <span>Function</span><span>;</span>
  <span>// 原本逻辑挪到 updateHostComponent 函数</span>
  <span>if</span> <span>(</span>isFunctionComponent<span>)</span> <span>{</span>
    <span>updateFunctionComponent</span><span>(</span>fiber<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>updateHostComponent</span><span>(</span>fiber<span>)</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>return</span> fiber<span>.</span>child<span>;</span>
  <span>}</span>
  <span>let</span> nextFiber <span>=</span> fiber<span>;</span>
  <span>while</span> <span>(</span>nextFiber<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextFiber<span>.</span>sibling<span>)</span> <span>{</span>
      <span>return</span> nextFiber<span>.</span>sibling<span>;</span>
    <span>}</span>
    nextFiber <span>=</span> nextFiber<span>.</span>parent<span>;</span>
  <span>}</span>
<span>}</span>

<span>// 新增函数，处理函数组件</span>
<span>function</span> <span>updateFunctionComponent</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>// 执行函数组件得到 children</span>
  <span>const</span> children <span>=</span> <span>[</span>fiber<span>.</span><span>type</span><span>(</span>fiber<span>.</span>props<span>)</span><span>]</span><span>;</span>
  <span>reconcileChildren</span><span>(</span>fiber<span>,</span> children<span>)</span><span>;</span>
<span>}</span>

<span>// 新增函数，处理原生标签组件</span>
<span>function</span> <span>updateHostComponent</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    fiber<span>.</span>dom <span>=</span> <span>createDom</span><span>(</span>fiber<span>)</span><span>;</span>
  <span>}</span>
  <span>reconcileChildren</span><span>(</span>fiber<span>,</span> fiber<span>.</span>props<span>.</span>children<span>)</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">createElement &amp;&amp; render</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="createelement"> createElement</h2>
<p>将 <code>babel</code> 解析过后的参数处理成一个虚拟 <code>dom</code></p>
<div><pre><code><span>export</span> <span>function</span> <span>createElement</span><span>(</span><span>type<span>,</span> props<span>,</span> <span>...</span>children</span><span>)</span> <span>{</span>
  <span>return</span> <span>{</span>
    type<span>,</span>
    props<span>:</span> <span>{</span>
      <span>...</span>props<span>,</span>
      children<span>:</span> children<span>.</span><span>map</span><span>(</span><span>child</span> <span>=></span> <span>typeof</span> child <span>===</span> <span>'object'</span> <span>?</span> child <span>:</span> <span>createTextElement</span><span>(</span>child<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><details><summary>createTextElement的实现</summary>
<div><pre><code><span>function</span> <span>createTextElement</span><span>(</span><span>text</span><span>)</span> <span>{</span>
  <span>return</span> <span>{</span>
    type<span>:</span> <span>'TEXT_ELEMENT'</span><span>,</span>
    props<span>:</span> <span>{</span>
      nodeValue<span>:</span> text<span>,</span>
      children<span>:</span> <span>[</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></details>
<h2 id="render"> render</h2>
<div><pre><code><span>export</span> <span>function</span> <span>render</span><span>(</span><span>element<span>,</span> container</span><span>)</span> <span>{</span>
  <span>// 创建节点</span>
  <span>const</span> dom <span>=</span> element<span>.</span>type <span>===</span> <span>'TEXT_ELEMENT'</span>
    <span>?</span> document<span>.</span><span>createTextNode</span><span>(</span><span>''</span><span>)</span>
    <span>:</span> document<span>.</span><span>createElement</span><span>(</span>element<span>.</span>type<span>)</span>
  <span>const</span> <span>isProperty</span> <span>=</span> <span>key</span> <span>=></span> key <span>!==</span> <span>'children'</span>
  Object<span>.</span><span>keys</span><span>(</span>element<span>.</span>props<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isProperty<span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      dom<span>[</span>name<span>]</span> <span>=</span> element<span>.</span>props<span>[</span>name<span>]</span>
    <span>}</span><span>)</span>
  <span>// 递归遍历子节点</span>
  element<span>.</span>props<span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> <span>render</span><span>(</span>child<span>,</span> dom<span>)</span><span>)</span>
  container<span>.</span><span>appendChild</span><span>(</span>dom<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">reconciliation</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/reconciliation/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/reconciliation/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>目前我们只添加节点到 DOM，还没考虑更新和删除节点的情况。要处理这2种情况，需要对比上次渲染的 fiber 和当前渲染的 fiber 的差异，根据差异决定是更新还是删除节点。React 把这个过程叫 <code>Reconciliation</code>。</p>
</blockquote>
<h2 id="概览"> 概览</h2>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>createDom</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>const</span> dom <span>=</span>
    fiber<span>.</span>type <span>===</span> <span>"TEXT_ELEMENT"</span>
      <span>?</span> document<span>.</span><span>createTextNode</span><span>(</span><span>""</span><span>)</span>
      <span>:</span> document<span>.</span><span>createElement</span><span>(</span>fiber<span>.</span>type<span>)</span><span>;</span>

  <span>updateDom</span><span>(</span>dom<span>,</span> <span>{</span><span>}</span><span>,</span> fiber<span>.</span>props<span>)</span><span>;</span>

  <span>return</span> dom<span>;</span>
<span>}</span>

<span>const</span> <span>isEvent</span> <span>=</span> <span>key</span> <span>=></span> key<span>.</span><span>startsWith</span><span>(</span><span>"on"</span><span>)</span><span>;</span>
<span>const</span> <span>isProperty</span> <span>=</span> <span>key</span> <span>=></span> key <span>!==</span> <span>"children"</span> <span>&amp;&amp;</span> <span>!</span><span>isEvent</span><span>(</span>key<span>)</span><span>;</span>
<span>const</span> <span>isNew</span> <span>=</span> <span>(</span><span>prev<span>,</span> next</span><span>)</span> <span>=></span> <span>key</span> <span>=></span> prev<span>[</span>key<span>]</span> <span>!==</span> next<span>[</span>key<span>]</span><span>;</span>
<span>const</span> <span>isGone</span> <span>=</span> <span>(</span><span>prev<span>,</span> next</span><span>)</span> <span>=></span> <span>key</span> <span>=></span> <span>!</span><span>(</span>key <span>in</span> next<span>)</span><span>;</span>

<span>// 新增函数，更新 DOM 节点属性</span>
<span>function</span> <span>updateDom</span><span>(</span><span>dom<span>,</span> prevProps <span>=</span> <span>{</span><span>}</span><span>,</span> nextProps <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
  <span>// 以 “on” 开头的属性作为事件要特别处理</span>
  <span>// 移除旧的或者变化了的的事件处理函数</span>
  Object<span>.</span><span>keys</span><span>(</span>prevProps<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isEvent<span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>key</span> <span>=></span> <span>!</span><span>(</span>key <span>in</span> nextProps<span>)</span> <span>||</span> <span>isNew</span><span>(</span>prevProps<span>,</span> nextProps<span>)</span><span>(</span>key<span>)</span><span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      <span>const</span> eventType <span>=</span> name<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>.</span><span>substring</span><span>(</span><span>2</span><span>)</span><span>;</span>
      dom<span>.</span><span>removeEventListener</span><span>(</span>eventType<span>,</span> prevProps<span>[</span>name<span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

  <span>// 移除旧的属性</span>
  Object<span>.</span><span>keys</span><span>(</span>prevProps<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isProperty<span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>isGone</span><span>(</span>prevProps<span>,</span> nextProps<span>)</span><span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      dom<span>[</span>name<span>]</span> <span>=</span> <span>""</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

  <span>// 添加或者更新属性</span>
  Object<span>.</span><span>keys</span><span>(</span>nextProps<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isProperty<span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>isNew</span><span>(</span>prevProps<span>,</span> nextProps<span>)</span><span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      <span>// React 规定 style 内联样式是驼峰命名的对象，</span>
      <span>// 根据规范给 style 每个属性单独赋值</span>
      <span>if</span> <span>(</span>name <span>===</span> <span>"style"</span><span>)</span> <span>{</span>
        Object<span>.</span><span>entries</span><span>(</span>nextProps<span>[</span>name<span>]</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>[</span>key<span>,</span> value<span>]</span></span><span>)</span> <span>=></span> <span>{</span>
          dom<span>.</span>style<span>[</span>key<span>]</span> <span>=</span> value<span>;</span>
        <span>}</span><span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        dom<span>[</span>name<span>]</span> <span>=</span> nextProps<span>[</span>name<span>]</span><span>;</span>
      <span>}</span>
    <span>}</span><span>)</span><span>;</span>

  <span>// 添加新的事件处理函数</span>
  Object<span>.</span><span>keys</span><span>(</span>nextProps<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isEvent<span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>isNew</span><span>(</span>prevProps<span>,</span> nextProps<span>)</span><span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      <span>const</span> eventType <span>=</span> name<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>.</span><span>substring</span><span>(</span><span>2</span><span>)</span><span>;</span>
      dom<span>.</span><span>addEventListener</span><span>(</span>eventType<span>,</span> nextProps<span>[</span>name<span>]</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>commitRoot</span><span>(</span><span>)</span> <span>{</span>
  deletions<span>.</span><span>forEach</span><span>(</span>commitWork<span>)</span><span>;</span>
  <span>commitWork</span><span>(</span>wipRoot<span>.</span>child<span>)</span><span>;</span>
  currentRoot <span>=</span> wipRoot<span>;</span>
  wipRoot <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>function</span> <span>commitWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>const</span> domParent <span>=</span> fiber<span>.</span>parent<span>.</span>dom<span>;</span>
  <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"PLACEMENT"</span> <span>&amp;&amp;</span> fiber<span>.</span>dom <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    domParent<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"UPDATE"</span> <span>&amp;&amp;</span> fiber<span>.</span>dom <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>updateDom</span><span>(</span>fiber<span>.</span>dom<span>,</span> fiber<span>.</span>alternate<span>.</span>props<span>,</span> fiber<span>.</span>props<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>fiber<span>.</span>effectTag <span>===</span> <span>"DELETION"</span><span>)</span> <span>{</span>
    domParent<span>.</span><span>removeChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>}</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>child<span>)</span><span>;</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>sibling<span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>render</span><span>(</span><span>element<span>,</span> container</span><span>)</span> <span>{</span>
  wipRoot <span>=</span> <span>{</span>
    dom<span>:</span> container<span>,</span>
    props<span>:</span> <span>{</span>
      children<span>:</span> <span>[</span>element<span>]</span>
    <span>}</span><span>,</span>
    alternate<span>:</span> currentRoot
  <span>}</span><span>;</span>
  deletions <span>=</span> <span>[</span><span>]</span><span>;</span>
  nextUnitOfWork <span>=</span> wipRoot<span>;</span>
<span>}</span>

<span>let</span> nextUnitOfWork <span>=</span> <span>null</span><span>;</span>
<span>let</span> currentRoot <span>=</span> <span>null</span><span>;</span>
<span>let</span> wipRoot <span>=</span> <span>null</span><span>;</span>
<span>let</span> deletions <span>=</span> <span>null</span><span>;</span>

<span>function</span> <span>workLoop</span><span>(</span><span>deadline</span><span>)</span> <span>{</span>
  <span>let</span> shouldYield <span>=</span> <span>false</span><span>;</span>
  <span>while</span> <span>(</span>nextUnitOfWork <span>&amp;&amp;</span> <span>!</span>shouldYield<span>)</span> <span>{</span>
    nextUnitOfWork <span>=</span> <span>performUnitOfWork</span><span>(</span>nextUnitOfWork<span>)</span><span>;</span>
    shouldYield <span>=</span> deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>;</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>!</span>nextUnitOfWork <span>&amp;&amp;</span> wipRoot<span>)</span> <span>{</span>
    <span>commitRoot</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>
<span>}</span>

<span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>

<span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    fiber<span>.</span>dom <span>=</span> <span>createDom</span><span>(</span>fiber<span>)</span><span>;</span>
  <span>}</span>

  <span>const</span> elements <span>=</span> fiber<span>.</span>props<span>.</span>children<span>;</span>
  <span>// 原本添加 fiber 的逻辑挪到 reconcileChildren 函数</span>
  <span>reconcileChildren</span><span>(</span>fiber<span>,</span> elements<span>)</span><span>;</span>

  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>return</span> fiber<span>.</span>child<span>;</span>
  <span>}</span>
  <span>let</span> nextFiber <span>=</span> fiber<span>;</span>
  <span>while</span> <span>(</span>nextFiber<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextFiber<span>.</span>sibling<span>)</span> <span>{</span>
      <span>return</span> nextFiber<span>.</span>sibling<span>;</span>
    <span>}</span>
    nextFiber <span>=</span> nextFiber<span>.</span>parent<span>;</span>
  <span>}</span>
<span>}</span>

<span>// 新增函数</span>
<span>function</span> <span>reconcileChildren</span><span>(</span><span>wipFiber<span>,</span> elements</span><span>)</span> <span>{</span>
  <span>let</span> index <span>=</span> <span>0</span><span>;</span>
  <span>// 上次渲染完成之后的 fiber 节点</span>
  <span>let</span> oldFiber <span>=</span> wipFiber<span>.</span>alternate <span>&amp;&amp;</span> wipFiber<span>.</span>alternate<span>.</span>child<span>;</span>
  <span>let</span> prevSibling <span>=</span> <span>null</span><span>;</span>

  <span>// 扁平化 props.children，处理函数组件的 children</span>
  elements <span>=</span> elements<span>.</span><span>flat</span><span>(</span><span>)</span><span>;</span>

  <span>while</span> <span>(</span>index <span>&lt;</span> elements<span>.</span>length <span>||</span> oldFiber <span>!=</span> <span>null</span><span>)</span> <span>{</span>
    <span>// 本次需要渲染的子元素</span>
    <span>const</span> element <span>=</span> elements<span>[</span>index<span>]</span><span>;</span>
    <span>let</span> newFiber <span>=</span> <span>null</span><span>;</span>

    <span>// 比较当前和上一次渲染的 type，即 DOM tag 'div'，</span>
    <span>// 暂不考虑自定义组件</span>
    <span>const</span> sameType <span>=</span> oldFiber <span>&amp;&amp;</span> element <span>&amp;&amp;</span> element<span>.</span>type <span>===</span> oldFiber<span>.</span>type<span>;</span>

    <span>// 同类型节点，只需更新节点 props 即可</span>
    <span>if</span> <span>(</span>sameType<span>)</span> <span>{</span>
      newFiber <span>=</span> <span>{</span>
        type<span>:</span> oldFiber<span>.</span>type<span>,</span>
        props<span>:</span> element<span>.</span>props<span>,</span>
        dom<span>:</span> oldFiber<span>.</span>dom<span>,</span> <span>// 复用旧节点的 DOM</span>
        parent<span>:</span> wipFiber<span>,</span>
        alternate<span>:</span> oldFiber<span>,</span>
        effectTag<span>:</span> <span>"UPDATE"</span> <span>// 新增属性，在提交/commit 阶段使用</span>
      <span>}</span><span>;</span>
    <span>}</span>
    <span>// 不同类型节点且存在新的元素时，创建新的 DOM 节点</span>
    <span>if</span> <span>(</span>element <span>&amp;&amp;</span> <span>!</span>sameType<span>)</span> <span>{</span>
      newFiber <span>=</span> <span>{</span>
        type<span>:</span> element<span>.</span>type<span>,</span>
        props<span>:</span> element<span>.</span>props<span>,</span>
        dom<span>:</span> <span>null</span><span>,</span>
        parent<span>:</span> wipFiber<span>,</span>
        alternate<span>:</span> <span>null</span><span>,</span>
        effectTag<span>:</span> <span>"PLACEMENT"</span> <span>// PLACEMENT 表示需要添加新的节点</span>
      <span>}</span><span>;</span>
    <span>}</span>
    <span>// 不同类型节点，且存在旧的 fiber 节点时，</span>
    <span>// 需要移除该节点</span>
    <span>if</span> <span>(</span>oldFiber <span>&amp;&amp;</span> <span>!</span>sameType<span>)</span> <span>{</span>
      oldFiber<span>.</span>effectTag <span>=</span> <span>"DELETION"</span><span>;</span>
      <span>// 当最后提交 fiber 树到 DOM 时，我们是从 wipRoot 开始的，</span>
      <span>// 此时没有上一次的 fiber，所以这里用一个数组来跟踪需要</span>
      <span>// 删除的节点</span>
      deletions<span>.</span><span>push</span><span>(</span>oldFiber<span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>oldFiber<span>)</span> <span>{</span>
      <span>// 同步更新下一个旧 fiber 节点</span>
      oldFiber <span>=</span> oldFiber<span>.</span>sibling<span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>index <span>===</span> <span>0</span><span>)</span> <span>{</span>
      wipFiber<span>.</span>child <span>=</span> newFiber<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      prevSibling<span>.</span>sibling <span>=</span> newFiber<span>;</span>
    <span>}</span>

    prevSibling <span>=</span> newFiber<span>;</span>
    index<span>++</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">render &amp; commit</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/render&amp;commit/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/render&amp;commit/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="render"> render</h2>
<div><div><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>function</span> <span>render</span><span>(</span><span>element<span>,</span> container</span><span>)</span> <span>{</span>
  <span>// render 时记录 wipRoot</span>
  wipRoot <span>=</span> <span>{</span>
    dom<span>:</span> container<span>,</span>
    props<span>:</span> <span>{</span>
      children<span>:</span> <span>[</span>element<span>]</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>;</span>
  nextUnitOfWork <span>=</span> wipRoot
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="何时做一次整体提交"> 何时做一次整体提交</h2>
<div><div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>function</span> <span>workLoop</span><span>(</span><span>deadline</span><span>)</span> <span>{</span>
  <span>let</span> shouldYield <span>=</span> <span>false</span>
  <span>while</span> <span>(</span>nextUnitOfWork <span>&amp;&amp;</span> <span>!</span>shouldYield<span>)</span> <span>{</span>
    nextUnitOfWork <span>=</span> <span>performUnitOfWork</span><span>(</span>
      nextUnitOfWork
    <span>)</span><span>;</span>
    shouldYield <span>=</span> deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span>
  <span>}</span>
  <span>// 当 nextUnitOfWork 为空则表示渲染 fiber 树完成了，</span>
  <span>// 可以提交到 DOM 了</span>
  <span>if</span> <span>(</span><span>!</span>nextUnitOfWork <span>&amp;&amp;</span> wipRoot<span>)</span> <span>{</span>
    <span>commitRoot</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
  <span>requestIdleCallback</span><span>(</span>workLoop<span>)</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="commit"> commit</h2>
<div><div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br></div><pre><code><span>function</span> <span>commitRoot</span><span>(</span><span>)</span> <span>{</span>
  <span>commitWork</span><span>(</span>wipRoot<span>.</span>child<span>)</span><span>;</span>
  wipRoot <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>function</span> <span>commitWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>const</span> domParent <span>=</span> fiber<span>.</span>parent<span>.</span>dom<span>;</span>
  domParent<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>// 递归子节点和兄弟节点</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>child<span>)</span><span>;</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>sibling<span>)</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="整体一览"> 整体一览</h2>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>createDom</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>const</span> dom <span>=</span>
    fiber<span>.</span>type <span>==</span> <span>"TEXT_ELEMENT"</span>
      <span>?</span> document<span>.</span><span>createTextNode</span><span>(</span><span>""</span><span>)</span>
      <span>:</span> document<span>.</span><span>createElement</span><span>(</span>fiber<span>.</span>type<span>)</span><span>;</span>
​
  <span>const</span> <span>isProperty</span> <span>=</span> <span>key</span> <span>=></span> key <span>!==</span> <span>"children"</span><span>;</span>
  Object<span>.</span><span>keys</span><span>(</span>fiber<span>.</span>props<span>)</span>
    <span>.</span><span>filter</span><span>(</span>isProperty<span>)</span>
    <span>.</span><span>forEach</span><span>(</span><span>name</span> <span>=></span> <span>{</span>
      dom<span>[</span>name<span>]</span> <span>=</span> fiber<span>.</span>props<span>[</span>name<span>]</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
​
  <span>return</span> dom<span>;</span>
<span>}</span>

<span>// 新增函数，提交根结点到 DOM</span>
<span>function</span> <span>commitRoot</span><span>(</span><span>)</span> <span>{</span>
  <span>commitWork</span><span>(</span>wipRoot<span>.</span>child<span>)</span><span>;</span>
  wipRoot <span>=</span> <span>null</span><span>;</span>
<span>}</span>
​
<span>// 新增子函数</span>
<span>function</span> <span>commitWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  <span>const</span> domParent <span>=</span> fiber<span>.</span>parent<span>.</span>dom<span>;</span>
  domParent<span>.</span><span>appendChild</span><span>(</span>fiber<span>.</span>dom<span>)</span><span>;</span>
  <span>// 递归子节点和兄弟节点</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>child<span>)</span><span>;</span>
  <span>commitWork</span><span>(</span>fiber<span>.</span>sibling<span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>render</span><span>(</span><span>element<span>,</span> container</span><span>)</span> <span>{</span>
  <span>// render 时记录 wipRoot</span>
  wipRoot <span>=</span> <span>{</span>
    dom<span>:</span> container<span>,</span>
    props<span>:</span> <span>{</span>
      children<span>:</span> <span>[</span>element<span>]</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>;</span>
  nextUnitOfWork <span>=</span> wipRoot<span>;</span>
<span>}</span>
​
<span>let</span> nextUnitOfWork <span>=</span> <span>null</span><span>;</span>
<span>// 新增变量，跟踪渲染进行中的根 fiber</span>
<span>let</span> wipRoot <span>=</span> <span>null</span><span>;</span>

<span>function</span> <span>workLoop</span><span>(</span><span>deadline</span><span>)</span> <span>{</span>
  <span>let</span> shouldYield <span>=</span> <span>false</span><span>;</span>
  <span>while</span> <span>(</span>nextUnitOfWork <span>&amp;&amp;</span> <span>!</span>shouldYield<span>)</span> <span>{</span>
    nextUnitOfWork <span>=</span> <span>performUnitOfWork</span><span>(</span>
      nextUnitOfWork
    <span>)</span><span>;</span>
    shouldYield <span>=</span> deadline<span>.</span><span>timeRemaining</span><span>(</span><span>)</span> <span>&lt;</span> <span>1</span><span>;</span>
  <span>}</span>

  <span>// 当 nextUnitOfWork 为空则表示渲染 fiber 树完成了，</span>
  <span>// 可以提交到 DOM 了</span>
  <span>if</span> <span>(</span><span>!</span>nextUnitOfWork <span>&amp;&amp;</span> wipRoot<span>)</span> <span>{</span>
    <span>commitRoot</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
  <span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>
<span>}</span>

​<span>// 一旦浏览器空闲，就触发执行单元任务</span>
<span>requestIdleCallback</span><span>(</span>workLoop<span>)</span><span>;</span>

<span>function</span> <span>performUnitOfWork</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>fiber<span>.</span>dom<span>)</span> <span>{</span>
    fiber<span>.</span>dom <span>=</span> <span>createDom</span><span>(</span>fiber<span>)</span><span>;</span>
  <span>}</span>

  <span>const</span> elements <span>=</span> fiber<span>.</span>props<span>.</span>children<span>;</span>
  <span>let</span> index <span>=</span> <span>0</span><span>;</span>
  <span>let</span> prevSibling <span>=</span> <span>null</span><span>;</span>
​
  <span>while</span> <span>(</span>index <span>&lt;</span> elements<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> element <span>=</span> elements<span>[</span>index<span>]</span><span>;</span>
​
    <span>const</span> newFiber <span>=</span> <span>{</span>
      type<span>:</span> element<span>.</span>type<span>,</span>
      props<span>:</span> element<span>.</span>props<span>,</span>
      parent<span>:</span> fiber<span>,</span>
      dom<span>:</span> <span>null</span><span>,</span>
    <span>}</span><span>;</span>

    <span>if</span> <span>(</span>index <span>===</span> <span>0</span><span>)</span> <span>{</span>
      fiber<span>.</span>child <span>=</span> newFiber<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      prevSibling<span>.</span>sibling <span>=</span> newFiber<span>;</span>
    <span>}</span>
​
    prevSibling <span>=</span> newFiber<span>;</span>
    index<span>++</span><span>;</span>
  <span>}</span>

  <span>if</span> <span>(</span>fiber<span>.</span>child<span>)</span> <span>{</span>
    <span>return</span> fiber<span>.</span>child<span>;</span>
  <span>}</span>

  <span>let</span> nextFiber <span>=</span> fiber<span>;</span>
  <span>while</span> <span>(</span>nextFiber<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextFiber<span>.</span>sibling<span>)</span> <span>{</span>
      <span>return</span> nextFiber<span>.</span>sibling<span>;</span>
    <span>}</span>
    nextFiber <span>=</span> nextFiber<span>.</span>parent<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">useState</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-react/useState/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-react/useState/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注意以下代码省略了未变化部分</p>
</blockquote>
<div><pre><code><span>// 新增变量，渲染进行中的 fiber 节点</span>
<span>let</span> wipFiber <span>=</span> <span>null</span><span>;</span>
<span>// 新增变量，当前 hook 的索引，以支持同一个函数组件多次调用 useState</span>
<span>let</span> hookIndex <span>=</span> <span>null</span><span>;</span>

<span>function</span> <span>updateFunctionComponent</span><span>(</span><span>fiber</span><span>)</span> <span>{</span>
  <span>// 更新进行中的 fiber 节点</span>
  wipFiber <span>=</span> fiber<span>;</span>
  <span>// 重置 hook 索引</span>
  hookIndex <span>=</span> <span>0</span><span>;</span>
  <span>// 新增 hooks 数组以支持同一个组件多次调用 useState</span>
  wipFiber<span>.</span>hooks <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>const</span> children <span>=</span> <span>[</span>fiber<span>.</span><span>type</span><span>(</span>fiber<span>.</span>props<span>)</span><span>]</span><span>;</span>
  <span>reconcileChildren</span><span>(</span>fiber<span>,</span> children<span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>useState</span><span>(</span><span>initial</span><span>)</span> <span>{</span>
  <span>// alternate 保存了上一次渲染的 fiber 节点</span>
  <span>const</span> oldHook <span>=</span>
    wipFiber<span>.</span>alternate <span>&amp;&amp;</span>
    wipFiber<span>.</span>alternate<span>.</span>hooks <span>&amp;&amp;</span>
    wipFiber<span>.</span>alternate<span>.</span>hooks<span>[</span>hookIndex<span>]</span><span>;</span>
  <span>const</span> hook <span>=</span> <span>{</span>
    <span>// 第一次渲染使用入参，第二次渲染复用前一次的状态</span>
    state<span>:</span> oldHook <span>?</span> oldHook<span>.</span>state <span>:</span> initial<span>,</span>
    <span>// 保存每次 setState 入参的队列</span>
    queue<span>:</span> <span>[</span><span>]</span>
  <span>}</span><span>;</span>

  <span>const</span> actions <span>=</span> oldHook <span>?</span> oldHook<span>.</span>queue <span>:</span> <span>[</span><span>]</span><span>;</span>
  actions<span>.</span><span>forEach</span><span>(</span><span>action</span> <span>=></span> <span>{</span>
    <span>// 根据调用 setState 顺序从前往后生成最新的 state</span>
    hook<span>.</span>state <span>=</span> action <span>instanceof</span> <span>Function</span> <span>?</span> <span>action</span><span>(</span>hook<span>.</span>state<span>)</span> <span>:</span> action<span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>// setState 函数用于更新 state，入参 action</span>
  <span>// 是新的 state 值或函数返回新的 state</span>
  <span>const</span> <span>setState</span> <span>=</span> <span>action</span> <span>=></span> <span>{</span>
    hook<span>.</span>queue<span>.</span><span>push</span><span>(</span>action<span>)</span><span>;</span>
    <span>// 下面这部分代码和 render 函数很像，</span>
    <span>// 设置新的 wipRoot 和 nextUnitOfWork</span>
    <span>// 浏览器空闲时即开始重新渲染。</span>
    wipRoot <span>=</span> <span>{</span>
      dom<span>:</span> currentRoot<span>.</span>dom<span>,</span>
      props<span>:</span> currentRoot<span>.</span>props<span>,</span>
      alternate<span>:</span> currentRoot
    <span>}</span><span>;</span>
    nextUnitOfWork <span>=</span> wipRoot<span>;</span>
    deletions <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>}</span><span>;</span>

  <span>// 保存本次 hook</span>
  wipFiber<span>.</span>hooks<span>.</span><span>push</span><span>(</span>hook<span>)</span><span>;</span>
  hookIndex<span>++</span><span>;</span>
  <span>return</span> <span>[</span>hook<span>.</span>state<span>,</span> setState<span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">redux</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-redux/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-redux/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="createstore"> createStore</h2>
<p>创建 store 核心对象</p>
<div><pre><code><span>const</span> <span>createStore</span> <span>=</span> <span>(</span><span>reducer<span>,</span> initState<span>,</span> enhancer</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>enhancer <span>&amp;&amp;</span> <span>typeof</span> initState <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
    enhancer <span>=</span> initState
    initState <span>=</span> <span>null</span>
  <span>}</span>
  <span>if</span> <span>(</span>enhancer <span>&amp;&amp;</span> <span>typeof</span> enhancer <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
    <span>return</span> <span>enhancer</span><span>(</span>createStore<span>)</span><span>(</span>reducer<span>,</span> initState<span>)</span>
  <span>}</span>
  <span>let</span> store <span>=</span> initState<span>,</span> 
    listeners <span>=</span> <span>[</span><span>]</span><span>,</span>
    isDispatch <span>=</span> <span>false</span><span>;</span>
  <span>const</span> <span>getState</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> store
  <span>// 原始 dispatch 内部执行 reducer 通知监听者</span>
  <span>const</span> <span>dispatch</span> <span>=</span> <span>(</span><span>action</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>isDispatch<span>)</span> <span>return</span> action
    <span>// dispatch 必须一个个来，加锁</span>
    isDispatch <span>=</span> <span>true</span>
    store <span>=</span> <span>reducer</span><span>(</span>store<span>,</span> action<span>)</span>
    isDispatch <span>=</span> <span>false</span>
    listeners<span>.</span><span>forEach</span><span>(</span><span>listener</span> <span>=></span> <span>listener</span><span>(</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>)</span>
    <span>return</span> action
  <span>}</span>
  <span>const</span> <span>subscribe</span> <span>=</span> <span>(</span><span>listener</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>typeof</span> listener <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
      listeners<span>.</span><span>push</span><span>(</span>listener<span>)</span>
    <span>}</span>
    <span>// 在监听的同时返回卸载监听的函数，利用闭包缓存监听者，以免想卸载监听的时候却找不到对应的想卸载的监听者</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>unsubscribe</span><span>(</span>listener<span>)</span>
  <span>}</span>
  <span>const</span> <span>unsubscribe</span> <span>=</span> <span>(</span><span>listener</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> index <span>=</span> listeners<span>.</span><span>indexOf</span><span>(</span>listener<span>)</span>
    listeners<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>{</span>
    getState<span>,</span>
    dispatch<span>,</span>
    subscribe<span>,</span>
    unsubscribe
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h2 id="applymiddleware"> applyMiddleware</h2>
<p>添加中间件</p>
<div><pre><code><span>const</span> <span>applyMiddleware</span> <span>=</span> <span>(</span><span><span>...</span>middlewares</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span><span>createStore</span><span>)</span> <span>=></span> <span>(</span><span>reducer<span>,</span> initState<span>,</span> enhancer</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> store <span>=</span> <span>createStore</span><span>(</span>reducer<span>,</span> initState<span>,</span> enhancer<span>)</span><span>;</span>
    <span>const</span> middlewareAPI <span>=</span> <span>{</span>
      getState<span>:</span> store<span>.</span>getState<span>,</span>
      <span>dispatch</span><span>:</span> <span>(</span><span>action</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span>action<span>)</span>
    <span>}</span>
    <span>// 剥掉中间件的第一层外衣</span>
    <span>let</span> chain <span>=</span> middlewares<span>.</span><span>map</span><span>(</span><span>middleware</span> <span>=></span> <span>middleware</span><span>(</span>middlewareAPI<span>)</span><span>)</span>
    <span>// 剥掉中间件的第二层外衣</span>
    store<span>.</span>dispatch <span>=</span> <span>compose</span><span>(</span><span>...</span>chain<span>)</span><span>(</span>store<span>.</span>dispatch<span>)</span>
    <span>return</span> <span>{</span>
      <span>...</span>store
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="compose"> compose</h3>
<div><pre><code><span>// 将一系列函数串起来，返回一个函数，增强原始 dispatch 的功能</span>
<span>// 中间件是由三阶函数构成，这里参数的函数是剥了最外层的中间件</span>
<span>const</span> <span>compose</span> <span>=</span> <span>(</span><span><span>...</span>funcs</span><span>)</span> <span>=></span> <span>{</span>
  <span>// 没有传入函数则原样返回</span>
  <span>if</span> <span>(</span><span>!</span>funcs<span>)</span> <span>{</span>
    <span>return</span> <span>args</span> <span>=></span> args
  <span>}</span>
  <span>if</span> <span>(</span>funcs<span>.</span>length <span>===</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> funcs<span>[</span><span>0</span><span>]</span>
  <span>}</span>
  <span>return</span> funcs<span>.</span><span>reduce</span><span>(</span><span>(</span><span>f1<span>,</span> f2</span><span>)</span> <span>=></span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>f1</span><span>(</span><span>f2</span><span>(</span><span>...</span>args<span>)</span><span>)</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="combinereducers"> combineReducers</h2>
<div><pre><code><span>// 拿到 reducer 的键，修改 state 对应键的值</span>
<span>const</span> <span>combineReducers</span> <span>=</span> <span>reducers</span> <span>=></span> <span>{</span>
  <span>const</span> finalReducers <span>=</span> <span>{</span><span>}</span><span>,</span>
    nativeKeys <span>=</span> Object<span>.</span>keys
  <span>nativeKeys</span><span>(</span>reducers<span>)</span><span>.</span><span>forEach</span><span>(</span><span>reducerKey</span> <span>=></span> <span>{</span>
    <span>if</span><span>(</span><span>typeof</span> reducers<span>[</span>reducerKey<span>]</span> <span>===</span> <span>"function"</span><span>)</span> <span>{</span>
      finalReducers<span>[</span>reducerKey<span>]</span> <span>=</span> reducers<span>[</span>reducerKey<span>]</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>return</span> <span>(</span><span>state<span>,</span> action</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> store <span>=</span> <span>{</span><span>}</span>
    <span>nativeKeys</span><span>(</span>finalReducers<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
      <span>const</span> reducer <span>=</span> finalReducers<span>[</span>key<span>]</span>
      <span>const</span> nextState <span>=</span> <span>reducer</span><span>(</span>state<span>[</span>key<span>]</span><span>,</span> action<span>)</span>
      store<span>[</span>key<span>]</span> <span>=</span> nextState
    <span>}</span><span>)</span>
    <span>return</span> store
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="bindactioncreator"> bindActionCreator</h2>
<div><pre><code><span>const</span> <span>bindActionCreator</span> <span>=</span> <span>(</span><span>action<span>,</span> dispatch</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>dispatch</span><span>(</span><span>action</span><span>(</span><span>...</span>args<span>)</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">react-redux</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-redux/react-redux/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-redux/react-redux/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用法"> 用法</h2>
<p>看看 react-redux 有两个重要的 API 的用法：</p>
<div><pre><code><span>// Provider</span>
ReactDOM<span>.</span><span>render</span><span>(</span><span>{</span>
  <span><span><span>&lt;</span><span>Provider</span></span> <span>store</span><span><span>=</span><span>{</span>store<span>}</span></span><span>></span></span><span><span><span>&lt;/</span><span>Provider</span></span><span>></span></span><span>,</span>
  document<span>.</span><span>getElementById</span><span>(</span><span>'app'</span><span>)</span>
<span>}</span><span>)</span>

<span>// connect</span>
@<span>connect</span><span>(</span>mapStateToProps<span>,</span> mapDispatchToProps<span>)</span>
<span>class</span> <span>App</span> <span>extends</span> <span>Component</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="provider"> Provider</h2>
<p>传递 store 和 订阅方法给所有组件</p>
<div><pre><code><span>class</span> <span>Subscription</span> <span>{</span>
  <span>constructor</span><span>(</span><span>store</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>store <span>=</span> store
    <span>this</span><span>.</span>listeners <span>=</span> <span>[</span><span>this</span><span>.</span>handleChangeWrapper<span>]</span>
  <span>}</span>
  <span>notify</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>this</span><span>.</span>listeners<span>.</span><span>forEach</span><span>(</span><span>listener</span> <span>=></span> <span>{</span>
      <span>listener</span><span>(</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span>
  <span>addListener</span><span>(</span><span>listener</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>listeners<span>.</span><span>push</span><span>(</span>listener<span>)</span>
  <span>}</span>
  <span>// 监听 store</span>
  <span>trySubscribe</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>unsubscribe <span>=</span> <span>this</span><span>.</span>store<span>.</span><span>subscribe</span><span>(</span><span>this</span><span>.</span>notify<span>)</span>
  <span>}</span>
  <span>// onStateChange 需要在组件中设置</span>
  <span>handleChangeWrapper</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>onStateChange<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>onStateChange</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>unsubscribe</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>listeners <span>=</span> <span>null</span>
    <span>this</span><span>.</span><span>unsubscribe</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>const</span> <span>Provider</span> <span>=</span> <span>(</span><span><span>{</span> store<span>,</span> children <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> contextValue <span>=</span> <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> subscription <span>=</span> <span>new</span> <span>Subscription</span><span>(</span>store<span>)</span>
    <span>return</span> <span>{</span>
      store<span>,</span>
      subscription
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span>store<span>]</span><span>)</span>
  <span>// 监听 store 变化</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> <span>{</span> subscription <span>}</span> <span>=</span> contextValue
    subscription<span>.</span><span>trySubscribe</span><span>(</span><span>)</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      subscription<span>.</span><span>unsubscribe</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span>contextValue<span>]</span><span>)</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>ReactReduxContext<span>.</span>Provider value<span>=</span><span>{</span>contextValue<span>}</span><span>></span>
      <span>{</span>children<span>}</span>
    <span>&lt;</span><span>/</span>ReactReduxContext<span>.</span>Provider<span>></span>
  <span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="connect"> connect</h2>
<p>从 sore 中的到 state 和 actionCreator，监听 state 变化，触发重渲染</p>
<div><pre><code><span>const</span> <span>connect</span> <span>=</span> <span>(</span><span>mapStateToProps<span>,</span> mapDispatchToProps</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span><span>WrappedComponent</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>(</span><span>props</span><span>)</span> <span>=></span> <span>{</span>
      <span>// 获取 store 和 订阅方法</span>
      <span>const</span> <span>{</span> store<span>,</span> subscription <span>}</span> <span>=</span> <span>useContext</span><span>(</span>ReactReduxContext<span>)</span>
      <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span>
      <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>// redux 中的 state 变化 ==> 触发监听者：onStateChange ==> setCount 引发组件重渲染</span>
        subscription<span>.</span><span>onStateChange</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span>
      <span>}</span><span>,</span> <span>[</span>count<span>]</span><span>)</span>
      <span>const</span> newProps <span>=</span> <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>const</span> stateProps <span>=</span> <span>mapStateToProps</span><span>(</span>store<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span>
        <span>const</span> dispatchProps <span>=</span> <span>mapDispatchToProps</span><span>(</span>store<span>.</span>dispatch<span>)</span>
        <span>return</span> <span>{</span>
          <span>...</span>stateProps<span>,</span>
          <span>...</span>dispatchProps<span>,</span>
          <span>...</span>props
        <span>}</span>
      <span>}</span><span>,</span> <span>[</span>props<span>,</span> store<span>,</span> count<span>]</span><span>)</span>
      <span>return</span> <span><span><span>&lt;</span><span>WrappedComponent</span></span> <span><span>{</span><span>...</span><span>newProps</span><span>}</span></span> <span>/></span></span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">createApp &amp;&amp; mount</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-vue-next/createApp&amp;mount/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-vue-next/createApp&amp;mount/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/code/images/mount.svg" alt="mount" /></p>
<h2 id="本文目标"> 本文目标</h2>
<p>简单实现 vue3 中的 <code>createApp</code> 和 <code>mount</code> 两个 API。虽然只有两个 API，但是这两个 API 实现了 vue3 根实例的创建、组件的解析、vnode 数的构建...<br>
通过这两个 API 的实现，就能够了解到整个 vue3 项目的整体挂载流程，可以说是 vue3 的核心 API。<br>
<a href="https://github.com/yesixuan/test-vue-next" target="_blank" rel="noopener noreferrer">本文代码 GitHub 仓库地址</a></p>
<div><pre><code><span>// 定义根组件</span>
<span>import</span> <span>{</span> h <span>}</span> <span>from</span> <span>'vue'</span> <span>// 文中只有 h 方法使用 vue 官方提供</span>
<span>import</span> <span>{</span> reactive <span>}</span> <span>from</span> <span>'./vic/reactive'</span> <span>// 自己实现的 reactive</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>'./vic'</span> <span>// 自己实现的 createApp</span>

<span>const</span> App <span>=</span> <span>{</span>
  components<span>:</span> <span>{</span> SubCom <span>}</span><span>,</span>
  <span>setup</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> count <span>=</span> <span>reactive</span><span>(</span><span>{</span>
      value<span>:</span> <span>0</span>
    <span>}</span><span>)</span>
    <span>const</span> <span>inc</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
      count<span>.</span>value<span>++</span>
    <span>}</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>h</span><span>(</span><span>'div'</span><span>,</span> <span>[</span><span>h</span><span>(</span><span>'h1'</span><span>,</span> count<span>.</span>value<span>)</span><span>,</span> <span>h</span><span>(</span><span>'button'</span><span>,</span> <span>{</span> onClick<span>:</span> inc <span>}</span><span>,</span> <span>'++'</span><span>)</span><span>,</span> <span>h</span><span>(</span>SubCom<span>)</span><span>]</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// 定义子组件</span>
<span>const</span> SubCom <span>=</span> <span>{</span>
  <span>setup</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>)</span> <span>=></span> <span>h</span><span>(</span><span>'div'</span><span>,</span> <span>[</span><span>h</span><span>(</span><span>'h2'</span><span>,</span> <span>'我是子组件'</span><span>)</span><span>]</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// 挂载</span>
<span>createApp</span><span>(</span>App<span>)</span><span>.</span><span>mount</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>'app'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="代码实现"> 代码实现</h2>
<div><pre><code><span>import</span> <span>{</span> effect <span>}</span> <span>from</span> <span>'./reactive'</span>

<span>let</span> uid <span>=</span> <span>0</span>

<span>/**
 * 1. 创建 context，用来承载一些全局的配置、全局注册的指令、组件...
 * 2. 创建 app 实例（vue 项目唯一的实例，目前主要关注它提供的 mount 方法）
 */</span>
<span>export</span> <span>const</span> <span>createApp</span> <span>=</span> <span>(</span><span>rootComponent<span>,</span> rootProps <span>=</span> <span>null</span></span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> context <span>=</span> <span>{</span>
    config<span>:</span> <span>{</span>
      devtools<span>:</span> <span>true</span><span>,</span>
      performance<span>:</span> <span>false</span><span>,</span>
      globalProperties<span>:</span> <span>{</span><span>}</span><span>,</span>
      optionMergeStrategies<span>:</span> <span>{</span><span>}</span><span>,</span>
      errorHandler<span>:</span> <span>undefined</span><span>,</span>
      warnHandler<span>:</span> <span>undefined</span>
    <span>}</span><span>,</span>
    mixins<span>:</span> <span>[</span><span>]</span><span>,</span>
    components<span>:</span> <span>{</span><span>}</span><span>,</span>
    directives<span>:</span> <span>{</span><span>}</span><span>,</span>
    provides<span>:</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>
  <span>}</span>
  <span>const</span> app <span>=</span> <span>{</span>
    <span>/**
     * 1. 创建根组件的 vnode
     * 2. 调用 render 方法，将 vnode 渲染到真实 dom 上
     */</span>
    <span>mount</span><span>:</span> <span>(</span><span>rootContainer</span><span>)</span> <span>=></span> <span>{</span>
      <span>const</span> vnode <span>=</span> <span>createVNode</span><span>(</span>rootComponent<span>,</span> rootProps<span>)</span>
      vnode<span>.</span>appContext <span>=</span> context
      <span>render</span><span>(</span>vnode<span>,</span> rootContainer<span>)</span>
    <span>}</span><span>,</span>
    components<span>:</span> <span>{</span><span>}</span>
  <span>}</span>
  <span>return</span> app
<span>}</span>

<span>/**
 * 极简版的创建 vnode
 * @param type 当 type 为对象时，表示这是个组件，当 type 为字符串时，表示这是个原生 dom 标签 
 */</span>
<span>function</span> <span>createVNode</span><span>(</span><span>type<span>,</span> props</span><span>)</span> <span>{</span>
  <span>const</span> vnode <span>=</span> <span>{</span>
    __v_isVNode<span>:</span> <span>true</span><span>,</span>
    type<span>,</span>
    props<span>,</span>
    key<span>:</span> props<span>,</span>
    scopeId<span>:</span> <span>1</span><span>,</span>
    children<span>:</span> <span>null</span><span>,</span>
    component<span>:</span> <span>null</span><span>,</span>
    el<span>:</span> <span>null</span><span>,</span>
    shapeFlag<span>:</span> <span>4</span><span>,</span> <span>// 表示组件，因为这里只在创建根组件的 vnode 的时候用到，所以这里先写死</span>
    patchFlag<span>:</span> <span>0</span><span>,</span>
    appContext<span>:</span> <span>null</span>
  <span>}</span>
  <span>return</span> vnode
<span>}</span>

<span>// render 什么也没做，光是调用了 patch 方法</span>
<span>// patch 的第一个参数传入 null 表示这是首次渲染，没有上一次的 vnode 进行 diff</span>
<span>function</span> <span>render</span><span>(</span><span>vnode<span>,</span> container</span><span>)</span> <span>{</span>
  <span>patch</span><span>(</span><span>null</span><span>,</span> vnode<span>,</span> container<span>)</span>
<span>}</span>

<span>// 整个 vue 应用递归挂载的起点</span>
<span>// 根据 shapeFlag 的不同，选择挂载组件还是挂载 dom 元素</span>
<span>function</span> <span>patch</span><span>(</span><span>n1<span>,</span> n2<span>,</span> container<span>,</span></span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> shapeFlag <span>}</span> <span>=</span> n2
  <span>if</span> <span>(</span><span>typeof</span> n2<span>.</span>type <span>===</span> <span>"symbol"</span><span>)</span> <span>{</span>
    <span>processText</span><span>(</span>n1<span>,</span> n2<span>,</span> container<span>)</span>
    <span>return</span>
  <span>}</span>
  <span>if</span> <span>(</span>shapeFlag <span>===</span> <span>17</span> <span>||</span> shapeFlag <span>===</span> <span>9</span><span>)</span> <span>{</span>
    <span>processElement</span><span>(</span>
      n1<span>,</span>
      n2<span>,</span>
      container
    <span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>shapeFlag <span>===</span> <span>4</span><span>)</span> <span>{</span>
    <span>// 首次 mount 走的就是这个分支</span>
    <span>processComponent</span><span>(</span>
      n1<span>,</span>
      n2<span>,</span>
      container
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>// 啥也没干，调了 mountComponent 方法</span>
<span>function</span> <span>processComponent</span><span>(</span><span>n1<span>,</span> n2<span>,</span> container</span><span>)</span> <span>{</span>
  <span>mountComponent</span><span>(</span>n2<span>,</span> container<span>)</span>
<span>}</span>

<span>/**
 * 1. 根据 vnode 创建了它的实例
 * 2. 对实例进行各种处理，包裹 props、data、调用组件的 setup 方法、生成组件的 render 方法
 * 3. 调用实例的 render 方法，得到组件下的第一额真实 dom 的 vnode，递归调用 patch（此时 patch 传入的就是真实 dom 的 vnode 了）
 */</span>
<span>function</span> <span>mountComponent</span><span>(</span><span>initialVNode<span>,</span> container</span><span>)</span> <span>{</span>
  <span>const</span> instance <span>=</span> <span>(</span>initialVNode<span>.</span>component <span>=</span> <span>createComponentInstance</span><span>(</span> initialVNode<span>,</span> <span>null</span><span>,</span> <span>null</span> <span>)</span><span>)</span>
  <span>setupComponent</span><span>(</span>instance<span>)</span>
  <span>setupRenderEffect</span><span>(</span>instance<span>,</span> initialVNode<span>,</span> container<span>)</span>
<span>}</span>

<span>// 根据组件 vnode 创建相应的实例</span>
<span>// 这里需要关注两个属性：appContext、components，这两个属性都继承了根实例的相应属性</span>
<span>// 这样做有利于在每个组件中拿到项目共享的一些属性和方法，在任何组件都能够拿到全局注册过的组件</span>
<span>function</span> <span>createComponentInstance</span><span>(</span><span>vnode<span>,</span> parent<span>,</span> suspense</span><span>)</span> <span>{</span>
  <span>// inherit parent app context - or - if root, adopt from root vnode</span>
  <span>const</span> appContext <span>=</span>
    <span>(</span>parent <span>?</span> parent<span>.</span>appContext <span>:</span> vnode<span>.</span>appContext<span>)</span> <span>||</span> <span>{</span><span>}</span>
  <span>const</span> instance <span>=</span> <span>{</span>
    uid<span>:</span> uid<span>++</span><span>,</span>
    vnode<span>,</span>
    parent<span>,</span>
    appContext<span>,</span>
    type<span>:</span> vnode<span>.</span>type<span>,</span>
    root<span>:</span> <span>null</span><span>,</span> <span>// to be immediately set</span>
    next<span>:</span> <span>null</span><span>,</span>
    subTree<span>:</span> <span>null</span><span>,</span> <span>// will be set synchronously right after creation</span>
    update<span>:</span> <span>null</span><span>,</span> <span>// will be set synchronously right after creation</span>
    render<span>:</span> <span>null</span><span>,</span>

    <span>// state</span>
    ctx<span>:</span> <span>{</span><span>}</span><span>,</span>
    data<span>:</span> <span>{</span><span>}</span><span>,</span>
    props<span>:</span> <span>{</span><span>}</span><span>,</span>
    attrs<span>:</span> <span>{</span><span>}</span><span>,</span>
    slots<span>:</span> <span>{</span><span>}</span><span>,</span>
    refs<span>:</span> <span>{</span><span>}</span><span>,</span>
    setupState<span>:</span> <span>{</span><span>}</span><span>,</span>
    setupContext<span>:</span> <span>null</span><span>,</span>

    <span>// per-instance asset storage (mutable during options resolution)</span>
    components<span>:</span> Object<span>.</span><span>create</span><span>(</span>appContext<span>.</span>components <span>||</span> <span>[</span><span>]</span><span>)</span>
  <span>}</span>
  instance<span>.</span>ctx <span>=</span> <span>{</span> _<span>:</span> instance <span>}</span>
  instance<span>.</span>root <span>=</span> parent <span>?</span> parent<span>.</span>root <span>:</span> instance
  <span>return</span> instance
<span>}</span>

<span>// 这里主要是调用组件的 setup 方法得到了实例的 render 方法（其实还有更多工作，如处理 data、props...此处暂且不论）</span>
<span>function</span> <span>setupComponent</span><span>(</span><span>instance</span><span>)</span> <span>{</span>
  <span>const</span> Component <span>=</span> instance<span>.</span>type
  <span>const</span> <span>{</span> setup <span>}</span> <span>=</span> Component
  <span>const</span> setupResult <span>=</span> <span>setup</span><span>(</span>instance<span>.</span>props<span>,</span> <span>{</span><span>}</span><span>)</span>
  instance<span>.</span>render <span>=</span> setupResult
<span>}</span>

<span>/**
 * 1. 使用 effect 包裹响应式操作
 * 2. 响应式操作里面主要做两件事
 *  2.1 调用实例的 render 方法得到 subTree
 *  2.2 递归调用 patch(subTree, container)
 */</span>
<span>function</span> <span>setupRenderEffect</span><span>(</span>
  <span>instance<span>,</span>
  initialVNode<span>,</span>
  container</span>
<span>)</span> <span>{</span>
  <span>// create reactive effect for rendering</span>
  <span>// Vic 创建更新函数</span>
  instance<span>.</span>update <span>=</span> <span>effect</span><span>(</span><span>function</span> <span>componentEffect</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> el <span>}</span> <span>=</span> initialVNode
    <span>// Vic 在这里创建组件根 dom 的 vNode 树 （这棵树里面的 children 也创建出 vnode）</span>
    <span>const</span> subTree <span>=</span>  <span>(</span>instance<span>.</span>subTree <span>=</span> <span>renderComponentRoot</span><span>(</span>instance<span>)</span><span>)</span>
    el <span>&amp;&amp;</span> container<span>.</span><span>removeChild</span><span>(</span>el<span>)</span>
    <span>// Vic 这个方法里面真正开始构建内存中的 dom 树</span>
    <span>patch</span><span>(</span>
      <span>null</span><span>,</span>
      subTree<span>,</span>
      container
    <span>)</span>
    initialVNode<span>.</span>el <span>=</span> subTree<span>.</span>el
  <span>}</span><span>)</span>
<span>}</span>

<span>// 调用实例的 render 方法，得到该组件实例下根 dom 节点的 vnode （由 h 函数来生成）</span>
<span>function</span> <span>renderComponentRoot</span><span>(</span><span>instance</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span>
    props<span>,</span>
    slots<span>,</span>
    attrs<span>,</span>
    emit<span>,</span>
    render
  <span>}</span> <span>=</span> instance

  <span>let</span> result
  
  <span>// 函数式组件</span>
  result <span>=</span> <span>render</span><span>(</span>props<span>,</span> <span>{</span> attrs<span>,</span> slots<span>,</span> emit <span>}</span><span>)</span>
  <span>return</span> result
<span>}</span>

<span>// 没啥说的，调用 mountElement 方法</span>
<span>function</span> <span>processElement</span><span>(</span><span>n1<span>,</span> n2<span>,</span> container</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n1 <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>mountElement</span><span>(</span>n2<span>,</span> container<span>)</span>
  <span>}</span>
<span>}</span>

<span>/**
 * 前置： 能走到这里来就意味着 vnode 是一个 dom 的 vnode （这里的 type 一定是一个字符串）
 * 1. 根据 type 创建 dom 节点
 * 2. 将创建出来的 dom 节点添加到 container 里面
 * 3. 处理 props （属性和事件）
 * 4. mountChildren （遍历 children，递归调用 patch）
 */</span>
<span>function</span> <span>mountElement</span><span>(</span><span>vnode<span>,</span> container</span><span>)</span> <span>{</span>
  <span>const</span> <span>{</span> type<span>,</span> props <span>}</span> <span>=</span> vnode

  <span>let</span> el <span>=</span> vnode<span>.</span>el <span>=</span> document<span>.</span><span>createElement</span><span>(</span>type<span>)</span>
  container<span>.</span><span>appendChild</span><span>(</span>el<span>)</span>
  Object<span>.</span><span>entries</span><span>(</span>props <span>||</span> <span>{</span><span>}</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span><span>[</span>key<span>,</span> val<span>]</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>key<span>.</span><span>startsWith</span><span>(</span><span>'on'</span><span>)</span><span>)</span> <span>{</span>
      el<span>.</span><span>addEventListener</span><span>(</span>key<span>.</span><span>substr</span><span>(</span><span>2</span><span>)</span><span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span><span>,</span> val<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      el<span>[</span>key<span>]</span> <span>=</span> val
    <span>}</span>
  <span>}</span><span>)</span>
  <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>vnode<span>.</span>children<span>)</span><span>)</span> <span>{</span> <span>// 递归的终止点</span>
    el<span>.</span><span>appendChild</span><span>(</span>document<span>.</span><span>createTextNode</span><span>(</span>vnode<span>.</span>children<span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>mountChildren</span><span>(</span>vnode<span>.</span>children<span>,</span> el<span>,</span> <span>null</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// 对每一个 child 进行 patch</span>
<span>function</span> <span>mountChildren</span><span>(</span><span>children<span>,</span> container</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> child <span>=</span> children<span>[</span>i<span>]</span>
    <span>patch</span><span>(</span>
      <span>null</span><span>,</span>
      child<span>,</span>
      container
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>// 乏善可陈（递归的终止点）</span>
<span>function</span> <span>processText</span><span>(</span><span>n1<span>,</span> n2<span>,</span> container</span><span>)</span> <span>{</span>
  n2<span>.</span>el <span>=</span> document<span>.</span><span>createTextNode</span><span>(</span>n2<span>.</span>children<span>)</span>
  container<span>.</span><span>appendChild</span><span>(</span>n2<span>.</span>el<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br></div></div><h2 id="最后"> 最后</h2>
<p>本文旨在厘清 mount 递归挂载 vue3 应用的整个过程。函数名称与 vue-next 源码保持一致，但是隐藏了大量的细节以及与 mount 无关的分支。</p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">reactive &amp;&amp; effect</title>
    <id>https://x-vic.gitee.io/code/code/views/owner-vue-next/</id>
    <link href="https://x-vic.gitee.io/code/code/views/owner-vue-next/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目标"> 目标</h2>
<p>实现 vue-next 响应式模块中的两个 API : <code>reactive</code>、 <code>effect</code></p>
<div><pre><code><span>var</span> obj <span>=</span> <span>reactive</span><span>(</span><span>{</span>
  name<span>:</span> <span>'Vic'</span><span>,</span>
  haha<span>:</span> <span>{</span>
    num<span>:</span> <span>0</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'打印消息：obj.name'</span><span>,</span> obj<span>.</span>name<span>)</span>
<span>}</span><span>)</span>

<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'打印消息：obj.haha.num'</span><span>,</span> obj<span>.</span>haha<span>.</span>num<span>)</span>
<span>}</span><span>)</span>

obj<span>.</span>name <span>=</span> <span>'qiu'</span>
obj<span>.</span>haha<span>.</span>num <span>=</span> <span>9</span>

<span>// output Vic</span>
<span>// output 0</span>
<span>// output qiu</span>
<span>// output 9</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="代码实现"> 代码实现</h2>
<div><pre><code><span>const</span> targetMap <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span>
<span>let</span> activeEffect

<span>const</span> handlers <span>=</span> <span>{</span>
  <span>get</span><span>:</span> <span>function</span> <span>get</span><span>(</span><span>target<span>,</span> key<span>,</span> receiver</span><span>)</span> <span>{</span>
    <span>const</span> res <span>=</span> Reflect<span>.</span><span>get</span><span>(</span>target<span>,</span> key<span>,</span> receiver<span>)</span>
    <span>track</span><span>(</span>target<span>,</span> key<span>)</span>
    <span>return</span> <span>typeof</span> res <span>===</span> <span>'object'</span>
      <span>?</span> <span>reactive</span><span>(</span>res<span>)</span>
      <span>:</span> res
  <span>}</span><span>,</span>
  <span>set</span><span>:</span> <span>function</span> <span>set</span><span>(</span><span>target<span>,</span> key<span>,</span> value<span>,</span> receiver</span><span>)</span> <span>{</span>
    <span>const</span> result <span>=</span> Reflect<span>.</span><span>set</span><span>(</span>target<span>,</span> key<span>,</span> value<span>,</span> receiver<span>)</span>
    <span>trigger</span><span>(</span>target<span>,</span> key<span>)</span>
    <span>return</span> result
  <span>}</span>
<span>}</span>

<span>function</span> <span>reactive</span><span>(</span><span>target</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handlers<span>)</span>
<span>}</span>

<span>function</span> <span>effect</span><span>(</span><span>fn<span>,</span> options <span>=</span> <span>{</span><span>}</span></span><span>)</span> <span>{</span>
  <span>// 包装原始函数，生成 Effect 对象（实际上就是在 fn 上面个添加一些静态属性）</span>
  <span>const</span> effect <span>=</span> <span>createReactiveEffect</span><span>(</span>fn<span>,</span> options<span>)</span>
  <span>effect</span><span>(</span><span>)</span>
  <span>return</span> effect
<span>}</span>

<span>function</span> <span>createReactiveEffect</span><span>(</span><span>fn<span>,</span> options</span><span>)</span> <span>{</span>
  <span>const</span> <span>effect</span> <span>=</span> <span>function</span> <span>reactiveEffect</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>return</span> <span>run</span><span>(</span>effect<span>,</span> fn<span>,</span> args<span>)</span>
  <span>}</span>
  effect<span>.</span>active <span>=</span> <span>true</span>
  <span>// effect函数中依赖的数据列表（响应数据中也会有一份 effects 的引用。它们是属于多对多的关系）</span>
  <span>return</span> effect
<span>}</span>

<span>function</span> <span>run</span><span>(</span><span>effect<span>,</span> fn<span>,</span> args</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span><span>!</span>effect<span>.</span>active</span><span>)</span> <span>{</span>
    <span>return</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span>
  <span>}</span>
  activeEffect <span>=</span> effect
  <span>// 在这里触发了 getter，进而开始 track</span>
  <span>const</span> res <span>=</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span>
  effect<span>.</span>active <span>=</span> <span>false</span>
  activeEffect <span>=</span> <span>null</span>
  <span>return</span> res
<span>}</span>

<span>function</span> <span>track</span><span>(</span><span>target<span>,</span> key</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>activeEffect <span>==</span> <span>null</span></span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>let</span> depsMap <span>=</span> targetMap<span>.</span><span>get</span><span>(</span>target<span>)</span>
  <span>if</span> <span>(</span><span>depsMap <span>==</span> <span>null</span></span><span>)</span> <span>{</span>
    targetMap<span>.</span><span>set</span><span>(</span>target<span>,</span> <span>(</span>depsMap <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>)</span><span>)</span>
  <span>}</span>
  <span>let</span> dep <span>=</span> depsMap<span>.</span><span>get</span><span>(</span>key<span>)</span>
  <span>if</span> <span>(</span><span>dep <span>==</span> <span>null</span></span><span>)</span> <span>{</span>
    depsMap<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>(</span>dep <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>)</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span><span>!</span>dep<span>.</span><span>has</span><span>(</span>activeEffect<span>)</span></span><span>)</span> <span>{</span>
    <span>// 将 activeEffect 添加进依赖列表</span>
    dep<span>.</span><span>add</span><span>(</span>activeEffect<span>)</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>trigger</span><span>(</span><span>target<span>,</span> key</span><span>)</span> <span>{</span>
  <span>const</span> depsMap <span>=</span> targetMap<span>.</span><span>get</span><span>(</span>target<span>)</span>
  <span>if</span> <span>(</span><span>depsMap <span>==</span> <span>null</span></span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  depsMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>.</span><span>forEach</span><span>(</span><span>effect</span> <span>=></span> <span>effect</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">组件渲染的细节</title>
    <id>https://x-vic.gitee.io/code/code/views/vue-next/componentDetail/</id>
    <link href="https://x-vic.gitee.io/code/code/views/vue-next/componentDetail/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="得到组件的-render-方法"> 得到组件的 render 方法</h2>
<blockquote>
<p>在 mountComponent 的时候（setupRenderEffect 之前），vue 会 setupComponent(instance)</p>
</blockquote>
<ol>
<li>模版编译得到 render</li>
<li>setup 方法返回的是一个函数，那么该函数自动成为实例的 render 方法</li>
</ol>
<h3 id="setupcomponent-instance"> setupComponent(instance)</h3>
<ol>
<li>初始化 props</li>
<li>初始化 slots</li>
<li>调用 setupStatefulComponent</li>
</ol>
<div><pre><code><span>export</span> <span>function</span> <span>setupComponent</span><span>(</span>
  instance<span>:</span> ComponentInternalInstance<span>,</span>
  isSSR <span>=</span> <span>false</span>
<span>)</span> <span>{</span>
  <span>const</span> <span>{</span> props<span>,</span> children<span>,</span> shapeFlag <span>}</span> <span>=</span> instance<span>.</span>vnode
  <span>const</span> isStateful <span>=</span> shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>STATEFUL_COMPONENT</span>
  <span>initProps</span><span>(</span>instance<span>,</span> props<span>,</span> isStateful<span>,</span> isSSR<span>)</span>
  <span>initSlots</span><span>(</span>instance<span>,</span> children<span>)</span>

  <span>const</span> setupResult <span>=</span> isStateful
    <span>?</span> <span>setupStatefulComponent</span><span>(</span>instance<span>,</span> isSSR<span>)</span>
    <span>:</span> <span>undefined</span>
  <span>return</span> setupResult
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="setupstatefulcomponent"> setupStatefulComponent</h3>
<div><pre><code><span>function</span> <span>setupStatefulComponent</span><span>(</span>
  instance<span>:</span> ComponentInternalInstance
<span>)</span> <span>{</span>
  <span>const</span> Component <span>=</span> instance<span>.</span><span>type</span> <span><span>as</span></span> ComponentOptions
  <span>// 0. create render proxy property access cache</span>
  instance<span>.</span>accessCache <span>=</span> <span>{</span><span>}</span>
  <span>// 1. create public instance / render proxy</span>
  <span>// also mark it raw so it's never observed</span>
  instance<span>.</span>proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>instance<span>.</span>ctx<span>,</span> PublicInstanceProxyHandlers<span>)</span>
  <span>// 2. call setup()</span>
  <span>const</span> <span>{</span> setup <span>}</span> <span>=</span> Component
  <span>if</span> <span>(</span>setup<span>)</span> <span>{</span>
    <span>const</span> setupContext <span>=</span> <span>(</span>instance<span>.</span>setupContext <span>=</span>
      setup<span>.</span>length <span>></span> <span>1</span> <span>?</span> <span>createSetupContext</span><span>(</span>instance<span>)</span> <span>:</span> <span>null</span><span>)</span>

    currentInstance <span>=</span> instance
    <span>const</span> setupResult <span>=</span> <span>callWithErrorHandling</span><span>(</span>
      setup<span>,</span>
      instance<span>,</span>
      ErrorCodes<span>.</span><span>SETUP_FUNCTION</span><span>,</span>
      <span>// 这里是真正注入到 setup 函数中的参数</span>
      <span>[</span>__DEV__ <span>?</span> <span>shallowReadonly</span><span>(</span>instance<span>.</span>props<span>)</span> <span>:</span> instance<span>.</span>props<span>,</span> setupContext<span>]</span>
    <span>)</span>
    currentInstance <span>=</span> <span>null</span>

    <span>handleSetupResult</span><span>(</span>instance<span>,</span> setupResult<span>,</span> isSSR<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>finishComponentSetup</span><span>(</span>instance<span>,</span> isSSR<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="callwitherrorhandling"> callWithErrorHandling</h3>
<p>调用 setup，进行错误处理</p>
<div><pre><code><span>export</span> <span>function</span> <span>callWithErrorHandling</span><span>(</span>
  fn<span>:</span> <span>Function</span><span>,</span>
  instance<span>:</span> ComponentInternalInstance <span>|</span> <span>null</span><span>,</span>
  <span>type</span><span>:</span> ErrorTypes<span>,</span>
  args<span>?</span><span>:</span> <span>unknown</span><span>[</span><span>]</span>
<span>)</span> <span>{</span>
  <span>let</span> res
  <span>try</span> <span>{</span>
    res <span>=</span> args <span>?</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span> <span>:</span> <span>fn</span><span>(</span><span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
    <span>handleError</span><span>(</span>err<span>,</span> instance<span>,</span> <span>type</span><span>)</span>
  <span>}</span>
  <span>return</span> res
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="handlesetupresult"> handleSetupResult</h3>
<ol>
<li>如果 setup 返回的是一个函数，那么这个函数将成为 instance 的 render 方法</li>
<li>将 setupResult 包装成 reactive 类型（如果已经是，那就作罢），并将之赋值给 instance.setupState</li>
<li>得到 render，兼容 2.x 选项组件</li>
</ol>
<div><pre><code><span>export</span> <span>function</span> <span>handleSetupResult</span><span>(</span>
  instance<span>:</span> ComponentInternalInstance<span>,</span>
  setupResult<span>:</span> <span>unknown</span><span>,</span>
  isSSR<span>:</span> <span>boolean</span>
<span>)</span> <span>{</span>
  <span>// 如果 setup 返回的是一个函数，那么这个函数将成为 instance 的 render 方法</span>
  <span>if</span> <span>(</span><span>isFunction</span><span>(</span>setupResult<span>)</span><span>)</span> <span>{</span>
    instance<span>.</span>render <span>=</span> setupResult <span>as</span> InternalRenderFunction
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isObject</span><span>(</span>setupResult<span>)</span><span>)</span> <span>{</span>
    <span>// 将 setupResult 包装成 reactive 类型（如果已经是，那就作罢），并将之赋值给 instance.setupState</span>
    instance<span>.</span>setupState <span>=</span> <span>reactive</span><span>(</span>setupResult<span>)</span>
  <span>}</span>
  <span>finishComponentSetup</span><span>(</span>instance<span>,</span> isSSR<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="finishcomponentsetup"> finishComponentSetup</h3>
<ol>
<li>运行时编译得到 render</li>
<li>兼容 2.x 版本的 options</li>
</ol>
<div><pre><code><span>function</span> <span>finishComponentSetup</span><span>(</span>
  instance<span>:</span> ComponentInternalInstance<span>,</span>
  isSSR<span>:</span> <span>boolean</span>
<span>)</span> <span>{</span>
  <span>const</span> Component <span>=</span> instance<span>.</span><span>type</span> <span><span>as</span></span> ComponentOptions

  <span>// template / render function normalization</span>
  <span>if</span> <span>(</span>__NODE_JS__ <span>&amp;&amp;</span> isSSR<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>Component<span>.</span>render<span>)</span> <span>{</span>
      instance<span>.</span>render <span>=</span> Component<span>.</span>render <span>as</span> InternalRenderFunction
    <span>}</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>instance<span>.</span>render<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>compile <span>&amp;&amp;</span> Component<span>.</span>template <span>&amp;&amp;</span> <span>!</span>Component<span>.</span>render<span>)</span> <span>{</span>
      <span>// 在这里，得到运行时编译出来的 render 方法，并且将这个方法缓存起来 compileCache[key] = render 其中，key 是原始模版字符串 </span>
      Component<span>.</span>render <span>=</span> <span>compile</span><span>(</span>Component<span>.</span>template<span>,</span> <span>{</span>
        isCustomElement<span>:</span> instance<span>.</span>appContext<span>.</span>config<span>.</span>isCustomElement <span>||</span> <span>NO</span>
      <span>}</span><span>)</span>
      <span>// 标记这个 render 方法是一个 runtime compile function</span>
      <span>;</span><span>(</span>Component<span>.</span>render <span>as</span> InternalRenderFunction<span>)</span><span>.</span>_rc <span>=</span> <span>true</span>
    <span>}</span>

    instance<span>.</span>render <span>=</span> <span>(</span>Component<span>.</span>render <span>||</span> <span>NOOP</span><span>)</span> <span>as</span> InternalRenderFunction

    <span>// 运行时编译的 render 使用了 with 语句，重新代理...</span>
    <span>if</span> <span>(</span>instance<span>.</span>render<span>.</span>_rc<span>)</span> <span>{</span>
      instance<span>.</span>withProxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>
        instance<span>.</span>ctx<span>,</span>
        RuntimeCompiledPublicInstanceProxyHandlers
      <span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// 兼容 2.x 选项组件</span>
  <span>if</span> <span>(</span>__FEATURE_OPTIONS__<span>)</span> <span>{</span>
    currentInstance <span>=</span> instance
    <span>applyOptions</span><span>(</span>instance<span>,</span> Component<span>)</span>
    currentInstance <span>=</span> <span>null</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="如何得到组件中真正需要渲染的-vdom"> 如何得到组件中真正需要渲染的 vdom</h2>
<blockquote>
<p>渲染(effect)一个组件的时候，通过 <code>const subTree = (instance.subTree = renderComponentRoot(instance))</code> 调用了 instance 的 render 方法，生成了标签 vnode 以及 自组件 vnode</p>
</blockquote>
<h3 id="rendercomponentroot"> renderComponentRoot</h3>
<p>调用 instance 的 render 方法，返回真实节点的 vnode</p>
<div><pre><code><span>export</span> <span>function</span> <span>renderComponentRoot</span><span>(</span>
  instance<span>:</span> ComponentInternalInstance
<span>)</span><span>:</span> VNode <span>{</span>
  <span>const</span> <span>{</span>
    <span>type</span><span>:</span> Component<span>,</span>
    parent<span>,</span>
    vnode<span>,</span>
    proxy<span>,</span>
    withProxy<span>,</span>
    props<span>,</span>
    slots<span>,</span>
    attrs<span>,</span>
    emit<span>,</span>
    renderCache
  <span>}</span> <span>=</span> instance

  <span>let</span> result
  currentRenderingInstance <span>=</span> instance
  
  <span>let</span> fallthroughAttrs
  <span>// 选项组件</span>
  <span>if</span> <span>(</span>vnode<span>.</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>STATEFUL_COMPONENT</span><span>)</span> <span>{</span>
    <span>// 运行时编译出来的 render 使用了 with 语句，这里要判断是不是需要 withProxy （with 语句对 has 操作符是要区别处理的）</span>
    <span>const</span> proxyToUse <span>=</span> withProxy <span>||</span> proxy
    <span>// 在这里创建子节点的 vNode</span>
    result <span>=</span> <span>normalizeVNode</span><span>(</span>
      instance<span>.</span>render<span>!</span><span>.</span><span>call</span><span>(</span>proxyToUse<span>,</span> proxyToUse<span>!</span><span>,</span> renderCache<span>)</span>
    <span>)</span>
    fallthroughAttrs <span>=</span> attrs
  <span>}</span> <span>else</span> <span>{</span>
    <span>// 函数式组件</span>
    <span>const</span> render <span>=</span> Component <span>as</span> FunctionalComponent
    result <span>=</span> <span>normalizeVNode</span><span>(</span>
      render<span>.</span>length <span>></span> <span>1</span>
        <span>// 往函数式组件（即单独一个 setup 函数）注入相关参数</span>
        <span>?</span> <span>render</span><span>(</span>props<span>,</span> <span>{</span> attrs<span>,</span> slots<span>,</span> emit <span>}</span><span>)</span>
        <span>:</span> <span>render</span><span>(</span>props<span>,</span> <span>null</span> <span>as</span> <span>any</span> <span>/* we know it doesn't need it */</span><span>)</span>
    <span>)</span>
    fallthroughAttrs <span>=</span> Component<span>.</span>props <span>?</span> attrs <span>:</span> <span>getFallthroughAttrs</span><span>(</span>attrs<span>)</span>
  <span>}</span>

  <span>let</span> root <span>=</span> result  
  
  root <span>=</span> <span>cloneVNode</span><span>(</span>root<span>,</span> fallthroughAttrs<span>)</span>
  
  result <span>=</span> root
  currentRenderingInstance <span>=</span> <span>null</span>

  <span>return</span> result
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id="内存中创建的-render"> 内存中创建的 render</h3>
<div><pre><code><span>(</span><span>function</span> <span>anonymous</span><span>(</span><span>Vue</span>
<span>)</span> <span>{</span>
<span>const</span> _Vue <span>=</span> Vue

<span>return</span> <span>function</span> <span>render</span><span>(</span><span>_ctx<span>,</span> _cache</span><span>)</span> <span>{</span>
  <span>// 通过 with 语句将 vue 组件实例注入到 render 函数的执行上下文中，以便 render 函数直接读取实例中的 data、method...</span>
  <span>with</span> <span>(</span>_ctx<span>)</span> <span>{</span>
    <span>const</span> <span>{</span> resolveComponent<span>:</span> _resolveComponent<span>,</span> createVNode<span>:</span> _createVNode<span>,</span> toDisplayString<span>:</span> _toDisplayString<span>,</span> createTextVNode<span>:</span> _createTextVNode<span>,</span> Fragment<span>:</span> _Fragment<span>,</span> openBlock<span>:</span> _openBlock<span>,</span> createBlock<span>:</span> _createBlock <span>}</span> <span>=</span> _Vue

    <span>const</span> _component_Hehe <span>=</span> <span>_resolveComponent</span><span>(</span><span>"Hehe"</span><span>)</span>

    <span>return</span> <span>(</span><span>_openBlock</span><span>(</span><span>)</span><span>,</span> <span>_createBlock</span><span>(</span>_Fragment<span>,</span> <span>null</span><span>,</span> <span>[</span>
      <span>_createVNode</span><span>(</span>_component_Hehe<span>)</span><span>,</span>
      <span>// count 直接从 _ctx 中读取</span>
      <span>_createTextVNode</span><span>(</span><span>_toDisplayString</span><span>(</span>count<span>)</span><span>,</span> <span>1</span> <span>/* TEXT */</span><span>)</span>
    <span>]</span><span>,</span> <span>64</span> <span>/* STABLE_FRAGMENT */</span><span>)</span><span>)</span>
  <span>}</span>
<span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">createApp &amp;&amp; mount</title>
    <id>https://x-vic.gitee.io/code/code/views/vue-next/createApp&amp;mount/</id>
    <link href="https://x-vic.gitee.io/code/code/views/vue-next/createApp&amp;mount/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/code/images/patch.svg" alt="patch" /></p>
<h2 id="createapp"> createApp</h2>
<ol>
<li>根据不同的宿主环境创建不同的 app</li>
<li>初始化 app 的各种方法</li>
</ol>
<blockquote>
<p>在 createApp 传入的参数被当作闭包存起来，之后在调用 app 的各种方法时，都可以直接取到这些入参。</p>
</blockquote>
<div><pre><code><span>const</span> <span>createApp</span> <span>=</span> <span>(</span>rootComponent<span>,</span> rootProps <span>=</span> <span>null</span><span>)</span> <span>=></span> <span>{</span>
  <span>/**
   * context 包含 components、config、directives、mixins、provides
  */</span>
  <span>const</span> context <span>=</span> <span>createAppContext</span><span>(</span><span>)</span>
  <span>const</span> app<span>:</span> App <span>=</span> <span>{</span>
    _component<span>:</span> rootComponent <span>as</span> Component<span>,</span>
    _props<span>:</span> rootProps<span>,</span>
    _container<span>:</span> <span>null</span><span>,</span>
    _context<span>:</span> context<span>,</span>

    <span>get</span> <span>config</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>set</span> <span>config</span><span>(</span>v<span>)</span> <span>{</span><span>}</span><span>,</span>

    <span>use</span><span>(</span>plugin<span>:</span> Plugin<span>,</span> <span>...</span>options<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>mixin</span><span>(</span>mixin<span>:</span> ComponentOptions<span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>component</span><span>(</span>name<span>:</span> <span>string</span><span>,</span> component<span>?</span><span>:</span> PublicAPIComponent<span>)</span><span>:</span> <span>any</span> <span>{</span><span>}</span><span>,</span>
    <span>directive</span><span>(</span>name<span>:</span> <span>string</span><span>,</span> directive<span>?</span><span>:</span> Directive<span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>mount</span><span>(</span>rootContainer<span>:</span> HostElement<span>,</span> isHydrate<span>?</span><span>:</span> <span>boolean</span><span>)</span><span>:</span> <span>any</span> <span>{</span><span>}</span><span>,</span>
    <span>unmount</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>provide</span><span>(</span>key<span>,</span> value<span>)</span> <span>{</span><span>}</span>
  <span>}</span>

  <span>return</span> app
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="mount"> mount</h2>
<div><pre><code><span>mount</span><span>(</span>rootContainer<span>:</span> HostElement<span>,</span> isHydrate<span>?</span><span>:</span> <span>boolean</span><span>)</span><span>:</span> <span>any</span> <span>{</span>
  <span>// rootComponent 从 createApp 中的闭包中拿到</span>
  <span>/**
   * 1. 确定 shapeFlag （shapeFlag 用来分辨这个 vnode 是什么类型，如 string、element、statefulComponent、FunctionalComponent...）
  */</span>
  <span>const</span> vnode <span>=</span> <span>createVNode</span><span>(</span>rootComponent <span>as</span> Component<span>,</span> rootProps<span>)</span>
  <span>render</span><span>(</span>vnode<span>,</span> rootContainer<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="根-render"> 根 render</h3>
<div><pre><code><span>const</span> render<span>:</span> <span>RootRenderFunction</span> <span>=</span> <span>(</span>vnode<span>,</span> container<span>)</span> <span>=></span> <span>{</span>
  <span>patch</span><span>(</span>container<span>.</span>_vnode <span>||</span> <span>null</span><span>,</span> vnode<span>,</span> container<span>)</span>
  <span>flushPostFlushCbs</span><span>(</span><span>)</span>
  container<span>.</span>_vnode <span>=</span> vnode
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="patch"> patch</h3>
<div><pre><code><span>const</span> patch<span>:</span> <span>PatchFn</span> <span>=</span> <span>(</span>
  n1<span>,</span>
  n2<span>,</span>
  container<span>,</span>
  anchor <span>=</span> <span>null</span><span>,</span>
  parentComponent <span>=</span> <span>null</span><span>,</span>
  parentSuspense <span>=</span> <span>null</span><span>,</span>
  isSVG <span>=</span> <span>false</span><span>,</span>
  optimized <span>=</span> <span>false</span>
<span>)</span> <span>=></span> <span>{</span>
  <span>// 对比 n1 n2 类型是否相同，如果不想同，就卸载旧的 vnode</span>
  <span>if</span> <span>(</span>n1 <span>&amp;&amp;</span> <span>!</span><span>isSameVNodeType</span><span>(</span>n1<span>,</span> n2<span>)</span><span>)</span> <span>{</span>
    anchor <span>=</span> <span>getNextHostNode</span><span>(</span>n1<span>)</span>
    <span>unmount</span><span>(</span>n1<span>,</span> parentComponent<span>,</span> parentSuspense<span>,</span> <span>true</span><span>)</span>
    n1 <span>=</span> <span>null</span>
  <span>}</span>

  <span>const</span> <span>{</span> <span>type</span><span>,</span> ref<span>,</span> shapeFlag <span>}</span> <span>=</span> n2
  <span>switch</span> <span>(</span><span>type</span><span>)</span> <span>{</span>
    <span>case</span> Text<span>:</span>
      <span>processText</span><span>(</span>n1<span>,</span> n2<span>,</span> container<span>,</span> anchor<span>)</span>
      <span>break</span>
    <span>case</span> Comment<span>:</span>
      <span>processCommentNode</span><span>(</span>n1<span>,</span> n2<span>,</span> container<span>,</span> anchor<span>)</span>
      <span>break</span>
    <span>case</span> Static<span>:</span>
      <span>if</span> <span>(</span>n1 <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>mountStaticNode</span><span>(</span>n2<span>,</span> container<span>,</span> anchor<span>,</span> isSVG<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>__DEV__<span>)</span> <span>{</span>
        <span>patchStaticNode</span><span>(</span>n1<span>,</span> n2<span>,</span> container<span>,</span> isSVG<span>)</span>
      <span>}</span>
      <span>break</span>
    <span>case</span> Fragment<span>:</span>
      <span>processFragment</span><span>(</span>
        n1<span>,</span>
        n2<span>,</span>
        container
      <span>)</span>
      <span>break</span>
    <span>default</span><span>:</span>
      <span>if</span> <span>(</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>ELEMENT</span><span>)</span> <span>{</span>
        <span>processElement</span><span>(</span>
          n1<span>,</span>
          n2<span>,</span>
          container
        <span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>COMPONENT</span><span>)</span> <span>{</span>
        <span>// 首次 mount 走的就是这个分支</span>
        <span>processComponent</span><span>(</span>
          n1<span>,</span>
          n2<span>,</span>
          container
        <span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>TELEPORT</span><span>)</span> <span>{</span>
        <span>;</span><span>(</span><span>type</span> <span><span>as</span></span> <span>typeof</span> TeleportImpl<span>)</span><span>.</span><span>process</span><span>(</span>
          n1<span>,</span>
          n2<span>,</span>
          container
        <span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>__FEATURE_SUSPENSE__ <span>&amp;&amp;</span> shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>SUSPENSE</span><span>)</span> <span>{</span>
        <span>;</span><span>(</span><span>type</span> <span><span>as</span></span> <span>typeof</span> SuspenseImpl<span>)</span><span>.</span><span>process</span><span>(</span>
          n1<span>,</span>
          n2<span>,</span>
          container
        <span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>__DEV__<span>)</span> <span>{</span>
        <span>warn</span><span>(</span><span>'Invalid VNode type:'</span><span>,</span> <span>type</span><span>,</span> <span><span>`</span><span>(</span><span><span>${</span><span>typeof</span> <span>type</span><span>}</span></span><span>)</span><span>`</span></span><span>)</span>
      <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><h3 id="processcomponent"> processComponent</h3>
<ol>
<li>判断 n1 是否存在来执行</li>
</ol>
<div><pre><code><span>const</span> <span>processComponent</span> <span>=</span> <span>(</span>
  n1<span>:</span> VNode <span>|</span> <span>null</span><span>,</span>
  n2<span>:</span> VNode<span>,</span>
  container<span>:</span> RendererElement<span>,</span>
  anchor<span>:</span> RendererNode <span>|</span> <span>null</span><span>,</span>
  parentComponent<span>:</span> ComponentInternalInstance <span>|</span> <span>null</span><span>,</span>
  parentSuspense<span>:</span> SuspenseBoundary <span>|</span> <span>null</span><span>,</span>
  isSVG<span>:</span> <span>boolean</span><span>,</span>
  optimized<span>:</span> <span>boolean</span>
<span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>n1 <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>mountComponent</span><span>(</span>
      n2<span>,</span>
      container<span>,</span>
      anchor<span>,</span>
      parentComponent<span>,</span>
      parentSuspense<span>,</span>
      isSVG<span>,</span>
      optimized
    <span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>updateComponent</span><span>(</span>n1<span>,</span> n2<span>,</span> parentComponent<span>,</span> optimized<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="mountcomponent"> mountComponent</h3>
<ol>
<li>创建组件实例</li>
<li>执行 setup 函数</li>
<li>调用 setupRenderEffect</li>
</ol>
<div><pre><code><span>const</span> mountComponent<span>:</span> <span>MountComponentFn</span> <span>=</span> <span>(</span>
  initialVNode<span>,</span>
  container<span>,</span>
  anchor<span>,</span>
  parentComponent<span>,</span>
  parentSuspense<span>,</span>
  isSVG<span>,</span>
  optimized
<span>)</span> <span>=></span> <span>{</span>
  <span>/**
   * 创建组件实例，该实例主要包含：各钩子函数、ctx（$data、$emit...）、
  */</span>
  <span>const</span> instance<span>:</span> ComponentInternalInstance <span>=</span> <span>(</span>initialVNode<span>.</span>component <span>=</span> <span>createComponentInstance</span><span>(</span>
    initialVNode<span>,</span>
    parentComponent<span>,</span>
    parentSuspense
  <span>)</span><span>)</span>

  <span>/**
   * 初始化 props、slots
   * 执行 setup 函数，返回结果
  */</span>
  <span>setupComponent</span><span>(</span>instance<span>)</span>

  <span>setupRenderEffect</span><span>(</span>
    instance<span>,</span>
    initialVNode<span>,</span>
    container<span>,</span>
    anchor<span>,</span>
    parentSuspense<span>,</span>
    isSVG<span>,</span>
    optimized
  <span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h3 id="setuprendereffect"> setupRenderEffect</h3>
<p>创建子节点的 vnode</p>
<div><pre><code><span>const</span> setupRenderEffect<span>:</span> <span>SetupRenderEffectFn</span> <span>=</span> <span>(</span>
  instance<span>,</span>
  initialVNode<span>,</span>
  container<span>,</span>
  anchor<span>,</span>
  parentSuspense<span>,</span>
  isSVG<span>,</span>
  optimized
<span>)</span> <span>=></span> <span>{</span>
  <span>// Vic 创建更新函数</span>
  instance<span>.</span>update <span>=</span> <span>effect</span><span>(</span><span>function</span> <span>componentEffect</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>instance<span>.</span>isMounted<span>)</span> <span>{</span>
      <span>let</span> vnodeHook<span>:</span> VNodeHook <span>|</span> <span>null</span> <span>|</span> <span>undefined</span>
      <span>const</span> <span>{</span> el<span>,</span> props <span>}</span> <span>=</span> initialVNode
      <span>const</span> <span>{</span> bm<span>,</span> m<span>,</span> a<span>,</span> parent <span>}</span> <span>=</span> instance
      
      <span>// 得到组件中根节点的 vnode (这个节点的 vnode 就是 dom 的 vnode)</span>
      <span>// 将 render 函数依赖收集了（这里的 render 是 vue 生成的 render，不同于上面提到的 render）</span>
      <span>/**
       * renderComponentRoot 里面会创建 child 的 vnode
      */</span>
      <span>const</span> subTree <span>=</span>  <span>(</span>instance<span>.</span>subTree <span>=</span> <span>renderComponentRoot</span><span>(</span>instance<span>)</span><span>)</span>
      
      <span>// 调用 beforeMount hook</span>
      <span>if</span> <span>(</span>bm<span>)</span> <span>{</span>
        <span>invokeArrayFns</span><span>(</span>bm<span>)</span>
      <span>}</span>
      
      <span>// 递归调用 patch，与第一次不同的是 n2 已经不是之前的根组件 vnode，而是根组件里面根元素的 vnode （这一次的 patch 是可以真正执行 appendChild 操作）</span>
      <span>patch</span><span>(</span>
        <span>null</span><span>,</span>
        subTree<span>,</span>
        container<span>,</span>
        anchor<span>,</span>
        instance<span>,</span>
        parentSuspense<span>,</span>
        isSVG
      <span>)</span>
      initialVNode<span>.</span>el <span>=</span> subTree<span>.</span>el

      <span>// 调用 mounted hook</span>
      <span>if</span> <span>(</span>m<span>)</span> <span>{</span>
        <span>queuePostRenderEffect</span><span>(</span>m<span>,</span> parentSuspense<span>)</span>
      <span>}</span>
      instance<span>.</span>isMounted <span>=</span> <span>true</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// 更新逻辑</span>
    <span>}</span>
  <span>}</span><span>,</span> __DEV__ <span>?</span> <span>createDevEffectOptions</span><span>(</span>instance<span>)</span> <span>:</span> prodEffectOptions<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><h3 id="effect-调用-patch"> effect 调用 patch</h3>
<h3 id="processelement-n2-为-article-这个节点的-vnode"> processElement (n2 为 article 这个节点的 vnode)</h3>
<div><pre><code><span>const</span> <span>processElement</span> <span>=</span> <span>(</span>
  n1<span>:</span> VNode <span>|</span> <span>null</span><span>,</span>
  n2<span>:</span> VNode<span>,</span>
  container<span>:</span> RendererElement<span>,</span>
  anchor<span>:</span> RendererNode <span>|</span> <span>null</span><span>,</span>
  parentComponent<span>:</span> ComponentInternalInstance <span>|</span> <span>null</span><span>,</span>
  parentSuspense<span>:</span> SuspenseBoundary <span>|</span> <span>null</span><span>,</span>
  isSVG<span>:</span> <span>boolean</span><span>,</span>
  optimized<span>:</span> <span>boolean</span>
<span>)</span> <span>=></span> <span>{</span>
  isSVG <span>=</span> isSVG <span>||</span> <span>(</span>n2<span>.</span><span>type</span> <span><span>as</span></span> <span>string</span><span>)</span> <span>===</span> <span>'svg'</span>
  <span>if</span> <span>(</span>n1 <span>==</span> <span>null</span><span>)</span> <span>{</span>
    <span>mountElement</span><span>(</span>
      n2<span>,</span>
      container<span>,</span>
      anchor<span>,</span>
      parentComponent<span>,</span>
      parentSuspense<span>,</span>
      isSVG<span>,</span>
      optimized
    <span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>patchElement</span><span>(</span>n1<span>,</span> n2<span>,</span> parentComponent<span>,</span> parentSuspense<span>,</span> isSVG<span>,</span> optimized<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="mountelement"> mountElement</h3>
<p>这里包含递归终止条件，即这个 vnode 的 children 是 text，那就终止。</p>
<ol>
<li>重用静态 dom 节点</li>
<li>根据 vnode 创建 dom</li>
<li>插入 dom 属性</li>
<li>调用指令的钩子(beforeMount)</li>
<li>给 dom 添加 scopeId</li>
<li>处理 children</li>
<li>将创建好的 dom 插入到 container</li>
</ol>
<div><pre><code><span>const</span> <span>mountElement</span> <span>=</span> <span>(</span>
  vnode<span>:</span> VNode<span>,</span>
  container<span>:</span> RendererElement<span>,</span>
  anchor<span>:</span> RendererNode <span>|</span> <span>null</span><span>,</span>
  parentComponent<span>:</span> ComponentInternalInstance <span>|</span> <span>null</span><span>,</span>
  parentSuspense<span>:</span> SuspenseBoundary <span>|</span> <span>null</span><span>,</span>
  isSVG<span>:</span> <span>boolean</span><span>,</span>
  optimized<span>:</span> <span>boolean</span>
<span>)</span> <span>=></span> <span>{</span>
  <span>let</span> el<span>:</span> RendererElement
  <span>let</span> vnodeHook<span>:</span> VNodeHook <span>|</span> <span>undefined</span> <span>|</span> <span>null</span>
  <span>const</span> <span>{</span>
    <span>type</span><span>,</span>
    props<span>,</span>
    shapeFlag<span>,</span>
    transition<span>,</span>
    scopeId<span>,</span>
    patchFlag<span>,</span>
    dirs
  <span>}</span> <span>=</span> vnode
  <span>if</span> <span>(</span>
    vnode<span>.</span>el <span>&amp;&amp;</span>
    hostCloneNode <span>!==</span> <span>undefined</span> <span>&amp;&amp;</span>
    patchFlag <span>===</span> PatchFlags<span>.</span><span>HOISTED</span>
  <span>)</span> <span>{</span>
    <span>// 如果是静态节点，那就重用</span>
    el <span>=</span> vnode<span>.</span>el <span>=</span> <span>hostCloneNode</span><span>(</span>vnode<span>.</span>el<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// 这里创建了真实的 dom</span>
    el <span>=</span> vnode<span>.</span>el <span>=</span> <span>hostCreateElement</span><span>(</span>
      vnode<span>.</span><span>type</span> <span><span>as</span></span> <span>string</span><span>,</span>
      isSVG<span>,</span>
      props <span>&amp;&amp;</span> props<span>.</span><span>is</span>
    <span>)</span>
    <span>// props</span>
    <span>if</span> <span>(</span>props<span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>const</span> key <span>in</span> props<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>isReservedProp</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
          <span>hostPatchProp</span><span>(</span>el<span>,</span> key<span>,</span> <span>null</span><span>,</span> props<span>[</span>key<span>]</span><span>,</span> isSVG<span>)</span>
        <span>}</span>
      <span>}</span>
      <span>if</span> <span>(</span><span>(</span>vnodeHook <span>=</span> props<span>.</span>onVnodeBeforeMount<span>)</span><span>)</span> <span>{</span>
        <span>invokeVNodeHook</span><span>(</span>vnodeHook<span>,</span> parentComponent<span>,</span> vnode<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>dirs<span>)</span> <span>{</span>
      <span>invokeDirectiveHook</span><span>(</span>vnode<span>,</span> <span>null</span><span>,</span> parentComponent<span>,</span> <span>'beforeMount'</span><span>)</span>
    <span>}</span>

    <span>// scopeId</span>
    <span>if</span> <span>(</span>scopeId<span>)</span> <span>{</span>
      <span>hostSetScopeId</span><span>(</span>el<span>,</span> scopeId<span>)</span>
    <span>}</span>

    <span>// 处理 children （container 变成了新创建的 container，这里一定是先把所有的 children 全部挂载之后，最后一次挂载到 mount 中的 container 上）</span>
    <span>if</span> <span>(</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>TEXT_CHILDREN</span><span>)</span> <span>{</span>
      <span>hostSetElementText</span><span>(</span>el<span>,</span> vnode<span>.</span>children <span>as</span> <span>string</span><span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>shapeFlag <span>&amp;</span> ShapeFlags<span>.</span><span>ARRAY_CHILDREN</span><span>)</span> <span>{</span>
      <span>// 这里执行完之后，就在内存中创建了一棵大大的 dom 树</span>
      <span>mountChildren</span><span>(</span>
        vnode<span>.</span>children <span>as</span> VNodeArrayChildren<span>,</span>
        el<span>,</span>
        <span>null</span><span>,</span>
        parentComponent<span>,</span>
        parentSuspense<span>,</span>
        isSVG <span>&amp;&amp;</span> <span>type</span> <span>!==</span> <span>'foreignObject'</span><span>,</span>
        optimized <span>||</span> <span>!</span><span>!</span>vnode<span>.</span>dynamicChildren
      <span>)</span>
    <span>}</span>
  <span>}</span>
  <span>// 这里开始作dom插入</span>
  <span>hostInsert</span><span>(</span>el<span>,</span> container<span>,</span> anchor<span>)</span>
  <span>if</span> <span>(</span>
    <span>(</span>vnodeHook <span>=</span> props <span>&amp;&amp;</span> props<span>.</span>onVnodeMounted<span>)</span> <span>||</span> dirs
  <span>)</span> <span>{</span>
    <span>queuePostRenderEffect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      vnodeHook <span>&amp;&amp;</span> <span>invokeVNodeHook</span><span>(</span>vnodeHook<span>,</span> parentComponent<span>,</span> vnode<span>)</span>
      dirs <span>&amp;&amp;</span> <span>invokeDirectiveHook</span><span>(</span>vnode<span>,</span> <span>null</span><span>,</span> parentComponent<span>,</span> <span>'mounted'</span><span>)</span>
    <span>}</span><span>,</span> parentSuspense<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br></div></div><h4 id="mountchildren"> mountChildren</h4>
<p>递归调用 patch</p>
<div><pre><code><span>const</span> mountChildren<span>:</span> <span>MountChildrenFn</span> <span>=</span> <span>(</span>
  children<span>,</span>
  container<span>,</span>
  start <span>=</span> <span>0</span>
<span>)</span> <span>=></span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> start<span>;</span> i <span>&lt;</span> children<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> child <span>=</span> <span>(</span>children<span>[</span>i<span>]</span> <span>=</span> optimized
      <span>?</span> <span>cloneIfMounted</span><span>(</span>children<span>[</span>i<span>]</span> <span>as</span> VNode<span>)</span>
      <span>:</span> <span>normalizeVNode</span><span>(</span>children<span>[</span>i<span>]</span><span>)</span><span>)</span>
    <span>patch</span><span>(</span>
      <span>null</span><span>,</span>
      child<span>,</span>
      container<span>,</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">effect</title>
    <id>https://x-vic.gitee.io/code/code/views/vue-next/effect/</id>
    <link href="https://x-vic.gitee.io/code/code/views/vue-next/effect/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<p>vue-next 中的依赖收集通过显式调用它提供的<code>effect</code>方法来启动。</p>
<h2 id="usage"> usage</h2>
<div><pre><code><span>const</span> <span>{</span> reactive<span>,</span> effect <span>}</span> <span>from</span> 'vue

<span>const</span> obj <span>=</span> <span>reactive</span><span>(</span><span>{</span> foo<span>:</span> <span>0</span> <span>}</span><span>)</span>
<span>effect</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>obj<span>.</span>foo<span>)</span>
<span>}</span><span>)</span>
<span>// output 0</span>
obj<span>.</span>foo<span>++</span>
<span>// output 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="effect-函数"> effect 函数</h2>
<p>主要做两件事：1. 包装 fn 生成 Effect；2. 调用 Effect 的 run 方法</p>
<div><div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>function</span> <span><span>effect</span><span><span>&lt;</span><span>T</span> <span>=</span> <span>any</span><span>></span></span></span><span>(</span>
  <span>fn</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>T</span><span>,</span>
  options<span>:</span> ReactiveEffectOptions <span>=</span> <span>EMPTY_OBJ</span>
<span>)</span><span>:</span> ReactiveEffect<span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>// 如果传入的函数已经是一个 Effect 对象</span>
  <span>if</span> <span>(</span><span>isEffect</span><span>(</span>fn<span>)</span><span>)</span> <span>{</span>
    fn <span>=</span> fn<span>.</span>raw
  <span>}</span>
  <span>// 包装原始函数，生成 Effect 对象（实际上就是在 fn 上面个添加一些静态属性）</span>
  <span>const</span> effect <span>=</span> <span>createReactiveEffect</span><span>(</span>fn<span>,</span> options<span>)</span>
  <span>if</span> <span>(</span><span>!</span>options<span>.</span>lazy<span>)</span> <span>{</span>
    <span>// 这一步真正调用传入的函数，触发了 getter</span>
    <span>effect</span><span>(</span><span>)</span>
  <span>}</span>
  <span>return</span> effect
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="createreactiveeffect"> createReactiveEffect</h2>
<p>创建 <code>effect</code> 函数，往 <code>effect</code> 上面加上一些静态属性</p>
<div><pre><code><span>function</span> <span><span>createReactiveEffect</span><span><span>&lt;</span><span>T</span> <span>=</span> <span>any</span><span>></span></span></span><span>(</span>
  <span>fn</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>T</span><span>,</span>
  options<span>:</span> ReactiveEffectOptions
<span>)</span><span>:</span> ReactiveEffect<span>&lt;</span><span>T</span><span>></span> <span>{</span>
  <span>// 依赖收集过程中 args 是没有的</span>
  <span>// 但是用户是可以拿到返回出去的 effect 进而手动调用，传入参数</span>
  <span>const</span> <span>effect</span> <span>=</span> <span>function</span> <span>reactiveEffect</span><span>(</span><span>...</span>args<span>:</span> <span>unknown</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>unknown</span> <span>{</span>
    <span>return</span> <span>run</span><span>(</span>effect<span>,</span> fn<span>,</span> args<span>)</span>
  <span>}</span> <span>as</span> ReactiveEffect
  effect<span>.</span>_isEffect <span>=</span> <span>true</span>
  effect<span>.</span>active <span>=</span> <span>true</span>
  effect<span>.</span>raw <span>=</span> fn
  <span>// effect函数中依赖的数据列表（响应数据中也会有一份 effects 的引用。它们是属于多对多的关系）</span>
  effect<span>.</span>deps <span>=</span> <span>[</span><span>]</span>
  effect<span>.</span>options <span>=</span> options
  <span>return</span> effect
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="run"> run</h2>
<ol>
<li>只有当 <code>effect</code> 中调用的 <code>fn</code> 才会触发依赖追踪（手动调用 <code>effect</code> 返回的函数以及 <code>setter</code> 触发的调用都不进行依赖收集）</li>
<li>保存 <code>effect</code> <code>引用（track</code> 是需要用到）</li>
<li>调用 <code>fn</code> 触发 <code>getter</code></li>
</ol>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>run</span><span>(</span>effect<span>:</span> ReactiveEffect<span>,</span> fn<span>:</span> <span>Function</span><span>,</span> args<span>:</span> <span>unknown</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>unknown</span> <span>{</span>
  <span>// 使用 effect(Function) 收集依赖时（effect.active === true）才会继续</span>
  <span>// 下面条件在 fn = effect(Function); fn() 下会为真</span>
  <span>if</span> <span>(</span><span>!</span>effect<span>.</span>active<span>)</span> <span>{</span>
    <span>return</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>effectStack<span>.</span><span>includes</span><span>(</span>effect<span>)</span><span>)</span> <span>{</span>
    <span>// 清空 effect.deps 中的响应式数据</span>
    <span>cleanup</span><span>(</span>effect<span>)</span>
    <span>try</span> <span>{</span>
      <span>enableTracking</span><span>(</span><span>)</span>
      effectStack<span>.</span><span>push</span><span>(</span>effect<span>)</span>
      <span>// 这一步引用指向很重要，因为在真正进行 track 的时候，</span>
      <span>// 需要将 activeEffect 添加到响应式数据的 effects 列表中，</span>
      <span>// 最后在 setter 被触发之后，挨个儿调用 effect</span>
      activeEffect <span>=</span> effect
      <span>// 在这里触发了 getter，进而开始 track</span>
      <span>return</span> <span>fn</span><span>(</span><span>...</span>args<span>)</span>
    <span>}</span> <span>finally</span> <span>{</span>
      effectStack<span>.</span><span>pop</span><span>(</span><span>)</span>
      <span>resetTracking</span><span>(</span><span>)</span>
      activeEffect <span>=</span> effectStack<span>[</span>effectStack<span>.</span>length <span>-</span> <span>1</span><span>]</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="track-依赖追踪"> track 依赖追踪</h2>
<ol>
<li>找依赖的响应对象</li>
<li>找响应对象的键对应的依赖列表</li>
<li><code>activeEffect.deps</code> 中添加 <code>Set&lt;Effect&gt;</code></li>
</ol>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>track</span><span>(</span>target<span>:</span> object<span>,</span> <span>type</span><span>:</span> TrackOpTypes<span>,</span> key<span>:</span> <span>unknown</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>shouldTrack <span>||</span> activeEffect <span>===</span> <span>undefined</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>let</span> depsMap <span>=</span> targetMap<span>.</span><span>get</span><span>(</span>target<span>)</span>
  <span>if</span> <span>(</span>depsMap <span>===</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
    targetMap<span>.</span><span>set</span><span>(</span>target<span>,</span> <span>(</span>depsMap <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>)</span><span>)</span>
  <span>}</span>
  <span>let</span> dep <span>=</span> depsMap<span>.</span><span>get</span><span>(</span>key<span>)</span>
  <span>if</span> <span>(</span>dep <span>===</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
    depsMap<span>.</span><span>set</span><span>(</span>key<span>,</span> <span>(</span>dep <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span><span>)</span><span>)</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>!</span>dep<span>.</span><span>has</span><span>(</span>activeEffect<span>)</span><span>)</span> <span>{</span>
    <span>// 将 activeEffect 添加进依赖列表</span>
    dep<span>.</span><span>add</span><span>(</span>activeEffect<span>)</span>
    activeEffect<span>.</span>deps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
    <span>if</span> <span>(</span>__DEV__ <span>&amp;&amp;</span> activeEffect<span>.</span>options<span>.</span>onTrack<span>)</span> <span>{</span>
      <span>// 触发 onTrack 钩子函数</span>
      activeEffect<span>.</span>options<span>.</span><span>onTrack</span><span>(</span><span>{</span>
        effect<span>:</span> activeEffect<span>,</span>
        target<span>,</span>
        <span>type</span><span>,</span>
        key
      <span>}</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="响应式数据改变后-通知-effect"> 响应式数据改变后，通知 effect</h2>
<p><a href="./handler.html#createSetter">setter 解析</a></p>
<h2 id="trigger"> trigger</h2>
<ol>
<li>根据 <code>target</code> 从 <code>targetMap</code> 中获取 <code>depsMap</code></li>
<li>根据 <code>key</code> 从 <code>depsMap</code> 中得到 <code>effects</code></li>
<li>将 <code>effects</code> 分发到内部的 <code>effects</code> 和 <code>computedRunners</code> 中</li>
<li>遍历调用内部 <code>effects</code> 和 <code>computedRunners</code> 中的 <code>effect</code></li>
</ol>
<div><pre><code><span>export</span> <span>function</span> <span>trigger</span><span>(</span>
  target<span>:</span> object<span>,</span>
  <span>type</span><span>:</span> TriggerOpTypes<span>,</span>
  key<span>?</span><span>:</span> <span>unknown</span><span>,</span>
  newValue<span>?</span><span>:</span> <span>unknown</span><span>,</span>
  oldValue<span>?</span><span>:</span> <span>unknown</span><span>,</span>
  oldTarget<span>?</span><span>:</span> Map<span>&lt;</span><span>unknown</span><span>,</span> <span>unknown</span><span>></span> <span>|</span> Set<span>&lt;</span><span>unknown</span><span>></span>
<span>)</span> <span>{</span>
  <span>const</span> depsMap <span>=</span> targetMap<span>.</span><span>get</span><span>(</span>target<span>)</span>
  <span>if</span> <span>(</span>depsMap <span>===</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
    <span>// never been tracked</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> effects <span>=</span> <span>new</span> <span>Set<span>&lt;</span>ReactiveEffect<span>></span></span><span>(</span><span>)</span>
  <span>const</span> computedRunners <span>=</span> <span>new</span> <span>Set<span>&lt;</span>ReactiveEffect<span>></span></span><span>(</span><span>)</span>
  <span>if</span> <span>(</span><span>type</span> <span>===</span> TriggerOpTypes<span>.</span><span>CLEAR</span><span>)</span> <span>{</span>
    <span>// collection being cleared</span>
    <span>// trigger all effects for target</span>
    <span>// Map 对象是由 forEach 方法的 map.forEach((value, key, map) => { ... })</span>
    depsMap<span>.</span><span>forEach</span><span>(</span>dep <span>=></span> <span>{</span>
      <span>addRunners</span><span>(</span>effects<span>,</span> computedRunners<span>,</span> dep<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>key <span>===</span> <span>'length'</span> <span>&amp;&amp;</span> <span>isArray</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>
    depsMap<span>.</span><span>forEach</span><span>(</span><span>(</span>dep<span>,</span> key<span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>key <span>===</span> <span>'length'</span> <span>||</span> key <span>>=</span> <span>(</span>newValue <span>as</span> <span>number</span><span>)</span><span>)</span> <span>{</span>
        <span>addRunners</span><span>(</span>effects<span>,</span> computedRunners<span>,</span> dep<span>)</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// schedule runs for SET | ADD | DELETE</span>
    <span>if</span> <span>(</span>key <span>!==</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
      <span>addRunners</span><span>(</span>effects<span>,</span> computedRunners<span>,</span> depsMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>)</span>
    <span>}</span>
    <span>// also run for iteration key on ADD | DELETE | Map.SET</span>
    <span>if</span> <span>(</span>
      <span>type</span> <span>===</span> TriggerOpTypes<span>.</span><span>ADD</span> <span>||</span>
      <span>type</span> <span>===</span> TriggerOpTypes<span>.</span><span>DELETE</span> <span>||</span>
      <span>(</span><span>type</span> <span>===</span> TriggerOpTypes<span>.</span><span>SET</span> <span>&amp;&amp;</span> target <span>instanceof</span> <span>Map</span><span>)</span>
    <span>)</span> <span>{</span>
      <span>const</span> iterationKey <span>=</span> <span>isArray</span><span>(</span>target<span>)</span> <span>?</span> <span>'length'</span> <span>:</span> <span>ITERATE_KEY</span>
      <span>addRunners</span><span>(</span>effects<span>,</span> computedRunners<span>,</span> depsMap<span>.</span><span>get</span><span>(</span>iterationKey<span>)</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>const</span> <span>run</span> <span>=</span> <span>(</span>effect<span>:</span> ReactiveEffect<span>)</span> <span>=></span> <span>{</span>
    <span>scheduleRun</span><span>(</span>
      effect<span>,</span>
      target<span>,</span>
      <span>type</span><span>,</span>
      key<span>,</span>
      __DEV__
        <span>?</span> <span>{</span>
            newValue<span>,</span>
            oldValue<span>,</span>
            oldTarget
          <span>}</span>
        <span>:</span> <span>undefined</span>
    <span>)</span>
  <span>}</span>
  <span>// Important: computed effects must be run first so that computed getters</span>
  <span>// can be invalidated before any normal effects that depend on them are run.</span>
  computedRunners<span>.</span><span>forEach</span><span>(</span>run<span>)</span>
  effects<span>.</span><span>forEach</span><span>(</span>run<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><details><summary>查看addRunners函数细节</summary>
<p>一个在 <code>effect</code> 中使用的对象可能既是响应式对象，又是某计算属性依赖的对象。
此时要将这二者对应的 <code>effect</code> 区分开来（触发时，先触发计算 <code>effect</code>）</p>
<div><pre><code><span>function</span> <span>addRunners</span><span>(</span>
  effects<span>:</span> Set<span>&lt;</span>ReactiveEffect<span>></span><span>,</span>
  computedRunners<span>:</span> Set<span>&lt;</span>ReactiveEffect<span>></span><span>,</span>
  effectsToAdd<span>:</span> Set<span>&lt;</span>ReactiveEffect<span>></span> <span>|</span> <span>undefined</span>
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>effectsToAdd <span>!==</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
    effectsToAdd<span>.</span><span>forEach</span><span>(</span>effect <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>effect <span>!==</span> activeEffect<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>effect<span>.</span>options<span>.</span>computed<span>)</span> <span>{</span>
          computedRunners<span>.</span><span>add</span><span>(</span>effect<span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          effects<span>.</span><span>add</span><span>(</span>effect<span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>// the effect mutated its own dependency during its execution.</span>
        <span>// this can be caused by operations like foo.value++</span>
        <span>// do not trigger or we end in an infinite loop</span>
      <span>}</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>
<h2 id="schedulerun"> scheduleRun</h2>
<p>最终调用 <code>effect</code> 的逻辑</p>
<div><pre><code><span>function</span> <span>scheduleRun</span><span>(</span>
  effect<span>:</span> ReactiveEffect<span>,</span>
  target<span>:</span> object<span>,</span>
  <span>type</span><span>:</span> TriggerOpTypes<span>,</span>
  key<span>:</span> <span>unknown</span><span>,</span>
  extraInfo<span>?</span><span>:</span> DebuggerEventExtraInfo
<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>effect<span>.</span>options<span>.</span>scheduler <span>!==</span> <span>void</span> <span>0</span><span>)</span> <span>{</span>
    effect<span>.</span>options<span>.</span><span>scheduler</span><span>(</span>effect<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>effect</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">handlers</title>
    <id>https://x-vic.gitee.io/code/code/views/vue-next/handler/</id>
    <link href="https://x-vic.gitee.io/code/code/views/vue-next/handler/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mutablehandlers-常规对象使用的-handler"> mutableHandlers 常规对象使用的 handler</h2>
<h3 id="creategetter"> createGetter</h3>
<p><code>Reflect</code>将一些明显属于语言内部的方法(Object.defineProperty)，放到 Reflect 中，作为它的静态方法。</p>
<ol>
<li>target 是数组，并且有调用的数组的<code>includes</code>, <code>indexOf</code>, <code>lastIndexOf</code>方法时，提前返回结果</li>
<li>通过<code>Reflect</code>回到将要返回的值</li>
<li>判断键是否为<code>Symbol</code>，如果是，提前返回结果</li>
<li>判断是否浅包装（只代理第一层属性）</li>
<li>判断是否为<code>Ref</code>对象，如果是，返回<code>ref.value</code></li>
<li><code>track</code>依赖追踪（收集）</li>
<li>递归进行响应式代理</li>
</ol>
<div><pre><code><span>function</span> <span>createGetter</span><span>(</span>isReadonly <span>=</span> <span>false</span><span>,</span> shallow <span>=</span> <span>false</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>get</span><span>(</span>target<span>:</span> object<span>,</span> key<span>:</span> <span>string</span> <span>|</span> <span>symbol</span><span>,</span> receiver<span>:</span> object<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isArray</span><span>(</span>target<span>)</span> <span>&amp;&amp;</span> <span>hasOwn</span><span>(</span>arrayInstrumentations<span>,</span> key<span>)</span><span>)</span> <span>{</span>
      <span>return</span> Reflect<span>.</span><span>get</span><span>(</span>arrayInstrumentations<span>,</span> key<span>,</span> receiver<span>)</span>
    <span>}</span>
    <span>// receiver： 在读取属性中遇到 this 的访问，则将 this 指向 传入的 receiver</span>
    <span>const</span> res <span>=</span> Reflect<span>.</span><span>get</span><span>(</span>target<span>,</span> key<span>,</span> receiver<span>)</span>
    <span>if</span> <span>(</span><span>isSymbol</span><span>(</span>key<span>)</span> <span>&amp;&amp;</span> builtInSymbols<span>.</span><span>has</span><span>(</span>key<span>)</span><span>)</span> <span>{</span>
      <span>return</span> res
    <span>}</span>
    <span>if</span> <span>(</span>shallow<span>)</span> <span>{</span>
      <span>track</span><span>(</span>target<span>,</span> TrackOpTypes<span>.</span><span>GET</span><span>,</span> key<span>)</span>
      <span>return</span> res
    <span>}</span>
    <span>if</span> <span>(</span><span>isRef</span><span>(</span>res<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isArray</span><span>(</span>target<span>)</span><span>)</span> <span>{</span>
      <span>return</span> res<span>.</span>value
    <span>}</span>
    <span>track</span><span>(</span>target<span>,</span> TrackOpTypes<span>.</span><span>GET</span><span>,</span> key<span>)</span>
    <span>return</span> <span>isObject</span><span>(</span>res<span>)</span>
      <span>?</span> isReadonly
        <span>?</span> <span>readonly</span><span>(</span>res<span>)</span>
        <span>:</span> <span>reactive</span><span>(</span>res<span>)</span>
      <span>:</span> res
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="createsetter"> createSetter</h3>
<ol>
<li>通过 <code>Reflect.set</code> 修改属性值</li>
<li>调用 <code>trigger</code></li>
</ol>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>function</span> <span>createSetter</span><span>(</span>isReadonly <span>=</span> <span>false</span><span>,</span> shallow <span>=</span> <span>false</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>set</span><span>(</span>
    target<span>:</span> object<span>,</span>
    key<span>:</span> <span>string</span> <span>|</span> <span>symbol</span><span>,</span>
    value<span>:</span> <span>unknown</span><span>,</span>
    receiver<span>:</span> object
  <span>)</span><span>:</span> <span>boolean</span> <span>{</span>
    <span>// ...开发环境下警告不允许修改 readOnly 数据</span>

    <span>const</span> oldValue <span>=</span> <span>(</span>target <span>as</span> <span>any</span><span>)</span><span>[</span>key<span>]</span>
    <span>if</span> <span>(</span><span>!</span>shallow<span>)</span> <span>{</span>
      value <span>=</span> <span>toRaw</span><span>(</span>value<span>)</span>
      <span>// 如果修改的属性是一个 Ref 对象，则自动展开 ref 的 value 属性，修改其 value 值</span>
      <span>if</span> <span>(</span><span>!</span><span>isArray</span><span>(</span>target<span>)</span> <span>&amp;&amp;</span> <span>isRef</span><span>(</span>oldValue<span>)</span> <span>&amp;&amp;</span> <span>!</span><span>isRef</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
        oldValue<span>.</span>value <span>=</span> value
        <span>return</span> <span>true</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>// in shallow mode, objects are set as-is regardless of reactive or not</span>
    <span>}</span>

    <span>const</span> hadKey <span>=</span> <span>hasOwn</span><span>(</span>target<span>,</span> key<span>)</span>
    <span>const</span> result <span>=</span> Reflect<span>.</span><span>set</span><span>(</span>target<span>,</span> key<span>,</span> value<span>,</span> receiver<span>)</span>
    <span>// don't trigger if target is something up in the prototype chain of original</span>
    <span>if</span> <span>(</span>target <span>===</span> <span>toRaw</span><span>(</span>receiver<span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>hadKey<span>)</span> <span>{</span>
        <span>trigger</span><span>(</span>target<span>,</span> TriggerOpTypes<span>.</span><span>ADD</span><span>,</span> key<span>,</span> value<span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>hasChanged</span><span>(</span>value<span>,</span> oldValue<span>)</span><span>)</span> <span>{</span>
        <span>trigger</span><span>(</span>target<span>,</span> TriggerOpTypes<span>.</span><span>SET</span><span>,</span> key<span>,</span> value<span>,</span> oldValue<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> result
  <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div>]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
  <entry>
    <title type="html">reactive</title>
    <id>https://x-vic.gitee.io/code/code/views/vue-next/reactive/</id>
    <link href="https://x-vic.gitee.io/code/code/views/vue-next/reactive/"/>
    <updated>2021-06-03T00:24:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="usage"> usage</h2>
<div><pre><code><span>import</span> <span>{</span> reactive <span>}</span> <span>from</span> <span>'vue'</span>

<span>const</span> obj <span>=</span> <span>reactive</span><span>(</span><span>{</span> foo<span>:</span> <span>0</span> <span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="reactive-函数"> reactive 函数</h2>
<p>该函数主要做一些对参数的判断，主要逻辑交由<code>createReactiveObject</code>函数来做</p>
<div><pre><code><span>export</span> <span>function</span> <span><span>reactive</span><span><span>&lt;</span><span>T</span> <span>extends</span> object<span>></span></span></span><span>(</span>target<span>:</span> <span>T</span><span>)</span><span>:</span> UnwrapNestedRefs<span>&lt;</span><span>T</span><span>></span>
<span>export</span> <span>function</span> <span>reactive</span><span>(</span>target<span>:</span> object<span>)</span> <span>{</span>
  <span>// ... 判断是否为 readonly、 ref，如果是则提前返回  </span>
  <span>return</span> <span>createReactiveObject</span><span>(</span>
    target<span>,</span>
    rawToReactive<span>,</span>
    reactiveToRaw<span>,</span>
    mutableHandlers<span>,</span>
    mutableCollectionHandlers
  <span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="createreactiveobject"> createReactiveObject</h2>
<ol>
<li>判断 target 是否已被代理、已经是一个 Proxy 对象、是否在被代理的白名单中（如：VNode...）</li>
<li>判断是普通对象还是 Set, Map, WeakMap, WeakSet，从而选择不同的 handler</li>
<li>保存 target -&gt; observed</li>
<li>保存 observed -&gt; target</li>
</ol>
<div><pre><code><span>function</span> <span>createReactiveObject</span><span>(</span>
  target<span>:</span> <span>unknown</span><span>,</span>
  toProxy<span>:</span> WeakMap<span>&lt;</span><span>any</span><span>,</span> <span>any</span><span>></span><span>,</span>
  toRaw<span>:</span> WeakMap<span>&lt;</span><span>any</span><span>,</span> <span>any</span><span>></span><span>,</span>
  baseHandlers<span>:</span> ProxyHandler<span>&lt;</span><span>any</span><span>></span><span>,</span>
  collectionHandlers<span>:</span> ProxyHandler<span>&lt;</span><span>any</span><span>></span>
<span>)</span> <span>{</span>
  <span>// ...判断 target 是否已被代理、已经是一个 Proxy 对象、是否在被代理的白名单中（如：VNode...）</span>
  <span>const</span> handlers <span>=</span> collectionTypes<span>.</span><span>has</span><span>(</span>target<span>.</span><span>constructor</span><span>)</span>
    <span>?</span> collectionHandlers
    <span>:</span> baseHandlers
  observed <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handlers<span>)</span>
  toProxy<span>.</span><span>set</span><span>(</span>target<span>,</span> observed<span>)</span>
  toRaw<span>.</span><span>set</span><span>(</span>observed<span>,</span> target<span>)</span>
  <span>return</span> observed
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="推荐阅读"> 推荐阅读</h2>
<p><a href="./handler.html#createGetter">getter 解析</a> </p>
]]></content>
    <author>
      <name>Vic</name>
    </author>
    <contributor>
      <name>Vic</name>
    </contributor>
    <published>2021-06-03T00:24:24.000Z</published>
    <rights>Copyright by Vic</rights>
  </entry>
</feed>